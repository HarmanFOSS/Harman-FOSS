*******************************************************************************
Date         : 2020-03-23
Author       : Xiaojun Zou
Harman International Industries, Incorporated

Description  : 1. use regex to instead search; 2. make excluding list, thread priority, supported extension, log level be configurable from MediaOne
ChangeList   : 5522940, 5523448
*******************************************************************************

diff --git a/src/makefile.am b/src/makefile.am
index e916609..8ef6deb 100755
--- a/src/makefile.am
+++ b/src/makefile.am
@@ -3,29 +3,32 @@ simple_mtpfs_CXXFLAGS = -Wall -pedantic $(FUSE_CFLAGS) $(LIBUSB1_CFLAGS)
 simple_mtpfs_CPPFLAGS = -DFUSE_USE_VERSION=28
 simple_mtpfs_LDADD    = $(MTP_LIBS) $(FUSE_LIBS) $(LIBUSB1_LIBS) -lsqlite3
 simple_mtpfs_SOURCES  =                 \
-	simple-mtpfs-fuse.h             \
-	simple-mtpfs-libmtp.h           \
-	simple-mtpfs-log.h              \
-	simple-mtpfs-mtp-device.h       \
-	simple-mtpfs-sha1.h             \
-	simple-mtpfs-tmp-files-pool.h   \
-	simple-mtpfs-type-basic.h       \
-	simple-mtpfs-type-dir.h         \
-	simple-mtpfs-type-file.h        \
-	simple-mtpfs-type-tmp-file.h    \
-	simple-mtpfs-util.h             \
-	simple-mtpfs-db.hpp             \
-	simple-mtpfs-fuse.cpp           \
-	simple-mtpfs-libmtp.cpp         \
-	simple-mtpfs-log.cpp            \
-	simple-mtpfs-main.cpp           \
-	simple-mtpfs-mtp-device.cpp     \
-	simple-mtpfs-sha1.cpp           \
-	simple-mtpfs-tmp-files-pool.cpp \
-	simple-mtpfs-type-dir.cpp       \
-	simple-mtpfs-type-file.cpp      \
-	simple-mtpfs-type-tmp-file.cpp  \
-	simple-mtpfs-util.cpp           \
-	simple-mtpfs-db.cpp             \
-	simple-mtpfs-ringbuf.h          \
-	simple-mtpfs-ringbuf.cpp
+   simple-mtpfs-fuse.h             \
+   simple-mtpfs-libmtp.h           \
+   simple-mtpfs-log.h              \
+   simple-mtpfs-mtp-device.h       \
+   simple-mtpfs-sha1.h             \
+   simple-mtpfs-tmp-files-pool.h   \
+   simple-mtpfs-type-basic.h       \
+   simple-mtpfs-type-dir.h         \
+   simple-mtpfs-type-file.h        \
+   simple-mtpfs-type-tmp-file.h    \
+   simple-mtpfs-util.h             \
+   simple-mtpfs-db.hpp             \
+   simple-mtpfs-fuse.cpp           \
+   simple-mtpfs-libmtp.cpp         \
+   simple-mtpfs-log.cpp            \
+   simple-mtpfs-main.cpp           \
+   simple-mtpfs-mtp-device.cpp     \
+   simple-mtpfs-sha1.cpp           \
+   simple-mtpfs-tmp-files-pool.cpp \
+   simple-mtpfs-type-dir.cpp       \
+   simple-mtpfs-type-file.cpp      \
+   simple-mtpfs-type-tmp-file.cpp  \
+   simple-mtpfs-util.cpp           \
+   simple-mtpfs-db.cpp             \
+   simple-mtpfs-ringbuf.h          \
+   simple-mtpfs-ringbuf.cpp        \
+   simple-mtpfs.h                  \
+   simple-mtpfs-config.h           \
+   simple-mtpfs-config.cpp
diff --git a/src/simple-mtpfs-config.cpp b/src/simple-mtpfs-config.cpp
new file mode 100755
index 0000000..aad6583
--- /dev/null
+++ b/src/simple-mtpfs-config.cpp
@@ -0,0 +1,122 @@
+/******************************************************************************
+ * Project         Harman Car Multimedia System
+ * (c) copyright   2017-2020
+ * Company         Harman Automotive Systems
+ *                 All rights reserved
+ * Secrecy Level   STRICTLY CONFIDENTIAL
+ ******************************************************************************/
+/**
+ * @file           simple-mtpfs-config.cpp
+ * @author         Xiaojun.Zou@harman.com
+ * @brief          the config for simple-mtpfs
+ */
+
+
+#include <pthread.h>
+
+#include <algorithm>
+
+#include "simple-mtpfs.h"
+#include "simple-mtpfs-config.h"
+#include "simple-mtpfs-log.h"
+
+
+Config::Config()
+: mScanThrPolicy(SCHED_OTHER)
+, mScanThrPriority(0)
+, mExcludePattern()
+{}
+
+Config::~Config()
+{}
+
+Config& Config::instance()
+{
+   static Config inst;
+
+   return inst;
+}
+
+int Config::setConfig(uint32_t type, const std::string& value)
+{
+   std::string valueLower = value;
+
+   std::transform(valueLower.begin(), valueLower.end(), valueLower.begin(), ::tolower);
+   LogInfo("config type: %x; config value: %s", type, value.c_str());
+   if (value.empty())
+   {
+      LogInfo("empty value, no need to set up");
+      return 0;
+   }
+   switch (type)
+   {
+      case SMTPFS_CONFIG_THREAD_POLICY:
+      {
+         mScanThrPolicy = atoi(value.c_str());
+      }
+      break;
+
+      case SMTPFS_CONFIG_THREAD_PRIORITY:
+      {
+         mScanThrPriority = atoi(value.c_str());
+      }
+      break;
+
+      case SMTPFS_CONFIG_EXCLUDE_PATTERN:
+      {
+         mExcludePattern = value;
+      }
+      break;
+
+      case SMTPFS_CONFIG_EXTAUDIO:
+      {
+         mExtNameAudio.push_back(valueLower);
+      }
+      break;
+
+      case SMTPFS_CONFIG_EXTVIDEO:
+      {
+         mExtNameVideo.push_back(valueLower);
+      }
+      break;
+
+      case SMTPFS_CONFIG_EXTIMAGE:
+      {
+         mExtNameImage.push_back(valueLower);
+      }
+      break;
+
+      case SMTPFS_CONFIG_EXTPLAYLIST:
+      {
+         mExtNamePlaylist.push_back(valueLower);
+      }
+      break;
+
+      case SMTPFS_CONFIG_EXTAUDIOBOOK:
+      {
+         mExtNameAudiobook.push_back(valueLower);
+      }
+      break;
+
+      case SMTPFS_CONFIG_LOGLEVEL:
+      {
+         mSMTPFSLogLevel = value;
+      }
+      break;
+
+      case SMTPFS_CONFIG_LIBMTP_LOGLEVEL:
+      {
+         mLibMTPLogLevel = value;
+      }
+      break;
+
+      default:
+      {
+         LogError("Unsupported config type: %x", type);
+         return -1;
+      }
+      break;
+   }
+
+   return 0;
+}
\ No newline at end of file
diff --git a/src/simple-mtpfs-config.h b/src/simple-mtpfs-config.h
new file mode 100755
index 0000000..c4d5566
--- /dev/null
+++ b/src/simple-mtpfs-config.h
@@ -0,0 +1,107 @@
+/******************************************************************************
+ * Project         Harman Car Multimedia System
+ * (c) copyright   2017-2020
+ * Company         Harman Automotive Systems
+ *                 All rights reserved
+ * Secrecy Level   STRICTLY CONFIDENTIAL
+ ******************************************************************************/
+/**
+ * @file           simple-mtpfs-config.h
+ * @author         Xiaojun.Zou@harman.com
+ * @brief          the config for simple-mtpfs
+ */
+
+#ifndef SMTPFS_CONFIG_H
+#define SMTPFS_CONFIG_H
+
+#include <string>
+#include <vector>
+
+
+//  config from MediaOne
+class Config
+{
+public:
+   Config();
+   ~Config();
+
+   static Config& instance();
+
+   //  set config from MediaOne.
+   int setConfig(uint32_t type, const std::string& value);
+
+   int32_t getScanThrPolicy();
+   int32_t getScanThrPriority();
+   std::string getExcPattern();
+   std::vector<std::string> getExtNameAudio();
+   std::vector<std::string> getExtNameVideo();
+   std::vector<std::string> getExtNameImage();
+   std::vector<std::string> getExtNamePlaylist();
+   std::vector<std::string> getExtNameAudiobook();
+   std::string getSMTPFSLogLevel();
+   std::string getLibMTPLogLevel();
+
+private:
+   int32_t mScanThrPolicy;
+   int32_t mScanThrPriority;
+   std::string mExcludePattern;
+   std::vector<std::string> mExtNameAudio;
+   std::vector<std::string> mExtNameVideo;
+   std::vector<std::string> mExtNameImage;
+   std::vector<std::string> mExtNamePlaylist;
+   std::vector<std::string> mExtNameAudiobook;
+   std::string mSMTPFSLogLevel;
+   std::string mLibMTPLogLevel;
+};
+
+inline int32_t Config::getScanThrPolicy()
+{
+   return mScanThrPolicy;
+}
+
+inline int32_t Config::getScanThrPriority()
+{
+   return mScanThrPriority;
+}
+
+inline std::string Config::getExcPattern()
+{
+   return mExcludePattern;
+}
+
+inline std::vector<std::string> Config::getExtNameAudio()
+{
+   return mExtNameAudio;
+}
+
+inline std::vector<std::string> Config::getExtNameVideo()
+{
+   return mExtNameVideo;
+}
+
+inline std::vector<std::string> Config::getExtNameImage()
+{
+   return mExtNameImage;
+}
+
+inline std::vector<std::string> Config::getExtNamePlaylist()
+{
+   return mExtNamePlaylist;
+}
+
+inline std::vector<std::string> Config::getExtNameAudiobook()
+{
+   return mExtNameAudiobook;
+}
+
+inline std::string Config::getSMTPFSLogLevel()
+{
+   return mSMTPFSLogLevel;
+}
+
+inline std::string Config::getLibMTPLogLevel()
+{
+   return mLibMTPLogLevel;
+}
+
+#endif
\ No newline at end of file
diff --git a/src/simple-mtpfs-fuse.cpp b/src/simple-mtpfs-fuse.cpp
index 129a458..6b0d164 100755
--- a/src/simple-mtpfs-fuse.cpp
+++ b/src/simple-mtpfs-fuse.cpp
@@ -18,176 +18,176 @@
 #include <config.h>
 #include <iostream>
 extern "C" {
-#  include <errno.h>
-#  include <fuse/fuse_opt.h>
-#  include <unistd.h>
-#  include <stddef.h>
+#include <errno.h>
+#include <fuse/fuse_opt.h>
+#include <unistd.h>
+#include <stddef.h>
 #include <poll.h>
 }
 #include "simple-mtpfs-fuse.h"
+#include "simple-mtpfs-config.h"
 #include "simple-mtpfs-log.h"
 #include "simple-mtpfs-util.h"
 
 int wrap_getattr(const char *path, struct stat *statbuf)
 {
-    LogDebug("enter getattr path:%s", path);
-    return SMTPFileSystem::instance()->getattr(path, statbuf);
+   LogDebug("enter getattr path:%s", path);
+   return SMTPFileSystem::instance()->getattr(path, statbuf);
 }
 
 int wrap_mknod(const char *path, mode_t mode, dev_t dev)
 {
-    return SMTPFileSystem::instance()->mknod(path, mode, dev);
+   return SMTPFileSystem::instance()->mknod(path, mode, dev);
 }
 
 int wrap_mkdir(const char *path, mode_t mode)
 {
-    return SMTPFileSystem::instance()->mkdir(path, mode);
+   return SMTPFileSystem::instance()->mkdir(path, mode);
 }
 
 int wrap_unlink(const char *path)
 {
-    return SMTPFileSystem::instance()->unlink(path);
+   return SMTPFileSystem::instance()->unlink(path);
 }
 
 int wrap_rmdir(const char *path)
 {
-    return SMTPFileSystem::instance()->rmdir(path);
+   return SMTPFileSystem::instance()->rmdir(path);
 }
 
 int wrap_rename(const char *path, const char *newpath)
 {
-    return SMTPFileSystem::instance()->rename(path, newpath);
+   return SMTPFileSystem::instance()->rename(path, newpath);
 }
 
 int wrap_chmod(const char *path, mode_t mode)
 {
-    return SMTPFileSystem::instance()->chmod(path, mode);
+   return SMTPFileSystem::instance()->chmod(path, mode);
 }
 
 int wrap_chown(const char *path, uid_t uid, gid_t gid)
 {
-    return SMTPFileSystem::instance()->chown(path, uid, gid);
+   return SMTPFileSystem::instance()->chown(path, uid, gid);
 }
 
 int wrap_truncate(const char *path, off_t new_size)
 {
-    return SMTPFileSystem::instance()->truncate(path, new_size);
+   return SMTPFileSystem::instance()->truncate(path, new_size);
 }
 
 int wrap_utime(const char *path, struct utimbuf *ubuf)
 {
-    return SMTPFileSystem::instance()->utime(path, ubuf);
+   return SMTPFileSystem::instance()->utime(path, ubuf);
 }
 
 int wrap_open(const char *path, struct fuse_file_info *file_info)
 {
-    //return SMTPFileSystem::instance()->open(path, file_info);
-    return 0;
+   //return SMTPFileSystem::instance()->open(path, file_info);
+   return 0;
 }
 
 int wrap_access(const char *path, int mask)
 {
-    LogDebug("enter wrap_access path:%s", path);
-    return SMTPFileSystem::instance()->access(path, mask);
+   LogDebug("enter wrap_access path:%s", path);
+   return SMTPFileSystem::instance()->access(path, mask);
 }
 
 int wrap_read(const char *path, char *buf, size_t size, off_t offset,
-    struct fuse_file_info *file_info)
+              struct fuse_file_info *file_info)
 {
-    //LogInfo("enter wrap_read[%s], size is :%d offset is:%d", path, size, offset);
-    return SMTPFileSystem::instance()->read(path, buf, size, offset, file_info);
-	
+   //LogInfo("enter wrap_read[%s], size is :%d offset is:%d", path, size, offset);
+   return SMTPFileSystem::instance()->read(path, buf, size, offset, file_info);
 }
 
 int wrap_readbuf(const char *path, struct fuse_bufvec **bufp, size_t size, off_t off, struct fuse_file_info *fileinfo)
 {
-	//LogInfo("enter wrap_readbuf[%s], size is :%d offset is:%d", path, size, off);
-	int readsize = 0;
-	struct fuse_bufvec* fbuf =(struct fuse_bufvec*)malloc(sizeof(struct fuse_bufvec));
-	if(!fbuf)
-		return -ENOENT;
-	*fbuf = FUSE_BUFVEC_INIT(size);
-	void* mem = NULL;
-	mem = malloc(size);
-	if(!mem)
-		return -ENOENT;
-	fbuf->buf[0].mem = mem;
-	readsize = SMTPFileSystem::instance()->read(path,(char*)mem,size,off,fileinfo);
-		
-	*bufp = fbuf;
-	return readsize;
+   //LogInfo("enter wrap_readbuf[%s], size is :%d offset is:%d", path, size, off);
+   int readsize = 0;
+   struct fuse_bufvec *fbuf = (struct fuse_bufvec *)malloc(sizeof(struct fuse_bufvec));
+   if (!fbuf)
+      return -ENOENT;
+   *fbuf = FUSE_BUFVEC_INIT(size);
+   void *mem = NULL;
+   mem = malloc(size);
+   if (!mem)
+      return -ENOENT;
+   fbuf->buf[0].mem = mem;
+   readsize = SMTPFileSystem::instance()->read(path, (char *)mem, size, off, fileinfo);
+
+   *bufp = fbuf;
+   return readsize;
 }
 
 int wrap_write(const char *path, const char *buf, size_t size, off_t offset,
-    struct fuse_file_info *file_info)
+               struct fuse_file_info *file_info)
 {
-    return SMTPFileSystem::instance()->write(path, buf, size, offset, file_info);
+   return SMTPFileSystem::instance()->write(path, buf, size, offset, file_info);
 }
 
 int wrap_statfs(const char *path, struct statvfs *stat_info)
 {
-    LogDebug("enter wrap_statfs, path:%s", path);
-    return SMTPFileSystem::instance()->statfs(path, stat_info);
+   LogDebug("enter wrap_statfs, path:%s", path);
+   return SMTPFileSystem::instance()->statfs(path, stat_info);
 }
 
 int wrap_flush(const char *path, struct fuse_file_info *file_info)
 {
-    LogDebug("enter wrap_flush, path:%s", path);
-    return SMTPFileSystem::instance()->flush(path, file_info);
+   LogDebug("enter wrap_flush, path:%s", path);
+   return SMTPFileSystem::instance()->flush(path, file_info);
 }
 
 int wrap_release(const char *path, struct fuse_file_info *file_info)
 {
-    LogDebug("enter wrap_release, path:%s", path);
-    //return SMTPFileSystem::instance()->release(path, file_info);
-	 return 0;
+   LogDebug("enter wrap_release, path:%s", path);
+   //return SMTPFileSystem::instance()->release(path, file_info);
+   return 0;
 }
 
 int wrap_fsync(const char *path, int datasync, struct fuse_file_info *file_info)
 {
-    LogDebug("enter wrap_fsync, path:%s", path);
-    return SMTPFileSystem::instance()->fsync(path, datasync, file_info);
+   LogDebug("enter wrap_fsync, path:%s", path);
+   return SMTPFileSystem::instance()->fsync(path, datasync, file_info);
 }
 
 int wrap_opendir(const char *path, struct fuse_file_info *file_info)
-{   
-    LogDebug("enter wrap_opendir, path:%s", path);
-    return SMTPFileSystem::instance()->opendir(path, file_info);
+{
+   LogDebug("enter wrap_opendir, path:%s", path);
+   return SMTPFileSystem::instance()->opendir(path, file_info);
 }
 
 int wrap_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
-    off_t offset, struct fuse_file_info *file_info)
+                 off_t offset, struct fuse_file_info *file_info)
 {
-    LogDebug("enter wrap_readdir, path:%s, offset:%lld", path, offset);
-    return SMTPFileSystem::instance()->readdir(path, buf, filler,
-        offset, file_info);
+   LogDebug("enter wrap_readdir, path:%s, offset:%lld", path, offset);
+   return SMTPFileSystem::instance()->readdir(path, buf, filler,
+                                              offset, file_info);
 }
 
 int wrap_releasedir(const char *path, struct fuse_file_info *file_info)
 {
-    LogDebug("enter wrap_releasedir, path:%s", path);
-    return SMTPFileSystem::instance()->releasedir(path, file_info);
+   LogDebug("enter wrap_releasedir, path:%s", path);
+   return SMTPFileSystem::instance()->releasedir(path, file_info);
 }
 
 int wrap_fsyncdir(const char *path, int datasync, struct fuse_file_info *file_info)
 {
-    LogDebug("enter wrap_fsyncdir, path:%s", path);
-    return SMTPFileSystem::instance()->fsyncdir(path, datasync, file_info);
+   LogDebug("enter wrap_fsyncdir, path:%s", path);
+   return SMTPFileSystem::instance()->fsyncdir(path, datasync, file_info);
 }
 
-void* wrap_init(struct fuse_conn_info *conn)
+void *wrap_init(struct fuse_conn_info *conn)
 {
-    return SMTPFileSystem::instance()->init(conn);
+   return SMTPFileSystem::instance()->init(conn);
 }
 
 int wrap_create(const char *path, mode_t mode, fuse_file_info *file_info)
 {
-    return SMTPFileSystem::instance()->create(path, mode, file_info);
+   return SMTPFileSystem::instance()->create(path, mode, file_info);
 }
 
 int wrap_ftruncate(const char *path, off_t offset, struct fuse_file_info *file_info)
 {
-    return SMTPFileSystem::instance()->ftruncate(path, offset, file_info);
+   return SMTPFileSystem::instance()->ftruncate(path, offset, file_info);
 }
 
 int wrap_ioctl(const char *path, int cmd, void *arg, struct fuse_file_info *file_info, unsigned int flags, void *data)
@@ -202,263 +202,270 @@ int wrap_poll(const char *path, struct fuse_file_info *file_info, struct fuse_po
    return SMTPFileSystem::instance()->poll(path, file_info, ph, reventsp);
 }
 
-
 SMTPFileSystem::SMTPFileSystemOptions::SMTPFileSystemOptions()
-    : m_good(false)
-    , m_help(false)
-    , m_version(false)
-    , m_verbose(false)
-    , m_enable_move(false)
-    , m_list_devices(false)
-    , m_device_no(1)
-    , m_device_file(nullptr)
-    , m_mount_point(nullptr)
+    : m_good(false), m_help(false), m_version(false), m_verbose(false), m_enable_move(false), m_list_devices(false), m_device_no(1), m_device_file(nullptr), m_mount_point(nullptr)
 {
 }
 
 SMTPFileSystem::SMTPFileSystemOptions::~SMTPFileSystemOptions()
 {
-    free(static_cast<void*>(m_device_file));
-    free(static_cast<void*>(m_mount_point));
+   free(static_cast<void *>(m_device_file));
+   free(static_cast<void *>(m_mount_point));
 }
 
 // -----------------------------------------------------------------------------
 
 int SMTPFileSystem::SMTPFileSystemOptions::opt_proc(void *data, const char *arg, int key,
-    struct fuse_args *outargs)
+                                                    struct fuse_args *outargs)
 {
-    SMTPFileSystemOptions *options = static_cast<SMTPFileSystemOptions*>(data);
+   SMTPFileSystemOptions *options = static_cast<SMTPFileSystemOptions *>(data);
 
-    if (key == FUSE_OPT_KEY_NONOPT) {
-        if (options->m_mount_point && options->m_device_file) {
-            // Unknown positional argument supplied
-            return -1;
-        }
-        if (options->m_device_file) {
-            fuse_opt_add_opt(&options->m_mount_point, arg);
-            return 0;
-        }
+   if (key == FUSE_OPT_KEY_NONOPT)
+   {
+      if (options->m_mount_point && options->m_device_file)
+      {
+         // Unknown positional argument supplied
+         return -1;
+      }
+      if (options->m_device_file)
+      {
+         fuse_opt_add_opt(&options->m_mount_point, arg);
+         return 0;
+      }
 
-        fuse_opt_add_opt(&options->m_device_file, arg);
-        return 0;
-    }
-    return 1;
+      fuse_opt_add_opt(&options->m_device_file, arg);
+      return 0;
+   }
+   return 1;
 }
 
 std::unique_ptr<SMTPFileSystem> SMTPFileSystem::s_instance;
 
 SMTPFileSystem *SMTPFileSystem::instance()
 {
-    if (!s_instance.get())
-        s_instance.reset(new SMTPFileSystem());
-    return s_instance.get();
-}
-
-SMTPFileSystem::SMTPFileSystem():
-    m_args(),
-    m_tmp_files_pool(),
-    m_options(),
-    m_device()
-   //  selectFd(0LL)
-{
-    m_fuse_operations.getattr = wrap_getattr;
-    m_fuse_operations.readlink = nullptr;
-    m_fuse_operations.getdir = nullptr;
-    m_fuse_operations.mknod = nullptr;//wrap_mknod;
-    m_fuse_operations.mkdir = nullptr;//wrap_mkdir;
-    m_fuse_operations.unlink = nullptr;//wrap_unlink;
-    m_fuse_operations.rmdir = nullptr;//wrap_rmdir;
-    m_fuse_operations.symlink = nullptr;
-    m_fuse_operations.rename = nullptr;//wrap_rename;
-    m_fuse_operations.link = nullptr;
-    m_fuse_operations.chmod = nullptr;//wrap_chmod;
-    m_fuse_operations.chown = nullptr;//wrap_chown;
-    m_fuse_operations.truncate = nullptr;//wrap_truncate;
-    m_fuse_operations.utime = nullptr;//wrap_utime;
-    m_fuse_operations.open = wrap_open;
-    m_fuse_operations.read = wrap_read;
-	m_fuse_operations.read_buf = wrap_readbuf;//nullptr;//wrap_readbuf;
-    m_fuse_operations.write = nullptr;//wrap_write;
-    m_fuse_operations.statfs = wrap_statfs;
-    m_fuse_operations.flush = wrap_flush;
-    m_fuse_operations.release = wrap_release;
-    m_fuse_operations.fsync = wrap_fsync;
-    m_fuse_operations.setxattr = nullptr;
-    m_fuse_operations.getxattr = nullptr;
-    m_fuse_operations.listxattr = nullptr;
-    m_fuse_operations.removexattr = nullptr;
-    m_fuse_operations.opendir = wrap_opendir;
-    m_fuse_operations.readdir = wrap_readdir;
-    m_fuse_operations.releasedir = nullptr;//wrap_releasedir;
-    m_fuse_operations.fsyncdir = nullptr;//wrap_fsyncdir;
-    m_fuse_operations.init = wrap_init;
-    m_fuse_operations.destroy = nullptr;
-    m_fuse_operations.access = wrap_access;
-    m_fuse_operations.create = nullptr;//wrap_create;
-    m_fuse_operations.ftruncate = nullptr;//wrap_ftruncate;
-    m_fuse_operations.fgetattr = nullptr;
-    m_fuse_operations.ioctl = wrap_ioctl;
-    m_fuse_operations.poll = wrap_poll;
+   if (!s_instance.get())
+      s_instance.reset(new SMTPFileSystem());
+   return s_instance.get();
+}
+
+SMTPFileSystem::SMTPFileSystem() : m_args(),
+                                   m_tmp_files_pool(),
+                                   m_options(),
+                                   m_device()
+//  selectFd(0LL)
+{
+   m_fuse_operations.getattr = wrap_getattr;
+   m_fuse_operations.readlink = nullptr;
+   m_fuse_operations.getdir = nullptr;
+   m_fuse_operations.mknod = nullptr;  //wrap_mknod;
+   m_fuse_operations.mkdir = nullptr;  //wrap_mkdir;
+   m_fuse_operations.unlink = nullptr; //wrap_unlink;
+   m_fuse_operations.rmdir = nullptr;  //wrap_rmdir;
+   m_fuse_operations.symlink = nullptr;
+   m_fuse_operations.rename = nullptr; //wrap_rename;
+   m_fuse_operations.link = nullptr;
+   m_fuse_operations.chmod = nullptr;    //wrap_chmod;
+   m_fuse_operations.chown = nullptr;    //wrap_chown;
+   m_fuse_operations.truncate = nullptr; //wrap_truncate;
+   m_fuse_operations.utime = nullptr;    //wrap_utime;
+   m_fuse_operations.open = wrap_open;
+   m_fuse_operations.read = wrap_read;
+   m_fuse_operations.read_buf = wrap_readbuf; //nullptr;//wrap_readbuf;
+   m_fuse_operations.write = nullptr;         //wrap_write;
+   m_fuse_operations.statfs = wrap_statfs;
+   m_fuse_operations.flush = wrap_flush;
+   m_fuse_operations.release = wrap_release;
+   m_fuse_operations.fsync = wrap_fsync;
+   m_fuse_operations.setxattr = nullptr;
+   m_fuse_operations.getxattr = nullptr;
+   m_fuse_operations.listxattr = nullptr;
+   m_fuse_operations.removexattr = nullptr;
+   m_fuse_operations.opendir = wrap_opendir;
+   m_fuse_operations.readdir = wrap_readdir;
+   m_fuse_operations.releasedir = nullptr; //wrap_releasedir;
+   m_fuse_operations.fsyncdir = nullptr;   //wrap_fsyncdir;
+   m_fuse_operations.init = wrap_init;
+   m_fuse_operations.destroy = nullptr;
+   m_fuse_operations.access = wrap_access;
+   m_fuse_operations.create = nullptr;    //wrap_create;
+   m_fuse_operations.ftruncate = nullptr; //wrap_ftruncate;
+   m_fuse_operations.fgetattr = nullptr;
+   m_fuse_operations.ioctl = wrap_ioctl;
+   m_fuse_operations.poll = wrap_poll;
 }
 
-
 SMTPFileSystem::~SMTPFileSystem()
 {
-    fuse_opt_free_args(&m_args);
+   fuse_opt_free_args(&m_args);
    //  selectFd  = 0LL;
 }
 
 bool SMTPFileSystem::parseOptions(int argc, char **argv)
 {
-    #define SMTPFS_OPT_KEY(t, p, v) { t, offsetof(SMTPFileSystemOptions, p), v }
-
-    static struct fuse_opt smtpfs_opts[] = {
-        SMTPFS_OPT_KEY("enable-move", m_enable_move, 1),
-        SMTPFS_OPT_KEY("--device %i", m_device_no, 0),
-        SMTPFS_OPT_KEY("-l", m_list_devices, 1),
-        SMTPFS_OPT_KEY("--list-devices", m_list_devices, 1),
-        SMTPFS_OPT_KEY("-v", m_verbose, 1),
-        SMTPFS_OPT_KEY("--verbose", m_verbose, 1),
-        SMTPFS_OPT_KEY("-V", m_version, 1),
-        SMTPFS_OPT_KEY("--version", m_version, 1),
-        SMTPFS_OPT_KEY("-h", m_help, 1),
-        SMTPFS_OPT_KEY("--help", m_help, 1),
-        FUSE_OPT_END
-    };
-
-    if (argc < 2) {
-        LogError("Wrong usage");
-        m_options.m_good = false;
-        return false;
-    }
-
-    fuse_opt_free_args(&m_args);
-    m_args = FUSE_ARGS_INIT(argc, argv);
-    if (fuse_opt_parse(&m_args, &m_options, smtpfs_opts, SMTPFileSystemOptions::opt_proc) == -1) {
-        m_options.m_good = false;
-        return false;
-    }
-
-    if (m_options.m_version || m_options.m_help || m_options.m_list_devices) {
-        m_options.m_good = true;
-        return true;
-    }
-
-    if (m_options.m_device_file && !m_options.m_mount_point) {
-        m_options.m_mount_point = m_options.m_device_file;
-        m_options.m_device_file = nullptr;
-    }
-
-    if (!m_options.m_mount_point) {
-        LogError("Mount point missing");
-        m_options.m_good = false;
-        return false;
-    }
-
-    fuse_opt_add_arg(&m_args, m_options.m_mount_point);
-    fuse_opt_add_arg(&m_args, "-s");
-
-    if (m_options.m_verbose) {
-        fuse_opt_add_arg(&m_args, "-f");
-    }
-
-    --m_options.m_device_no;
-
-    // device file and -- device are mutually exclusive, fail if both set
-    if (m_options.m_device_no && m_options.m_device_file) {
-        m_options.m_good = false;
-        return false;
-    }
-
-    m_options.m_good = true;
-    return true;
+#define SMTPFS_OPT_KEY(t, p, v)                \
+   {                                           \
+      t, offsetof(SMTPFileSystemOptions, p), v \
+   }
+
+   static struct fuse_opt smtpfs_opts[] = {
+       SMTPFS_OPT_KEY("enable-move", m_enable_move, 1),
+       SMTPFS_OPT_KEY("--device %i", m_device_no, 0),
+       SMTPFS_OPT_KEY("-l", m_list_devices, 1),
+       SMTPFS_OPT_KEY("--list-devices", m_list_devices, 1),
+       SMTPFS_OPT_KEY("-v", m_verbose, 1),
+       SMTPFS_OPT_KEY("--verbose", m_verbose, 1),
+       SMTPFS_OPT_KEY("-V", m_version, 1),
+       SMTPFS_OPT_KEY("--version", m_version, 1),
+       SMTPFS_OPT_KEY("-h", m_help, 1),
+       SMTPFS_OPT_KEY("--help", m_help, 1),
+       FUSE_OPT_END};
+
+   if (argc < 2)
+   {
+      LogError("Wrong usage");
+      m_options.m_good = false;
+      return false;
+   }
+
+   fuse_opt_free_args(&m_args);
+   m_args = FUSE_ARGS_INIT(argc, argv);
+   if (fuse_opt_parse(&m_args, &m_options, smtpfs_opts, SMTPFileSystemOptions::opt_proc) == -1)
+   {
+      m_options.m_good = false;
+      return false;
+   }
+
+   if (m_options.m_version || m_options.m_help || m_options.m_list_devices)
+   {
+      m_options.m_good = true;
+      return true;
+   }
+
+   if (m_options.m_device_file && !m_options.m_mount_point)
+   {
+      m_options.m_mount_point = m_options.m_device_file;
+      m_options.m_device_file = nullptr;
+   }
+
+   if (!m_options.m_mount_point)
+   {
+      LogError("Mount point missing");
+      m_options.m_good = false;
+      return false;
+   }
+
+   fuse_opt_add_arg(&m_args, m_options.m_mount_point);
+   fuse_opt_add_arg(&m_args, "-s");
+
+   if (m_options.m_verbose)
+   {
+      fuse_opt_add_arg(&m_args, "-f");
+   }
+
+   --m_options.m_device_no;
+
+   // device file and -- device are mutually exclusive, fail if both set
+   if (m_options.m_device_no && m_options.m_device_file)
+   {
+      m_options.m_good = false;
+      return false;
+   }
+
+   m_options.m_good = true;
+   return true;
 }
 
 void SMTPFileSystem::printHelp() const
 {
-    struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
-    struct fuse_operations tmp_operations;
-    memset(&tmp_operations, 0, sizeof(tmp_operations));
-    std::cerr << "usage: " << smtpfs_basename(m_args.argv[0])
-              << " <source> mountpoint [options]\n\n"
-        << "general options:\n"
-        << "    -o opt,[opt...]        mount options\n"
-        << "    -h   --help            print help\n"
-        << "    -V   --version         print version\n\n"
-        << "simple-mtpfs options:\n"
-        << "    -v   --verbose         verbose output, implies -f\n"
-        << "    -l   --list-devices    print available devices. Supports <source> option\n"
-        << "         --device          select a device number to mount\n"
-        << "    -o enable-move         enable the move operations\n\n";
-    fuse_opt_add_arg(&args, m_args.argv[0]);
-    fuse_opt_add_arg(&args, "-ho");
-    fuse_main(args.argc, args.argv, &tmp_operations, nullptr);
-    fuse_opt_free_args(&args);
-    std::cerr << "\nReport bugs to <" << PACKAGE_BUGREPORT << ">.\n";
+   struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
+   struct fuse_operations tmp_operations;
+   memset(&tmp_operations, 0, sizeof(tmp_operations));
+   std::cerr << "usage: " << smtpfs_basename(m_args.argv[0])
+             << " <source> mountpoint [options]\n\n"
+             << "general options:\n"
+             << "    -o opt,[opt...]        mount options\n"
+             << "    -h   --help            print help\n"
+             << "    -V   --version         print version\n\n"
+             << "simple-mtpfs options:\n"
+             << "    -v   --verbose         verbose output, implies -f\n"
+             << "    -l   --list-devices    print available devices. Supports <source> option\n"
+             << "         --device          select a device number to mount\n"
+             << "    -o enable-move         enable the move operations\n\n";
+   fuse_opt_add_arg(&args, m_args.argv[0]);
+   fuse_opt_add_arg(&args, "-ho");
+   fuse_main(args.argc, args.argv, &tmp_operations, nullptr);
+   fuse_opt_free_args(&args);
+   std::cerr << "\nReport bugs to <" << PACKAGE_BUGREPORT << ">.\n";
 }
 
 void SMTPFileSystem::printVersion() const
 {
-    struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
-    struct fuse_operations tmp_operations;
-    memset(&tmp_operations, 0, sizeof(tmp_operations));
-    fuse_opt_add_arg(&args, m_args.argv[0]);
-    fuse_opt_add_arg(&args, "--version");
-    std::cout << "simple-mtpfs version " << VERSION << "\n";
-    fuse_main(args.argc, args.argv, &tmp_operations, nullptr);
-    fuse_opt_free_args(&args);
+   struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
+   struct fuse_operations tmp_operations;
+   memset(&tmp_operations, 0, sizeof(tmp_operations));
+   fuse_opt_add_arg(&args, m_args.argv[0]);
+   fuse_opt_add_arg(&args, "--version");
+   std::cout << "simple-mtpfs version " << VERSION << "\n";
+   fuse_main(args.argc, args.argv, &tmp_operations, nullptr);
+   fuse_opt_free_args(&args);
 }
 
 bool SMTPFileSystem::listDevices() const
 {
-    const std::string dev_file = m_options.m_device_file ? m_options.m_device_file : "";
+   const std::string dev_file = m_options.m_device_file ? m_options.m_device_file : "";
 
-    return MTPDevice::listDevices(m_options.m_verbose, dev_file);
+   return MTPDevice::listDevices(m_options.m_verbose, dev_file);
 }
 
 bool SMTPFileSystem::exec()
 {
-    if (!m_options.m_good)
-        return false;
+   if (!m_options.m_good)
+      return false;
 
-    if (m_options.m_version || m_options.m_help)
-        return true;
+   if (m_options.m_version || m_options.m_help)
+      return true;
 
-    if (!smtpfs_check_dir(m_options.m_mount_point)) {
-        LogError("Can not mount the device to %s", m_options.m_mount_point);
-        return false;
-    }
+   if (!smtpfs_check_dir(m_options.m_mount_point))
+   {
+      LogError("Can not mount the device to %s", m_options.m_mount_point);
+      return false;
+   }
 
-    if (!m_tmp_files_pool.createTmpDir()) {
-        LogError("Can not create a temporary directory");
-        return false;
-    }
+   if (!m_tmp_files_pool.createTmpDir())
+   {
+      LogError("Can not create a temporary directory");
+      return false;
+   }
 
-    if (m_options.m_device_file) {
-        // Try to use device file first, if provided
-        if (!m_device.connect(m_options.m_device_file))
-            return false;
-    } else {
-        // Connect to MTP device by order number, if no device file supplied
-        if (!m_device.connect(m_options.m_device_no))
-            return false;
-    }
-    m_device.enableMove(m_options.m_enable_move);
-    if (fuse_main(m_args.argc, m_args.argv, &m_fuse_operations, nullptr) > 0) {
-        return false;
-    }
+   if (m_options.m_device_file)
+   {
+      // Try to use device file first, if provided
+      if (!m_device.connect(m_options.m_device_file))
+         return false;
+   }
+   else
+   {
+      // Connect to MTP device by order number, if no device file supplied
+      if (!m_device.connect(m_options.m_device_no))
+         return false;
+   }
+   m_device.enableMove(m_options.m_enable_move);
+   if (fuse_main(m_args.argc, m_args.argv, &m_fuse_operations, nullptr) > 0)
+   {
+      return false;
+   }
 
-    LogInfo("m_device.disconnect");
-    m_device.disconnect();
-    LogInfo("m_device.disconnect ok");
+   LogInfo("m_device.disconnect");
+   m_device.disconnect();
+   LogInfo("m_device.disconnect ok");
 
-    m_tmp_files_pool.removeTmpDir();
-    LogInfo("removeTmpDir ok");
+   m_tmp_files_pool.removeTmpDir();
+   LogInfo("removeTmpDir ok");
 
-    return true;
+   return true;
 }
 
-void* SMTPFileSystem::init(struct fuse_conn_info *conn)
+void *SMTPFileSystem::init(struct fuse_conn_info *conn)
 {
    LogInfo("enter init");
    m_device.launchTasks();
@@ -470,410 +477,427 @@ int SMTPFileSystem::getattr(const char *path, struct stat *buf)
    string ioctlNode = "/";
    ioctlNode += SMTPFSIOCTLNODE;
 
-	LogDebug("enter, path: %s", path);
-	memset(buf, 0, sizeof(struct stat));
-	struct fuse_context *fc = fuse_get_context();
-	buf->st_uid = fc->uid;
-	buf->st_gid = fc->gid;
-	if (path == std::string("/")) 
-	{
-		buf->st_mode = S_IFDIR | 0775;
-		buf->st_nlink = 2;
-		LogDebug("path == '/'");
-		return 0;
-	} 
-   else if(path == ioctlNode)
+   LogDebug("enter, path: %s", path);
+   memset(buf, 0, sizeof(struct stat));
+   struct fuse_context *fc = fuse_get_context();
+   buf->st_uid = fc->uid;
+   buf->st_gid = fc->gid;
+   if (path == std::string("/"))
+   {
+      buf->st_mode = S_IFDIR | 0775;
+      buf->st_nlink = 2;
+      LogDebug("path == '/'");
+      return 0;
+   }
+   else if (path == ioctlNode)
    {
       //LogInfo("smtpfs ioctl node: %s", path);
       buf->st_ino = 0;
-      buf->st_size = 128*1024;
+      buf->st_size = 128 * 1024;
       buf->st_blocks = 512;
       buf->st_nlink = 1;
       buf->st_mode = S_IFREG | 0644;
       //LogInfo(" %s is fake file", path);
    }
-	else 
-	{
-		bool isFile = isMediaType(path);
-		std::string tmp_path(smtpfs_dirname(path));
-		std::string tmp_file(smtpfs_basename(path));
-		const TypeDir *content = m_device.dirFetchContentFromCache(tmp_path);
-		if (content) 
-		{
-			if (content->dir(tmp_file)) 
-			{
-				const TypeDir *dir = content->dir(tmp_file);
-				buf->st_ino = dir->id();
-				buf->st_mode = S_IFDIR | 0775;
-				buf->st_nlink = 2;
-				buf->st_mtime = dir->modificationDate();
-				LogDebug("path:%s is dir", path);
-				return 0;
-			} 
-			else if (content->file(tmp_file)) 
-			{
-				const TypeFile *file = content->file(tmp_file);
-				buf->st_ino = file->id();
-				buf->st_size = file->size();
-				buf->st_blocks = (file->size() / 512) + (file->size() % 512 > 0 ? 1 : 0);
-				buf->st_nlink = 1;
-				buf->st_mode = S_IFREG | 0644;
-				buf->st_mtime = file->modificationDate();
-				buf->st_ctime = buf->st_mtime;
-				buf->st_atime = buf->st_mtime;
-				LogDebug("path:%s is file", path);
-				//LogInfo("%s size: %llu", path, buf->st_size);
-				return 0;
-			} 
-		}
-
-		if(isFile)
-		{
-			//LogInfo("query file %s from db", path);
-			#ifdef MTP_HAS_DB
-			//find the file from smtpfs.db
-			uint32_t fileId = 0;
-			string pathStr = path;
-			m_device.queryFileID(pathStr, m_device.getUUID(), &fileId);
-
-			//get file info by database
-			if(fileId && !m_device.getFileInfoById(fileId, buf))
-			{
-				LogInfo("file %s exist in db", path);
-				return 0;
-			}
-			//if the file dose not exist in database
-			else 
-			#endif
-			{
-				LogError("file %s not exist in db", path);
-				return -ENOENT;
-			}
-		}
-		else
-		{
-			//check if the dir exist in database
-			buf->st_mode = S_IFDIR | 0775;
-			buf->st_nlink = 2;
-			buf->st_mtime = time(NULL);
-			LogInfo(" %s is fake dir", path);
-		}
-	}
-
-	LogDebug("exit");
-
-    return 0;
+   else
+   {
+      std::string tmp_path(smtpfs_dirname(path));
+      std::string tmp_file(smtpfs_basename(path));
+      const TypeDir *content = m_device.dirFetchContentFromCache(tmp_path);
+      if (content)
+      {
+         if (content->dir(tmp_file))
+         {
+            const TypeDir *dir = content->dir(tmp_file);
+            buf->st_ino = dir->id();
+            buf->st_mode = S_IFDIR | 0775;
+            buf->st_nlink = 2;
+            buf->st_mtime = dir->modificationDate();
+            LogDebug("path:%s is dir", path);
+            return 0;
+         }
+         else if (content->file(tmp_file))
+         {
+            const TypeFile *file = content->file(tmp_file);
+            buf->st_ino = file->id();
+            buf->st_size = file->size();
+            buf->st_blocks = (file->size() / 512) + (file->size() % 512 > 0 ? 1 : 0);
+            buf->st_nlink = 1;
+            buf->st_mode = S_IFREG | 0644;
+            buf->st_mtime = file->modificationDate();
+            buf->st_ctime = buf->st_mtime;
+            buf->st_atime = buf->st_mtime;
+            LogDebug("path:%s is file", path);
+            //LogInfo("%s size: %llu", path, buf->st_size);
+            return 0;
+         }
+         else
+         {
+            LogWarning("did not find the file: %s", path);
+         }
+      }
+      else
+      {
+         LogWarning("did not find the dir: %s;", tmp_path.c_str());
+      }
+
+      bool isFile = m_device.isMediaType(path);
+
+      if (isFile)
+      {
+// LogInfo("query file %s from db", path);
+#ifdef MTP_HAS_DB
+         //find the file from smtpfs.db
+         uint32_t fileId = 0;
+         string pathStr = path;
+         m_device.queryFileID(pathStr, m_device.getUUID(), &fileId);
+
+         //get file info by database
+         if (fileId && !m_device.getFileInfoById(fileId, buf))
+         {
+            LogInfo("file %s exist in db", path);
+            return 0;
+         }
+         //if the file dose not exist in database
+         else
+#endif
+         {
+            LogError("file %s not exist in db", path);
+            return -ENOENT;
+         }
+      }
+      else
+      {
+         //check if the dir exist in database
+         buf->st_mode = S_IFDIR | 0775;
+         buf->st_nlink = 2;
+         buf->st_mtime = time(NULL);
+         LogInfo(" %s is fake dir", path);
+      }
+   }
+
+   LogDebug("exit");
+
+   return 0;
 }
 
 int SMTPFileSystem::mknod(const char *path, mode_t mode, dev_t dev)
 {
-    if (!S_ISREG(mode))
-        return -EINVAL;
+   if (!S_ISREG(mode))
+      return -EINVAL;
 
-    std::string tmp_path = m_tmp_files_pool.makeTmpPath(std::string(path));
-    int rval = ::open(tmp_path.c_str(), O_CREAT | O_WRONLY, mode);
-    if (rval < 0)
-        return -errno;
+   std::string tmp_path = m_tmp_files_pool.makeTmpPath(std::string(path));
+   int rval = ::open(tmp_path.c_str(), O_CREAT | O_WRONLY, mode);
+   if (rval < 0)
+      return -errno;
 
-    rval = ::close(rval);
-    if (rval < 0)
-        return -errno;
+   rval = ::close(rval);
+   if (rval < 0)
+      return -errno;
 
-    m_device.filePush(tmp_path, std::string(path));
-    ::unlink(tmp_path.c_str());
-    return 0;
+   m_device.filePush(tmp_path, std::string(path));
+   ::unlink(tmp_path.c_str());
+   return 0;
 }
 
 int SMTPFileSystem::mkdir(const char *path, mode_t mode)
 {
-    return m_device.dirCreateNew(std::string(path));
+   return m_device.dirCreateNew(std::string(path));
 }
 
 int SMTPFileSystem::unlink(const char *path)
 {
-    return m_device.fileRemove(std::string(path));
+   return m_device.fileRemove(std::string(path));
 }
 
 int SMTPFileSystem::rmdir(const char *path)
 {
-    return m_device.dirRemove(std::string(path));
+   return m_device.dirRemove(std::string(path));
 }
 
 int SMTPFileSystem::rename(const char *path, const char *newpath)
 {
-    const std::string tmp_old_dirname(smtpfs_dirname(std::string(path)));
-    const std::string tmp_new_dirname(smtpfs_dirname(std::string(newpath)));
-    if (tmp_old_dirname == tmp_new_dirname)
-        return m_device.rename(std::string(path), std::string(newpath));
+   const std::string tmp_old_dirname(smtpfs_dirname(std::string(path)));
+   const std::string tmp_new_dirname(smtpfs_dirname(std::string(newpath)));
+   if (tmp_old_dirname == tmp_new_dirname)
+      return m_device.rename(std::string(path), std::string(newpath));
 
-    if (!m_options.m_enable_move)
-        return -EPERM;
+   if (!m_options.m_enable_move)
+      return -EPERM;
 
-    const std::string tmp_file = m_tmp_files_pool.makeTmpPath(std::string(newpath));
-    int rval = m_device.filePull(std::string(path), tmp_file);
-    if (rval != 0)
-        return -rval;
+   const std::string tmp_file = m_tmp_files_pool.makeTmpPath(std::string(newpath));
+   int rval = m_device.filePull(std::string(path), tmp_file);
+   if (rval != 0)
+      return -rval;
 
-    rval = m_device.filePush(tmp_file, std::string(newpath));
-    if (rval != 0)
-        return -rval;
+   rval = m_device.filePush(tmp_file, std::string(newpath));
+   if (rval != 0)
+      return -rval;
 
-    rval = m_device.fileRemove(std::string(path));
-    if (rval != 0)
-        return -rval;
+   rval = m_device.fileRemove(std::string(path));
+   if (rval != 0)
+      return -rval;
 
-    return 0;
+   return 0;
 }
 
 int SMTPFileSystem::chmod(const char *path, mode_t mode)
 {
-    return 0;
+   return 0;
 }
 
 int SMTPFileSystem::chown(const char *path, uid_t uid, gid_t gid)
 {
-    return 0;
+   return 0;
 }
 
 int SMTPFileSystem::truncate(const char *path, off_t new_size)
 {
-    const std::string tmp_path = m_tmp_files_pool.makeTmpPath(std::string(path));
-    int rval = m_device.filePull(std::string(path), tmp_path);
-    if (rval != 0) {
-        ::unlink(tmp_path.c_str());
-        return -rval;
-    }
+   const std::string tmp_path = m_tmp_files_pool.makeTmpPath(std::string(path));
+   int rval = m_device.filePull(std::string(path), tmp_path);
+   if (rval != 0)
+   {
+      ::unlink(tmp_path.c_str());
+      return -rval;
+   }
 
-    rval = ::truncate(tmp_path.c_str(), new_size);
-    if (rval != 0) {
-        int errno_tmp = errno;
-        ::unlink(tmp_path.c_str());
-        return -errno_tmp;
-    }
+   rval = ::truncate(tmp_path.c_str(), new_size);
+   if (rval != 0)
+   {
+      int errno_tmp = errno;
+      ::unlink(tmp_path.c_str());
+      return -errno_tmp;
+   }
 
-    rval = m_device.fileRemove(std::string(path));
-    if (rval != 0) {
-        ::unlink(tmp_path.c_str());
-        return -rval;
-    }
+   rval = m_device.fileRemove(std::string(path));
+   if (rval != 0)
+   {
+      ::unlink(tmp_path.c_str());
+      return -rval;
+   }
 
-    rval = m_device.filePush(tmp_path, std::string(path));
-    ::unlink(tmp_path.c_str());
+   rval = m_device.filePush(tmp_path, std::string(path));
+   ::unlink(tmp_path.c_str());
 
-    if (rval != 0)
-        return -rval;
+   if (rval != 0)
+      return -rval;
 
-    return 0;
+   return 0;
 }
 
 int SMTPFileSystem::utime(const char *path, struct utimbuf *ubuf)
 {
-    std::string tmp_basename(smtpfs_basename(std::string(path)));
-    std::string tmp_dirname(smtpfs_dirname(std::string(path)));
+   std::string tmp_basename(smtpfs_basename(std::string(path)));
+   std::string tmp_dirname(smtpfs_dirname(std::string(path)));
 
-    const TypeDir *parent = m_device.dirFetchContentFromCache(tmp_dirname);
-    if (!parent)
-        return -ENOENT;
+   const TypeDir *parent = m_device.dirFetchContentFromCache(tmp_dirname);
+   if (!parent)
+      return -ENOENT;
 
-    const TypeFile *file = parent->file(tmp_basename);
-    if (!file)
-        return -ENOENT;
+   const TypeFile *file = parent->file(tmp_basename);
+   if (!file)
+      return -ENOENT;
 
-    const_cast<TypeFile*>(file)->setModificationDate(ubuf->modtime);
+   const_cast<TypeFile *>(file)->setModificationDate(ubuf->modtime);
 
-    return 0;
+   return 0;
 }
 
 int SMTPFileSystem::create(const char *path, mode_t mode, fuse_file_info *file_info)
 {
-    const std::string tmp_path = m_tmp_files_pool.makeTmpPath(std::string(path));
+   const std::string tmp_path = m_tmp_files_pool.makeTmpPath(std::string(path));
 
-    int rval = ::creat(tmp_path.c_str(), mode);
-    if (rval < 0)
-        return -errno;
+   int rval = ::creat(tmp_path.c_str(), mode);
+   if (rval < 0)
+      return -errno;
 
-    file_info->fh = rval;
-    m_tmp_files_pool.addFile(TypeTmpFile(std::string(path), tmp_path, rval, true));
-    m_device.filePush(tmp_path, std::string(path));
+   file_info->fh = rval;
+   m_tmp_files_pool.addFile(TypeTmpFile(std::string(path), tmp_path, rval, true));
+   m_device.filePush(tmp_path, std::string(path));
 
-    return 0;
+   return 0;
 }
 
 int SMTPFileSystem::open(const char *path, struct fuse_file_info *file_info)
 {
-	#if 1
-	string ioctlNode = "/";
-	ioctlNode += SMTPFSIOCTLNODE;
-    
-	if(!path || !file_info)
-	{
-		LogError("pointer NULL, path: %p, file_info: %p", path, file_info);
-		return -1;
-	}
-
-	if(path == ioctlNode)
-	{
-		// if(!selectFd)
-		// {
-		// 	uint64_t handle = 0x0807060504030201;
-		// 	//LogInfo("enter open path:%s, fh: %llx --> %llx,", path, file_info->fh, handle);
-		// 	file_info->fh = handle;
-		// 	selectFd = handle;
-		// }
-		// else
-		// {
-		// 	LogWarning("open control node had been open, please check if multi-open");
-		// }
-
-	}
-	else
-	{
-		//LogInfo("enter open path:%s, fh: %llx --> 0", path, file_info->fh);
-		file_info->fh = 0;
-	}
-
-    return 0;
-	#else
-    if (file_info->flags & O_WRONLY)
-        file_info->flags |= O_TRUNC;
-
-    const std::string std_path(path);
-
-    TypeTmpFile *tmp_file = const_cast<TypeTmpFile*>(
-        m_tmp_files_pool.getFile(std_path));
-
-    std::string tmp_path;
-    if (tmp_file) {
-        tmp_path = tmp_file->pathTmp();
-    } else {
-        tmp_path = m_tmp_files_pool.makeTmpPath(std_path);
-
-        int rval = m_device.filePull(std_path, tmp_path);
-        if (rval != 0)
-            return -rval;
-    }
-
-    int fd = ::open(tmp_path.c_str(), file_info->flags);
-    if (fd < 0) {
-        ::unlink(tmp_path.c_str());
-        return -errno;
-    }
-
-    file_info->fh = fd;
-
-    if (tmp_file)
-        tmp_file->addFileDescriptor(fd);
-    else
-        m_tmp_files_pool.addFile(TypeTmpFile(std_path, tmp_path, fd));
-
-    return 0;
-	#endif
+#if 1
+   string ioctlNode = "/";
+   ioctlNode += SMTPFSIOCTLNODE;
+
+   if (!path || !file_info)
+   {
+      LogError("pointer NULL, path: %p, file_info: %p", path, file_info);
+      return -1;
+   }
+
+   if (path == ioctlNode)
+   {
+      // if(!selectFd)
+      // {
+      // 	uint64_t handle = 0x0807060504030201;
+      // 	//LogInfo("enter open path:%s, fh: %llx --> %llx,", path, file_info->fh, handle);
+      // 	file_info->fh = handle;
+      // 	selectFd = handle;
+      // }
+      // else
+      // {
+      // 	LogWarning("open control node had been open, please check if multi-open");
+      // }
+   }
+   else
+   {
+      //LogInfo("enter open path:%s, fh: %llx --> 0", path, file_info->fh);
+      file_info->fh = 0;
+   }
+
+   return 0;
+#else
+   if (file_info->flags & O_WRONLY)
+      file_info->flags |= O_TRUNC;
+
+   const std::string std_path(path);
+
+   TypeTmpFile *tmp_file = const_cast<TypeTmpFile *>(
+       m_tmp_files_pool.getFile(std_path));
+
+   std::string tmp_path;
+   if (tmp_file)
+   {
+      tmp_path = tmp_file->pathTmp();
+   }
+   else
+   {
+      tmp_path = m_tmp_files_pool.makeTmpPath(std_path);
+
+      int rval = m_device.filePull(std_path, tmp_path);
+      if (rval != 0)
+         return -rval;
+   }
+
+   int fd = ::open(tmp_path.c_str(), file_info->flags);
+   if (fd < 0)
+   {
+      ::unlink(tmp_path.c_str());
+      return -errno;
+   }
+
+   file_info->fh = fd;
+
+   if (tmp_file)
+      tmp_file->addFileDescriptor(fd);
+   else
+      m_tmp_files_pool.addFile(TypeTmpFile(std_path, tmp_path, fd));
+
+   return 0;
+#endif
 }
 
 int SMTPFileSystem::read(const char *path, char *buf, size_t size,
-    off_t offset, struct fuse_file_info *file_info)
+                         off_t offset, struct fuse_file_info *file_info)
 {
-	int ret = 0;
-	const std::string std_path(path);
-	string ioctlNode = "/";
-	ioctlNode += SMTPFSIOCTLNODE;
+   int ret = 0;
+   const std::string std_path(path);
+   string ioctlNode = "/";
+   ioctlNode += SMTPFSIOCTLNODE;
 
-   	//LogInfo("read node: %s, size: %u, offset: %u, fh: %llx", path, size, offset, file_info->fh);
+   //LogInfo("read node: %s, size: %u, offset: %u, fh: %llx", path, size, offset, file_info->fh);
 
-	//if(buf) memset(buf, 0x00, size);
+   //if(buf) memset(buf, 0x00, size);
 
-	if(path == ioctlNode)
-	{
-		//LogInfo("read node: %s, size: %u, offset: %u, fh: %llx", path, size, offset, file_info->fh);
-		//ret = m_device.fillEvent(buf, size);
-	}
-	else
-	{
-		ret  = m_device.filesplitPull(std_path,"",size,offset,(unsigned char*)buf);
-	}
-	return ret;
+   if (path == ioctlNode)
+   {
+      //LogInfo("read node: %s, size: %u, offset: %u, fh: %llx", path, size, offset, file_info->fh);
+      //ret = m_device.fillEvent(buf, size);
+   }
+   else
+   {
+      ret = m_device.filesplitPull(std_path, "", size, offset, (unsigned char *)buf);
+   }
+   return ret;
 }
 
 int SMTPFileSystem::write(const char *path, const char *buf, size_t size,
-    off_t offset, struct fuse_file_info *file_info)
+                          off_t offset, struct fuse_file_info *file_info)
 {
-    const TypeTmpFile *tmp_file = m_tmp_files_pool.getFile(std::string(path));
-    if (!tmp_file)
-        return -EINVAL;
+   const TypeTmpFile *tmp_file = m_tmp_files_pool.getFile(std::string(path));
+   if (!tmp_file)
+      return -EINVAL;
 
-    int rval = ::pwrite(file_info->fh, buf, size, offset);
-    if (rval < 0)
-        return -errno;
+   int rval = ::pwrite(file_info->fh, buf, size, offset);
+   if (rval < 0)
+      return -errno;
 
-    const_cast<TypeTmpFile*>(tmp_file)->setModified();
-    return rval;
+   const_cast<TypeTmpFile *>(tmp_file)->setModified();
+   return rval;
 }
 
 int SMTPFileSystem::release(const char *path, struct fuse_file_info *file_info)
 {
-    int rval = ::close(file_info->fh);
-    if (rval < 0)
-        return -errno;
+   int rval = ::close(file_info->fh);
+   if (rval < 0)
+      return -errno;
 
-    const std::string std_path(path);
-    if (std_path == std::string("-"))
-        return 0;
+   const std::string std_path(path);
+   if (std_path == std::string("-"))
+      return 0;
 
-    TypeTmpFile *tmp_file = const_cast<TypeTmpFile*>(
-        m_tmp_files_pool.getFile(std_path));
-    tmp_file->removeFileDescriptor(file_info->fh);
-    if (tmp_file->refcnt() != 0)
-        return 0;
+   TypeTmpFile *tmp_file = const_cast<TypeTmpFile *>(
+       m_tmp_files_pool.getFile(std_path));
+   tmp_file->removeFileDescriptor(file_info->fh);
+   if (tmp_file->refcnt() != 0)
+      return 0;
 
-    const bool modif = tmp_file->isModified();
-    const std::string tmp_path = tmp_file->pathTmp();
-    m_tmp_files_pool.removeFile(std_path);
-    if (modif) {
-        rval = m_device.filePush(tmp_path, std_path);
-        if (rval != 0) {
-            ::unlink(tmp_path.c_str());
-            return -rval;
-        }
-    }
+   const bool modif = tmp_file->isModified();
+   const std::string tmp_path = tmp_file->pathTmp();
+   m_tmp_files_pool.removeFile(std_path);
+   if (modif)
+   {
+      rval = m_device.filePush(tmp_path, std_path);
+      if (rval != 0)
+      {
+         ::unlink(tmp_path.c_str());
+         return -rval;
+      }
+   }
 
-    ::unlink(tmp_path.c_str());
+   ::unlink(tmp_path.c_str());
 
-    return 0;
+   return 0;
 }
 
 int SMTPFileSystem::statfs(const char *path, struct statvfs *stat_info)
 {
-    uint64_t bs = 1024;
-    // XXX: linux coreutils still use bsize member to calculate free space
-    stat_info->f_bsize = static_cast<unsigned long>(bs);
-    stat_info->f_frsize = static_cast<unsigned long>(bs);
-    stat_info->f_blocks = m_device.storageTotalSize() / bs;
-    stat_info->f_bavail = m_device.storageFreeSize() / bs;
-    stat_info->f_bfree = stat_info->f_bavail;
+   uint64_t bs = 1024;
+   // XXX: linux coreutils still use bsize member to calculate free space
+   stat_info->f_bsize = static_cast<unsigned long>(bs);
+   stat_info->f_frsize = static_cast<unsigned long>(bs);
+   stat_info->f_blocks = m_device.storageTotalSize() / bs;
+   stat_info->f_bavail = m_device.storageFreeSize() / bs;
+   stat_info->f_bfree = stat_info->f_bavail;
 
-	LogInfo(" statfs");
-    return 0;
+   LogInfo(" statfs");
+   return 0;
 }
 
 int SMTPFileSystem::flush(const char *path, struct fuse_file_info *file_info)
 {
-    return 0;
+   return 0;
 }
 
 int SMTPFileSystem::fsync(const char *path, int datasync,
-    struct fuse_file_info *fi)
+                          struct fuse_file_info *fi)
 {
-    int rval = -1;
+   int rval = -1;
 #ifdef HAVE_FDATASYNC
-    if (datasync)
-        rval = ::fdatasync(fi->fh);
-    else
+   if (datasync)
+      rval = ::fdatasync(fi->fh);
+   else
 #else
-    rval = ::fsync(fi->fh);
+   rval = ::fsync(fi->fh);
 #endif
-    if (rval != 0)
-        return -errno;
-    return 0;
+       if (rval != 0)
+      return -errno;
+   return 0;
 }
 
 int SMTPFileSystem::opendir(const char *path, struct fuse_file_info *file_info)
@@ -894,13 +918,13 @@ int SMTPFileSystem::opendir(const char *path, struct fuse_file_info *file_info)
       LogError(" query path: %s is not cached", path);
       return -ENOENT;
    }
-   
+
    LogDebug(" exit opendir");
    return 0;
 }
 
 int SMTPFileSystem::readdir(const char *path, void *buf, fuse_fill_dir_t filler,
-    off_t offset, struct fuse_file_info *file_info)
+                            off_t offset, struct fuse_file_info *file_info)
 {
    LogDebug(" enter readdir, path:%s", path);
 
@@ -914,7 +938,8 @@ int SMTPFileSystem::readdir(const char *path, void *buf, fuse_fill_dir_t filler,
    const std::vector<TypeDir> dirs = content->dirs();
    const std::vector<TypeFile> files = content->files();
 
-   for (const TypeDir &d : dirs) {
+   for (const TypeDir &d : dirs)
+   {
       struct stat st;
       memset(&st, 0, sizeof(st));
       st.st_ino = d.id();
@@ -922,7 +947,8 @@ int SMTPFileSystem::readdir(const char *path, void *buf, fuse_fill_dir_t filler,
       filler(buf, d.name().c_str(), &st, 0);
    }
 
-   for (const TypeFile &f : files) {
+   for (const TypeFile &f : files)
+   {
       struct stat st;
       memset(&st, 0, sizeof(st));
       st.st_ino = f.id();
@@ -936,79 +962,79 @@ int SMTPFileSystem::readdir(const char *path, void *buf, fuse_fill_dir_t filler,
 
 int SMTPFileSystem::releasedir(const char *path, struct fuse_file_info *file_info)
 {
-    return 0;
+   return 0;
 }
 
 int SMTPFileSystem::fsyncdir(const char *path, int datasync,
-    struct fuse_file_info *file_info)
+                             struct fuse_file_info *file_info)
 {
-    return 0;
+   return 0;
 }
 
 int SMTPFileSystem::ftruncate(const char *path, off_t offset,
-    struct fuse_file_info *file_info)
+                              struct fuse_file_info *file_info)
 {
-    const TypeTmpFile *tmp_file = m_tmp_files_pool.getFile(std::string(path));
-    if (::ftruncate(file_info->fh, offset) != 0)
-        return -errno;
-    const_cast<TypeTmpFile*>(tmp_file)->setModified();
-    return 0;
+   const TypeTmpFile *tmp_file = m_tmp_files_pool.getFile(std::string(path));
+   if (::ftruncate(file_info->fh, offset) != 0)
+      return -errno;
+   const_cast<TypeTmpFile *>(tmp_file)->setModified();
+   return 0;
 }
 
 int SMTPFileSystem::access(const char *path, int mask)
 {
-	//LogInfo(" enter access, path:%s", path);
-
-	if(!path)
-	{
-		LogError("path is NULL");
-		return -EINVAL;
-	}
-
-   	bool isInCache = false;
-	//1st,check if the path is exist or not from cache pool
-	std::string tmp_basename(smtpfs_basename(std::string(path)));
-	std::string tmp_dirname(smtpfs_dirname(std::string(path)));
-	if(tmp_basename == tmp_dirname)
-	{
-		LogInfo("basename == dirname");
-		return 0;
-	}
-
-	if(tmp_basename.empty())
-	{
-		LogInfo("basename basename is empty");
-		return 0;
-	}
-
-	const TypeDir *parent = m_device.dirFetchContentFromCache(tmp_dirname);
-	if(parent)
-	{
-		const TypeFile *file = parent->file(tmp_basename);
-		if(file)
-		{
-			LogDebug("path:%s exist in cache", path);
-			isInCache = true;
-		}
-		else
-		{
-			LogDebug("path:%s not exist in cache", path);
-			isInCache = false;
-		}
-	}
-
-	if(isInCache == false)
-	{
-		//LogInfo("query from db path:%s ", path);
-		uint32_t fileId = 0;
-		#ifdef MTP_HAS_DB
-		string pathStr = path;
-		m_device.queryFileID(pathStr, m_device.getUUID(), &fileId);
-		if(!fileId)
-		{
-			LogError("not exist in db, path:%s", path);
-			return -ENOENT;
-		}
+   //LogInfo(" enter access, path:%s", path);
+
+   if (!path)
+   {
+      LogError("path is NULL");
+      return -EINVAL;
+   }
+
+   bool isInCache = false;
+   //1st,check if the path is exist or not from cache pool
+   std::string tmp_basename(smtpfs_basename(std::string(path)));
+   std::string tmp_dirname(smtpfs_dirname(std::string(path)));
+   if (tmp_basename == tmp_dirname)
+   {
+      LogInfo("basename == dirname");
+      return 0;
+   }
+
+   if (tmp_basename.empty())
+   {
+      LogInfo("basename basename is empty");
+      return 0;
+   }
+
+   const TypeDir *parent = m_device.dirFetchContentFromCache(tmp_dirname);
+   if (parent)
+   {
+      const TypeFile *file = parent->file(tmp_basename);
+      if (file)
+      {
+         LogDebug("path:%s exist in cache", path);
+         isInCache = true;
+      }
+      else
+      {
+         LogDebug("path:%s not exist in cache", path);
+         isInCache = false;
+      }
+   }
+
+   if (isInCache == false)
+   {
+      //LogInfo("query from db path:%s ", path);
+      uint32_t fileId = 0;
+#ifdef MTP_HAS_DB
+      string pathStr = path;
+      m_device.queryFileID(pathStr, m_device.getUUID(), &fileId);
+      if (!fileId)
+      {
+         LogError("not exist in db, path:%s", path);
+         return -ENOENT;
+      }
 
       // while(!m_device.indexingDone())
       // {
@@ -1021,50 +1047,50 @@ int SMTPFileSystem::access(const char *path, int mask)
       //    {
       //       sleep(1);
       //       LogInfo(" wait fileId: %u exist from mtp phone ", fileId);
-      //    } 
+      //    }
       // }
 
-      if(!m_device.isFileExist(fileId))
-	  #endif
+      if (!m_device.isFileExist(fileId))
+#endif
       {
          LogInfo(" fileId: %u not exist from mtp phone, access failed ", fileId);
          return -ENOENT;
       }
-	}
+   }
 
-	if(mask & W_OK)
-	{
-		LogInfo(" access, query W_OK return EINVAL");
-		return -EINVAL;
-	}
+   if (mask & W_OK)
+   {
+      LogInfo(" access, query W_OK return EINVAL");
+      return -EINVAL;
+   }
 
-	if(mask & X_OK)
-	{
-		LogInfo(" access, query X_OK return EINVAL");
-		return -EINVAL; 
-	}
+   if (mask & X_OK)
+   {
+      LogInfo(" access, query X_OK return EINVAL");
+      return -EINVAL;
+   }
 
-	//LogInfo("exit access");
-	return 0;
+   //LogInfo("exit access");
+   return 0;
 }
 
 int SMTPFileSystem::ioctl(const char *path, int cmd, void *arg, struct fuse_file_info *file_info, unsigned int flags, void *data)
 {
-	int ret = 0;
-	string ioctlNode = "/";
-	ioctlNode += SMTPFSIOCTLNODE;
+   int ret = 0;
+   string ioctlNode = "/";
+   ioctlNode += SMTPFSIOCTLNODE;
 
    //LogInfo("enter path:%s", path);
 
-   if(!path || !file_info)
+   if (!path || !file_info)
    {
       LogError(" invalid input pointer");
       return -1;
    }
 
-   if(ioctlNode != path)
+   if (ioctlNode != path)
    {
-	   return -ENOSYS;
+      return -ENOSYS;
    }
 
    //LogInfo("path: %s, data: %p, data: %x", path, data, data);
@@ -1074,78 +1100,105 @@ int SMTPFileSystem::ioctl(const char *path, int cmd, void *arg, struct fuse_file
       LogError("not support FUSE_IOCTL_COMPAT");
       return -ENOSYS;
    }
-   
-   switch (cmd) 
+
+   switch (cmd)
    {
-      case SMTPFS_GETEVENT:
-      {
-         //LogInfo(" cmd: SMTPFS_GETEVENT, %p, %p", data, arg);
-         ret = m_device.getEvent((char *)data, SMTPFS_EVENT_MAXLEN);
-      }break;
+   case SMTPFS_GETEVENT:
+   {
+      //LogInfo(" cmd: SMTPFS_GETEVENT, %p, %p", data, arg);
+      ret = m_device.getEvent((char *)data, SMTPFS_EVENT_MAXLEN);
+   }
+   break;
 
-      case SMTPFS_SETEVENT:
-      {
-         LogInfo(" cmd: SMTPFS_SETEVENT, %p, %p", data, arg);
-         ret = m_device.setEvent((char *)data, SMTPFS_EVENT_MAXLEN);
-      }break;
+   case SMTPFS_SETEVENT:
+   {
+      LogInfo(" cmd: SMTPFS_SETEVENT, %p, %p", data, arg);
+      ret = m_device.setEvent((char *)data, SMTPFS_EVENT_MAXLEN);
+   }
+   break;
 
-      default: 
-      {
-         //LogWarning(" unsupported cmd");
-         ret = -EINVAL;
-      }break;
-	}
+   case SMTPFS_SETCONFIG:
+   {
+      LogInfo(" cmd: SMTPFS_SETCONFIG, %p, %p", data, arg);
+      ret = ioctlSetConfig((char *)data, SMTPFS_EVENT_MAXLEN);
+   }
+
+   default:
+   {
+      //LogWarning(" unsupported cmd");
+      ret = -EINVAL;
+   }
+   break;
+   }
 
    //LogInfo(" ioctl, ret: %d", ret);
 
-	return ret;
+   return ret;
 }
 
 int SMTPFileSystem::poll(const char *path, struct fuse_file_info *file_info, struct fuse_pollhandle *ph, unsigned *reventsp)
 {
-	int ret = 0;
-	string ioctlNode = "/";
-	ioctlNode += SMTPFSIOCTLNODE;
-
-	//LogInfo("enter path:%s, fh: %llx", path, file_info->fh);
-
-	if(!path || !file_info || !ph || !reventsp)
-	{
-		LogError(" invalid input pointer");
-		return -1;;
-	}
-
-	if(ioctlNode != path)
-	{
-		return -ENOSYS;;
-	}
-
-	// if(0)//(file_info->fh != selectFd)
-	// {
-	// 	LogInfo("selectFd[%llx] != fh[%llx], not trigger poll", selectFd, file_info->fh);
-	// 	fuse_pollhandle_destroy(ph);
-	// 	return 0;
-	// }
-
-//    if(!m_device.canTriggerNotify())
-//    {
-// 	   LogInfo("not trigget poll");
-// 	   fuse_pollhandle_destroy(ph);
-// 	   return 0;
-//    }
-
-	if(ph && (false == m_device.indexingDone()))
-	{
-		//LogInfo("has event to happen, notify app");
-		*reventsp |= POLLIN;
-		fuse_notify_poll(ph);
-	}
-	else
-	{
-		//LogInfo("indexing done, not notify polling");
-		ret = -1;
-	}
-
-	//LogInfo("exit path:%s", path);
-	return ret;
+   int ret = 0;
+   string ioctlNode = "/";
+   ioctlNode += SMTPFSIOCTLNODE;
+
+   //LogInfo("enter path:%s, fh: %llx", path, file_info->fh);
+
+   if (!path || !file_info || !ph || !reventsp)
+   {
+      LogError(" invalid input pointer");
+      return -1;
+   }
+
+   if (ioctlNode != path)
+   {
+      return -ENOSYS;
+   }
+
+   // if(0)//(file_info->fh != selectFd)
+   // {
+   // 	LogInfo("selectFd[%llx] != fh[%llx], not trigger poll", selectFd, file_info->fh);
+   // 	fuse_pollhandle_destroy(ph);
+   // 	return 0;
+   // }
+
+   //    if(!m_device.canTriggerNotify())
+   //    {
+   // 	   LogInfo("not trigget poll");
+   // 	   fuse_pollhandle_destroy(ph);
+   // 	   return 0;
+   //    }
+
+   if (ph && (false == m_device.indexingDone()))
+   {
+      //LogInfo("has event to happen, notify app");
+      *reventsp |= POLLIN;
+      fuse_notify_poll(ph);
+   }
+   else
+   {
+      //LogInfo("indexing done, not notify polling");
+      ret = -1;
+   }
+
+   //LogInfo("exit path:%s", path);
+   return ret;
+}
+
+int SMTPFileSystem::ioctlSetConfig(char *data, uint32_t len)
+{
+   if (NULL == data || (len < sizeof(smtpfs_config)))
+   {
+      LogError("data: %p, len: %d", data, len);
+      return -1;
+   }
+   smtpfs_config *config = (smtpfs_config *)data;
+
+   if (len < config->len)
+   {
+      LogError("data too short; len: %u; expect len: %u", len, config->len);
+      return -1;
+   }
+
+   return Config::instance().setConfig(config->type, std::string(data + sizeof(smtpfs_config), config->len - sizeof(smtpfs_config)));
 }
\ No newline at end of file
diff --git a/src/simple-mtpfs-fuse.h b/src/simple-mtpfs-fuse.h
index 2ad6a55..88a1618 100755
--- a/src/simple-mtpfs-fuse.h
+++ b/src/simple-mtpfs-fuse.h
@@ -114,6 +114,9 @@ private:
     bool createTmpDir();
     bool removeTmpDir();
 
+    //  handle ioctl for set config
+    int ioctlSetConfig(char* data, uint32_t len);
+
     static std::unique_ptr<SMTPFileSystem> s_instance;
     struct fuse_args m_args;
     struct fuse_operations m_fuse_operations;
diff --git a/src/simple-mtpfs-log.cpp b/src/simple-mtpfs-log.cpp
index b88db11..3ac6589 100755
--- a/src/simple-mtpfs-log.cpp
+++ b/src/simple-mtpfs-log.cpp
@@ -36,26 +36,11 @@ void Logger::init()
 
     /* before smtp running, we can set log level by set the environment variable  SMTP_LOG_LEVEL */
     const char *logLevelEnv = getenv("SMTP_LOG_LEVEL");
-    if (logLevelEnv != NULL) {
-        std::string level = logLevelEnv;
-        if (level == "VERBOSE")
-            m_logLevel = SMTP_LOG_LEVEL_VERBOSE;
-        else if (level == "DEBUG")
-            m_logLevel = SMTP_LOG_LEVEL_DEBUG;
-        else if (level == "INFO")
-            m_logLevel = SMTP_LOG_LEVEL_INFO;
-        else if (level == "WARNING")
-            m_logLevel = SMTP_LOG_LEVEL_WARNING;
-        else if (level == "ERROR")
-            m_logLevel = SMTP_LOG_LEVEL_ERROR;
-        else if (level == "OFF")
-            m_logLevel = SMTP_LOG_LEVEL_OFF;
-        else
-            m_logLevel = SMTP_LOG_LEVEL_INFO;
-    } else {
-        m_logLevel = SMTP_LOG_LEVEL_INFO;
-    }
 
+   if (logLevelEnv)
+   {
+      setLogLevel(logLevelEnv);
+   }
 
     /* -- set libmtp log level start --
     Setting libmtp debug level according to the SMTP_LOG_LEVEL, libmtp log and smtp log will output to one log file
@@ -84,6 +69,34 @@ void Logger::init()
     LogInfo("logger initialized, loglevel is:%s", toString(m_logLevel).c_str());
 }
 
+void Logger::setLogLevel(const std::string &logLevel)
+{
+   // FIXME. it's not a good idea to set log level for simple-mtpfs, the log level should read config while init.
+   // And, it need a libmtp interface to set log level of libmtp.
+   if (!logLevel.empty())
+   {
+      if (logLevel == "VERBOSE")
+         m_logLevel = SMTP_LOG_LEVEL_VERBOSE;
+      else if (logLevel == "DEBUG")
+         m_logLevel = SMTP_LOG_LEVEL_DEBUG;
+      else if (logLevel == "INFO")
+         m_logLevel = SMTP_LOG_LEVEL_INFO;
+      else if (logLevel == "WARNING")
+         m_logLevel = SMTP_LOG_LEVEL_WARNING;
+      else if (logLevel == "ERROR")
+         m_logLevel = SMTP_LOG_LEVEL_ERROR;
+      else if (logLevel == "OFF")
+         m_logLevel = SMTP_LOG_LEVEL_OFF;
+      else
+         m_logLevel = SMTP_LOG_LEVEL_INFO;
+   }
+   else
+   {
+      m_logLevel = SMTP_LOG_LEVEL_INFO;
+   }
+   LogInfo("logger set log level to: %s", toString(m_logLevel).c_str());
+}
+
 void Logger::Log(const char *format, SMTP_LOG_LEVEL logLevel, const char* funcName, int line, ...)
 {
     if (m_logLevel > logLevel)
diff --git a/src/simple-mtpfs-log.h b/src/simple-mtpfs-log.h
index f736ac9..3592b7c 100755
--- a/src/simple-mtpfs-log.h
+++ b/src/simple-mtpfs-log.h
@@ -54,6 +54,7 @@ public:
 
 public:
     static void init();
+    static void setLogLevel(const std::string &logLevel);
     static void Log(const char *format, SMTP_LOG_LEVEL logLevel, const char* funcName, int line, ...);
     static bool isEnableLibmtpLog();
     static void off();
diff --git a/src/simple-mtpfs-main.cpp b/src/simple-mtpfs-main.cpp
index a2be1e8..df22da9 100755
--- a/src/simple-mtpfs-main.cpp
+++ b/src/simple-mtpfs-main.cpp
@@ -17,11 +17,14 @@
 
 #include <config.h>
 #include <iostream>
+
+#include "simple-mtpfs-config.h"
 #include "simple-mtpfs-fuse.h"
 #include "simple-mtpfs-util.h"
 
 int main(int argc, char **argv)
 {
+    Config::instance();
     Logger::init();
 
     SMTPFileSystem *filesystem = SMTPFileSystem::instance();
diff --git a/src/simple-mtpfs-mtp-device.cpp b/src/simple-mtpfs-mtp-device.cpp
index 6a66a97..b5fbb69 100755
--- a/src/simple-mtpfs-mtp-device.cpp
+++ b/src/simple-mtpfs-mtp-device.cpp
@@ -23,592 +23,629 @@
 #include <cstdlib>
 #include <pthread.h>
 extern "C" {
-#  include <unistd.h>
-#  include <sys/types.h>
-#  define _DARWIN_USE_64_BIT_INODE
-#  include <sys/stat.h>
+#include <unistd.h>
+#include <sys/types.h>
+#define _DARWIN_USE_64_BIT_INODE
+#include <sys/stat.h>
 #include <stdio.h>
 }
+
+#include "simple-mtpfs-config.h"
 #include "simple-mtpfs-fuse.h"
 #include "simple-mtpfs-libmtp.h"
 #include "simple-mtpfs-log.h"
 #include "simple-mtpfs-mtp-device.h"
 #include "simple-mtpfs-util.h"
 
+// the time out for libmtp request
+#define LIBMTP_REQUEST_TIMEOUT                  (500)
+#define LIBMTP_REQUEST_TIMEOUT_ABORT            (50000)
+
 uint32_t MTPDevice::s_root_node = ~0;
 
 static LIBMTP_mtpdevice_t *g_device = NULL;
 static MTPDevice *gMTPDev = NULL;
-#define RINGBUF_SIZE (512*1024) 
-
-MTPDevice::MTPDevice():
-	#ifdef MTP_HAS_DB
-    SIMPLE_DB(),
-	#endif
-    m_device(nullptr),
-    m_capabilities(),
-    m_device_mutex(),
-    m_root_dir(),
-    m_move_enabled(false),
-    mUUID(""),
-    m_list_all_done(0),
-    m_read_data_cmd_coming(0),
-    m_rbuf(NULL),
-    m_fileName(""),
-    m_fileId(0),
-    m_fileSize(0),
-    m_fileOffset(0),
-	m_trackList_offset(0),
-   	scanThreadRun(false),
-	isIndexingDone(false),
-	m_lastMode_sync_done(false)
+#define RINGBUF_SIZE (512 * 1024)
+
+MTPDevice::MTPDevice() :
+#ifdef MTP_HAS_DB
+                         SIMPLE_DB(),
+#endif
+                         m_device(nullptr),
+                         m_capabilities(),
+                         m_device_mutex(),
+                         m_root_dir(),
+                         m_move_enabled(false),
+                         mUUID(""),
+                         m_list_all_done(0),
+                         m_read_data_cmd_coming(0),
+                         m_rbuf(NULL),
+                         m_fileName(""),
+                         m_fileId(0),
+                         m_fileSize(0),
+                         m_fileOffset(0),
+                         m_trackList_offset(0),
+                         scanThreadRun(false),
+                         isIndexingDone(false),
+                         m_lastMode_sync_done(false),
+                         mFolderIgnored(0),
+                         mFileIgnored(0)
 {
-    gMTPDev = this;
-    sem_init(&device_connect_sem, 0, 0);
+   gMTPDev = this;
+   sem_init(&device_connect_sem, 0, 0);
 
-    StreamHelper::off();
-    LIBMTP_Init();
-    StreamHelper::on();
+   StreamHelper::off();
+   LIBMTP_Init();
+   StreamHelper::on();
 }
 
 MTPDevice::~MTPDevice()
 {
-    disconnect();
-    gMTPDev = NULL;
-    sem_destroy(&device_connect_sem);
-	scanThreadRun = false;
-	isIndexingDone = false;
-	m_lastMode_sync_done = false;
+   disconnect();
+   gMTPDev = NULL;
+   sem_destroy(&device_connect_sem);
+   scanThreadRun = false;
+   isIndexingDone = false;
+   m_lastMode_sync_done = false;
 }
 
 bool MTPDevice::connect(LIBMTP_raw_device_t *dev)
 {
-    if (m_device) {
-        LogInfo("Already connected");
-        return true;
-    }
+   if (m_device)
+   {
+      LogInfo("Already connected");
+      return true;
+   }
 
-    // Do not output LIBMTP debug stuff
-    StreamHelper::off();
-    m_device = LIBMTP_Open_Raw_Device_Uncached(dev);
-    StreamHelper::on();
+   // Do not output LIBMTP debug stuff
+   StreamHelper::off();
+   m_device = LIBMTP_Open_Raw_Device_Uncached(dev);
+   StreamHelper::on();
 
-    if (!m_device) {
-        LIBMTP_Dump_Errorstack(m_device);
-        return false;
-    }
+   if (!m_device)
+   {
+      LIBMTP_Dump_Errorstack(m_device);
+      return false;
+   }
 
-    if (!enumStorages())
-        return false;
+   if (!enumStorages())
+      return false;
 
-    // Retrieve capabilities.
-    m_capabilities = MTPDevice::getCapabilities(*this);
+   // Retrieve capabilities.
+   m_capabilities = MTPDevice::getCapabilities(*this);
 
-    g_device = m_device;
+   g_device = m_device;
 
-    char tmpStr[128] = "";
+   char tmpStr[128] = "";
 
-    LogInfo("vendor_id: %x, product_id: %x", dev->device_entry.vendor_id, dev->device_entry.product_id);
+   LogInfo("vendor_id: %x, product_id: %x", dev->device_entry.vendor_id, dev->device_entry.product_id);
 
-    //sprintf(tmpStr, "%x_%x_", dev->device_entry.vendor_id, dev->device_entry.product_id);
+   //sprintf(tmpStr, "%x_%x_", dev->device_entry.vendor_id, dev->device_entry.product_id);
 
-    string seriaID = LIBMTP_Get_Serialnumber(m_device);
+   string seriaID = LIBMTP_Get_Serialnumber(m_device);
 
-    LogInfo("seriaID: %s", seriaID.c_str());
+   LogInfo("seriaID: %s", seriaID.c_str());
 
-    mUUID = tmpStr + seriaID;
+   mUUID = tmpStr + seriaID;
 
-	#ifdef MTP_HAS_DB
-    writeDevice(mUUID);
-	#endif
-    LogInfo("connected");
-    return true;
+#ifdef MTP_HAS_DB
+   writeDevice(mUUID);
+#endif
+   LogInfo("connected");
+   return true;
 }
 
 bool MTPDevice::connect_priv(int dev_no, const std::string &dev_file)
 {
-    if (m_device) {
-        LogInfo("Already connected");
-        return true;
-    }
+   if (m_device)
+   {
+      LogInfo("Already connected");
+      return true;
+   }
 
-    int raw_devices_cnt;
-    LIBMTP_raw_device_t *raw_devices;
+   int raw_devices_cnt;
+   LIBMTP_raw_device_t *raw_devices;
 
-    // Do not output LIBMTP debug stuff
-    StreamHelper::off();
-    LIBMTP_error_number_t err = LIBMTP_Detect_Raw_Devices(
-        &raw_devices, &raw_devices_cnt);
-    StreamHelper::on();
+   // Do not output LIBMTP debug stuff
+   StreamHelper::off();
+   LIBMTP_error_number_t err = LIBMTP_Detect_Raw_Devices(
+       &raw_devices, &raw_devices_cnt);
+   StreamHelper::on();
 
-    if (err != LIBMTP_ERROR_NONE) {
-        switch(err) {
-        case LIBMTP_ERROR_NO_DEVICE_ATTACHED:
-            LogError("No raw devices found.");
-            break;
-        case LIBMTP_ERROR_CONNECTING:
-            LogError("There has been an error connecting. Exiting.");
-            break;
-        case LIBMTP_ERROR_MEMORY_ALLOCATION:
-            LogError("Encountered a Memory Allocation Error. Exiting.");
-            break;
-        case LIBMTP_ERROR_GENERAL:
-            LogError("General error occured. Exiting.");
-            break;
-        case LIBMTP_ERROR_USB_LAYER:
-            LogError("USB Layer error occured. Exiting.");
-            break;
-        default:
-            break;
-        }
-        return false;
-    }
+   if (err != LIBMTP_ERROR_NONE)
+   {
+      switch (err)
+      {
+      case LIBMTP_ERROR_NO_DEVICE_ATTACHED:
+         LogError("No raw devices found.");
+         break;
+      case LIBMTP_ERROR_CONNECTING:
+         LogError("There has been an error connecting. Exiting.");
+         break;
+      case LIBMTP_ERROR_MEMORY_ALLOCATION:
+         LogError("Encountered a Memory Allocation Error. Exiting.");
+         break;
+      case LIBMTP_ERROR_GENERAL:
+         LogError("General error occured. Exiting.");
+         break;
+      case LIBMTP_ERROR_USB_LAYER:
+         LogError("USB Layer error occured. Exiting.");
+         break;
+      default:
+         break;
+      }
+      return false;
+   }
 
 #ifndef HAVE_LIBUSB1
-    if (!dev_file.empty()) {
-        uint8_t bnum, dnum;
-        dev_no = raw_devices_cnt;
-
-        if (smtpfs_usb_devpath(dev_file, &bnum, &dnum))
-            for (dev_no = 0; dev_no < raw_devices_cnt; ++dev_no)
-                if (bnum == raw_devices[dev_no].bus_location &&
-                    dnum == raw_devices[dev_no].devnum)
-                    break;
-
-        if (dev_no == raw_devices_cnt) {
-            LogError("Can not open such device '%s'", dev_file.c_str());
-            free(static_cast<void*>(raw_devices));
-            return false;
-        }
-    }
+   if (!dev_file.empty())
+   {
+      uint8_t bnum, dnum;
+      dev_no = raw_devices_cnt;
+
+      if (smtpfs_usb_devpath(dev_file, &bnum, &dnum))
+         for (dev_no = 0; dev_no < raw_devices_cnt; ++dev_no)
+            if (bnum == raw_devices[dev_no].bus_location &&
+                dnum == raw_devices[dev_no].devnum)
+               break;
+
+      if (dev_no == raw_devices_cnt)
+      {
+         LogError("Can not open such device '%s'", dev_file.c_str());
+         free(static_cast<void *>(raw_devices));
+         return false;
+      }
+   }
 #endif // !HAVE_LIBUSB1
 
-    if (dev_no < 0 || dev_no >= raw_devices_cnt) {
-        LogError("Can not connect to device no %d", dev_no + 1);
-        free(static_cast<void*>(raw_devices));
-        return false;
-    }
+   if (dev_no < 0 || dev_no >= raw_devices_cnt)
+   {
+      LogError("Can not connect to device no %d", dev_no + 1);
+      free(static_cast<void *>(raw_devices));
+      return false;
+   }
 
-    LIBMTP_raw_device_t *raw_device = &raw_devices[dev_no];
+   LIBMTP_raw_device_t *raw_device = &raw_devices[dev_no];
 
-    char tmpStr[128] = "";
+   char tmpStr[128] = "";
 
-    LogInfo("vendor_id: %x, product_id: %x\n", raw_device->device_entry.vendor_id, raw_device->device_entry.product_id);
+   LogInfo("vendor_id: %x, product_id: %x\n", raw_device->device_entry.vendor_id, raw_device->device_entry.product_id);
 
-    sprintf(tmpStr, "%x_%x_", raw_device->device_entry.vendor_id, raw_device->device_entry.product_id);
+   sprintf(tmpStr, "%x_%x_", raw_device->device_entry.vendor_id, raw_device->device_entry.product_id);
 
-    //printf("tmpStr: %s\n", tmpStr);
+   //printf("tmpStr: %s\n", tmpStr);
 
-    // Do not output LIBMTP debug stuff
-    StreamHelper::off();
-    m_device = LIBMTP_Open_Raw_Device_Uncached(raw_device);
-    StreamHelper::on();
-    free(static_cast<void*>(raw_devices));
+   // Do not output LIBMTP debug stuff
+   StreamHelper::off();
+   m_device = LIBMTP_Open_Raw_Device_Uncached(raw_device);
+   StreamHelper::on();
+   free(static_cast<void *>(raw_devices));
 
-    if (!m_device) {
-        LIBMTP_Dump_Errorstack(m_device);
-        return false;
-    }
+   if (!m_device)
+   {
+      LIBMTP_Dump_Errorstack(m_device);
+      return false;
+   }
 
-    if (!enumStorages())
-        return false;
+   if (!enumStorages())
+      return false;
 
-    // Retrieve capabilities.
-    m_capabilities = MTPDevice::getCapabilities(*this);
+   // Retrieve capabilities.
+   m_capabilities = MTPDevice::getCapabilities(*this);
 
-    LogInfo("Connected.");
-    g_device = m_device;
+   LogInfo("Connected.");
+   g_device = m_device;
 
-    string seriaID = LIBMTP_Get_Serialnumber(m_device);
+   string seriaID = LIBMTP_Get_Serialnumber(m_device);
 
-    LogInfo("seriaID: %s", seriaID.c_str());
-    
-    mUUID = tmpStr + seriaID;
+   LogInfo("seriaID: %s", seriaID.c_str());
 
-	#ifdef MTP_HAS_DB
-    writeDevice(mUUID);
-	#endif
+   mUUID = tmpStr + seriaID;
 
-    if(m_rbuf)
-    {
-        RingBuffer_Free(m_rbuf);
-		m_rbuf = NULL;
-    }
-    //	else
-    {
-        m_rbuf = RingBuffer_Malloc(RINGBUF_SIZE);
-    }
+#ifdef MTP_HAS_DB
+   writeDevice(mUUID);
+#endif
+
+   if (m_rbuf)
+   {
+      RingBuffer_Free(m_rbuf);
+      m_rbuf = NULL;
+   }
+   //	else
+   {
+      m_rbuf = RingBuffer_Malloc(RINGBUF_SIZE);
+   }
 
-	//setLastModeSyncPath("/");
+   //setLastModeSyncPath("/");
 
-    return true;
+   return true;
 }
 
 bool MTPDevice::connect(int dev_no)
 {
-    return connect_priv(dev_no, std::string());
+   return connect_priv(dev_no, std::string());
 }
 
 #ifdef HAVE_LIBUSB1
 bool MTPDevice::connect(const std::string &dev_file)
 {
-    if (m_device) {
-        LogInfo("Already connected");
-        return true;
-    }
+   if (m_device)
+   {
+      LogInfo("Already connected");
+      return true;
+   }
 
-    LIBMTP_raw_device_t *raw_device = smtpfs_raw_device_new(dev_file);
-    if (!raw_device) {
-        LogError("Can not open such device %s", dev_file.c_str());
-        return false;
-    }
+   LIBMTP_raw_device_t *raw_device = smtpfs_raw_device_new(dev_file);
+   if (!raw_device)
+   {
+      LogError("Can not open such device %s", dev_file.c_str());
+      return false;
+   }
 
-    bool rval = connect(raw_device);
+   bool rval = connect(raw_device);
 
-    // TODO:  Smart pointer with alloc, free hooks.
-    smtpfs_raw_device_free(raw_device);
+   // TODO:  Smart pointer with alloc, free hooks.
+   smtpfs_raw_device_free(raw_device);
 
-    return rval;
+   return rval;
 }
 #else
 bool MTPDevice::connect(const std::string &dev_file)
 {
-    return connect_priv(-1, dev_file);
+   return connect_priv(-1, dev_file);
 }
 #endif
 
 void MTPDevice::disconnect()
 {
-    if (!m_device)
-        return;
-
-    LogInfo("MTPDevice::disconnect start");
-    
-	criticalEnter1();
-    LIBMTP_Release_Device(m_device);
-	criticalLeave1();
-	if (m_rbuf)
-	{
-		RingBuffer_Free(m_rbuf);
-		m_rbuf = NULL;
-	}
-    m_device = nullptr;
-    g_device = m_device;
-    mUUID = "";
-    
-    LogInfo("Disconnected ok");
+   if (!m_device)
+      return;
+
+   LogInfo("MTPDevice::disconnect start");
+
+   criticalEnter1();
+   LIBMTP_Release_Device(m_device);
+   criticalLeave1();
+   if (m_rbuf)
+   {
+      RingBuffer_Free(m_rbuf);
+      m_rbuf = NULL;
+   }
+   m_device = nullptr;
+   g_device = m_device;
+   mUUID = "";
+
+   LogInfo("Disconnected ok");
 }
 
 uint64_t MTPDevice::storageTotalSize() const
 {
-    uint64_t total = 0;
-    for (LIBMTP_devicestorage_t *s = m_device->storage; s; s = s->next)
-        total += s->MaxCapacity;
-    return total;
+   uint64_t total = 0;
+   for (LIBMTP_devicestorage_t *s = m_device->storage; s; s = s->next)
+      total += s->MaxCapacity;
+   return total;
 }
 
 uint64_t MTPDevice::storageFreeSize() const
 {
-    uint64_t free = 0;
-    for (LIBMTP_devicestorage_t *s = m_device->storage; s; s = s->next)
-        free += s->FreeSpaceInBytes;
-    return free;
+   uint64_t free = 0;
+   for (LIBMTP_devicestorage_t *s = m_device->storage; s; s = s->next)
+      free += s->FreeSpaceInBytes;
+   return free;
 }
 
 bool MTPDevice::enumStorages()
 {
-    criticalEnter();
-    LIBMTP_Clear_Errorstack(m_device);
-    if (LIBMTP_Get_Storage(m_device, LIBMTP_STORAGE_SORTBY_NOTSORTED) < 0) {
-        std::cerr << "Could not retrieve device storage.\n";
-        std::cerr << "For android phones make sure the screen is unlocked.\n";
-        LogError("Could not retrieve device storage. Exiting");
-        LIBMTP_Dump_Errorstack(m_device);
-        LIBMTP_Clear_Errorstack(m_device);
-        return false;
-    }
-    criticalLeave();
-    return true;
+   criticalEnter();
+   LIBMTP_Clear_Errorstack(m_device);
+   if (LIBMTP_Get_Storage(m_device, LIBMTP_STORAGE_SORTBY_NOTSORTED) < 0)
+   {
+      std::cerr << "Could not retrieve device storage.\n";
+      std::cerr << "For android phones make sure the screen is unlocked.\n";
+      LogError("Could not retrieve device storage. Exiting");
+      LIBMTP_Dump_Errorstack(m_device);
+      LIBMTP_Clear_Errorstack(m_device);
+      return false;
+   }
+   criticalLeave();
+   return true;
 }
 
 const TypeDir *MTPDevice::dirFetchContentFromCache(std::string path)
 {
-    //LogInfo("MTPDevice::dirFetchContentFromCache: path:%s", path.c_str());
-
-    if (false == m_root_dir.isFetched()) {
-        //int count = 0;
-        for (LIBMTP_devicestorage_t *s = m_device->storage; s; s = s->next) {
-            m_root_dir.addDir(TypeDir(s_root_node, 0, s->id, std::string(s->StorageDescription)));
-            LogInfo("path:%s addDir %s, storageid:%d", path.c_str(), s->StorageDescription, s->id);
-            LogDebug("path:%s setFetched", path.c_str());
-            m_root_dir.setFetched();
-            //count++;
-        }
-        //m_root_dir.setItemCount(count);
-        //m_root_dir.setFetchHandleDone(true);
-    }
+   //LogInfo("MTPDevice::dirFetchContentFromCache: path:%s", path.c_str());
 
-    // if (m_root_dir.dirCount() == 1)
-    //     path = '/' + m_root_dir.dirs().begin()->name() + path;
+   if (false == m_root_dir.isFetched())
+   {
+      //int count = 0;
+      for (LIBMTP_devicestorage_t *s = m_device->storage; s; s = s->next)
+      {
+         m_root_dir.addDir(TypeDir(s_root_node, 0, s->id, std::string(s->StorageDescription)));
+         LogInfo("path:%s addDir %s, storageid:%d", path.c_str(), s->StorageDescription, s->id);
+         LogDebug("path:%s setFetched", path.c_str());
+         m_root_dir.setFetched();
+         //count++;
+      }
+      //m_root_dir.setItemCount(count);
+      //m_root_dir.setFetchHandleDone(true);
+   }
 
-    if (path == "/")
-    {
-        //LogInfo("path is / , return m_root_dir");
-        return &m_root_dir;
-    }
+   // if (m_root_dir.dirCount() == 1)
+   //     path = '/' + m_root_dir.dirs().begin()->name() + path;
 
-    std::string member;
-    std::istringstream ss(path);
-    TypeDir *dir = &m_root_dir;
+   if (path == "/")
+   {
+      //LogInfo("path is / , return m_root_dir");
+      return &m_root_dir;
+   }
 
-    while (std::getline(ss, member, '/')) {
-      
-        if (member.empty())
-            continue;
+   std::string member;
+   std::istringstream ss(path);
+   TypeDir *dir = &m_root_dir;
 
-        const TypeDir *tmp = dir->dir(member);
-        if (!tmp)
-        {
-            //LogError("not found :%s", member.c_str());
-            return nullptr;
-        }
-      
-        dir = const_cast<TypeDir*>(tmp);
-    }
+   while (std::getline(ss, member, '/'))
+   {
 
-    LogDebug("dir->name: %s, exit", dir->name().c_str());
-    return dir;
-}
+      if (member.empty())
+         continue;
 
+      const TypeDir *tmp = dir->dir(member);
+      if (!tmp)
+      {
+         //LogError("not found :%s", member.c_str());
+         return nullptr;
+      }
+
+      dir = const_cast<TypeDir *>(tmp);
+   }
+
+   LogDebug("dir->name: %s, exit", dir->name().c_str());
+   return dir;
+}
 
 int MTPDevice::dirCreateNew(const std::string &path)
 {
-    const std::string tmp_basename(smtpfs_basename(path));
-    const std::string tmp_dirname(smtpfs_dirname(path));
-    const TypeDir *dir_parent = dirFetchContentFromCache(tmp_dirname);
-    if (!dir_parent || dir_parent->id() == 0) {
-        LogError("Can not remove directory %s", path.c_str());
-        return -EINVAL;
-    }
-    char *c_name = strdup(tmp_basename.c_str());
-    criticalEnter();
-    uint32_t new_id = LIBMTP_Create_Folder(m_device, c_name,
-        dir_parent->id(), dir_parent->storageid());
-    criticalLeave();
-    if (new_id == 0) {
-        LogError("Could not create directory %s", path.c_str());
-        LIBMTP_Dump_Errorstack(m_device);
-        LIBMTP_Clear_Errorstack(m_device);
-    } else {
-        const_cast<TypeDir*>(dir_parent)->addDir(TypeDir(new_id, dir_parent->id(),
-            dir_parent->storageid(), tmp_basename));
-        LogInfo("Directory %s created", path.c_str());
-    }
-    free(static_cast<void*>(c_name));
-    return new_id != 0 ? 0 : -EINVAL;
+   const std::string tmp_basename(smtpfs_basename(path));
+   const std::string tmp_dirname(smtpfs_dirname(path));
+   const TypeDir *dir_parent = dirFetchContentFromCache(tmp_dirname);
+   if (!dir_parent || dir_parent->id() == 0)
+   {
+      LogError("Can not remove directory %s", path.c_str());
+      return -EINVAL;
+   }
+   char *c_name = strdup(tmp_basename.c_str());
+   criticalEnter();
+   uint32_t new_id = LIBMTP_Create_Folder(m_device, c_name,
+                                          dir_parent->id(), dir_parent->storageid());
+   criticalLeave();
+   if (new_id == 0)
+   {
+      LogError("Could not create directory %s", path.c_str());
+      LIBMTP_Dump_Errorstack(m_device);
+      LIBMTP_Clear_Errorstack(m_device);
+   }
+   else
+   {
+      const_cast<TypeDir *>(dir_parent)->addDir(TypeDir(new_id, dir_parent->id(), dir_parent->storageid(), tmp_basename));
+      LogInfo("Directory %s created", path.c_str());
+   }
+   free(static_cast<void *>(c_name));
+   return new_id != 0 ? 0 : -EINVAL;
 }
 
 int MTPDevice::dirRemove(const std::string &path)
 {
-    const std::string tmp_basename(smtpfs_basename(path));
-    const std::string tmp_dirname(smtpfs_dirname(path));
-    const TypeDir *dir_parent = dirFetchContentFromCache(tmp_dirname);
-    const TypeDir *dir_to_remove = dir_parent ? dir_parent->dir(tmp_basename) : nullptr;
-    if (!dir_parent || !dir_to_remove || dir_parent->id() == 0) {
-        LogError("No such directory %s to remove", path.c_str());
-        return -ENOENT;
-    }
-    if (!dir_to_remove->isEmpty())
-        return -ENOTEMPTY;
-    criticalEnter();
-    int rval = LIBMTP_Delete_Object(m_device, dir_to_remove->id());
-    criticalLeave();
-    if (rval != 0){
-        LogError("Could not remove the directory %s", path.c_str());
-        LIBMTP_Dump_Errorstack(m_device);
-        LIBMTP_Clear_Errorstack(m_device);
-        return -EINVAL;
-    }
-    const_cast<TypeDir*>(dir_parent)->removeDir(*dir_to_remove);
-    LogInfo("Folder %s removed", path.c_str());
-    return 0;
+   const std::string tmp_basename(smtpfs_basename(path));
+   const std::string tmp_dirname(smtpfs_dirname(path));
+   const TypeDir *dir_parent = dirFetchContentFromCache(tmp_dirname);
+   const TypeDir *dir_to_remove = dir_parent ? dir_parent->dir(tmp_basename) : nullptr;
+   if (!dir_parent || !dir_to_remove || dir_parent->id() == 0)
+   {
+      LogError("No such directory %s to remove", path.c_str());
+      return -ENOENT;
+   }
+   if (!dir_to_remove->isEmpty())
+      return -ENOTEMPTY;
+   criticalEnter();
+   int rval = LIBMTP_Delete_Object(m_device, dir_to_remove->id());
+   criticalLeave();
+   if (rval != 0)
+   {
+      LogError("Could not remove the directory %s", path.c_str());
+      LIBMTP_Dump_Errorstack(m_device);
+      LIBMTP_Clear_Errorstack(m_device);
+      return -EINVAL;
+   }
+   const_cast<TypeDir *>(dir_parent)->removeDir(*dir_to_remove);
+   LogInfo("Folder %s removed", path.c_str());
+   return 0;
 }
 
 int MTPDevice::dirRename(const std::string &oldpath, const std::string &newpath)
 {
-    const std::string tmp_old_basename(smtpfs_basename(oldpath));
-    const std::string tmp_old_dirname(smtpfs_dirname(oldpath));
-    const std::string tmp_new_basename(smtpfs_basename(newpath));
-    const std::string tmp_new_dirname(smtpfs_dirname(newpath));
-    const TypeDir *dir_parent = dirFetchContentFromCache(tmp_old_dirname);
-    const TypeDir *dir_to_rename = dir_parent ? dir_parent->dir(tmp_old_basename) : nullptr;
-    if (!dir_parent || !dir_to_rename || dir_parent->id() == 0) {
-        LogError("can't rename %s to %s", tmp_old_basename.c_str(), tmp_new_basename.c_str());
-        return -EINVAL;
-    }
-    if (tmp_old_dirname != tmp_new_dirname) {
-        LogError("can't move %s to %s", oldpath.c_str(), newpath.c_str());
-        return -EINVAL;
-    }
+   const std::string tmp_old_basename(smtpfs_basename(oldpath));
+   const std::string tmp_old_dirname(smtpfs_dirname(oldpath));
+   const std::string tmp_new_basename(smtpfs_basename(newpath));
+   const std::string tmp_new_dirname(smtpfs_dirname(newpath));
+   const TypeDir *dir_parent = dirFetchContentFromCache(tmp_old_dirname);
+   const TypeDir *dir_to_rename = dir_parent ? dir_parent->dir(tmp_old_basename) : nullptr;
+   if (!dir_parent || !dir_to_rename || dir_parent->id() == 0)
+   {
+      LogError("can't rename %s to %s", tmp_old_basename.c_str(), tmp_new_basename.c_str());
+      return -EINVAL;
+   }
+   if (tmp_old_dirname != tmp_new_dirname)
+   {
+      LogError("can't move %s to %s", oldpath.c_str(), newpath.c_str());
+      return -EINVAL;
+   }
 
-    LIBMTP_folder_t *folder = dir_to_rename->toLIBMTPFolder();
-    criticalEnter();
-    int ret = LIBMTP_Set_Folder_Name(m_device, folder, tmp_new_basename.c_str());
-    criticalLeave();
-    free(static_cast<void*>(folder->name));
-    free(static_cast<void*>(folder));
-    if (ret != 0) {
-        LogError("can't rename %s to %s", oldpath.c_str(), tmp_new_basename.c_str());
-        LIBMTP_Dump_Errorstack(m_device);
-        LIBMTP_Clear_Errorstack(m_device);
-        return -EINVAL;
-    }
-    const_cast<TypeDir*>(dir_to_rename)->setName(tmp_new_basename);
-    LogInfo("move %s to %s", oldpath.c_str(), tmp_new_basename.c_str());
-    return 0;
+   LIBMTP_folder_t *folder = dir_to_rename->toLIBMTPFolder();
+   criticalEnter();
+   int ret = LIBMTP_Set_Folder_Name(m_device, folder, tmp_new_basename.c_str());
+   criticalLeave();
+   free(static_cast<void *>(folder->name));
+   free(static_cast<void *>(folder));
+   if (ret != 0)
+   {
+      LogError("can't rename %s to %s", oldpath.c_str(), tmp_new_basename.c_str());
+      LIBMTP_Dump_Errorstack(m_device);
+      LIBMTP_Clear_Errorstack(m_device);
+      return -EINVAL;
+   }
+   const_cast<TypeDir *>(dir_to_rename)->setName(tmp_new_basename);
+   LogInfo("move %s to %s", oldpath.c_str(), tmp_new_basename.c_str());
+   return 0;
 }
 
 int MTPDevice::rename(const std::string &oldpath, const std::string &newpath)
 {
 #ifndef SMTPFS_MOVE_BY_SET_OBJECT_PROPERTY
-    const std::string tmp_old_basename(smtpfs_basename(oldpath));
-    const std::string tmp_old_dirname(smtpfs_dirname(oldpath));
-    const std::string tmp_new_dirname(smtpfs_dirname(newpath));
-    if (tmp_old_dirname != tmp_new_dirname)
-        return -EINVAL;
-
-    const TypeDir *dir_parent = dirFetchContentFromCache(tmp_old_dirname);
-    if (!dir_parent || dir_parent->id() == 0)
-        return -EINVAL;
-    const TypeDir *dir_to_rename = dir_parent->dir(tmp_old_basename);
-    if (dir_to_rename)
-        return dirRename(oldpath, newpath);
-    else
-        return fileRename(oldpath, newpath);
+   const std::string tmp_old_basename(smtpfs_basename(oldpath));
+   const std::string tmp_old_dirname(smtpfs_dirname(oldpath));
+   const std::string tmp_new_dirname(smtpfs_dirname(newpath));
+   if (tmp_old_dirname != tmp_new_dirname)
+      return -EINVAL;
+
+   const TypeDir *dir_parent = dirFetchContentFromCache(tmp_old_dirname);
+   if (!dir_parent || dir_parent->id() == 0)
+      return -EINVAL;
+   const TypeDir *dir_to_rename = dir_parent->dir(tmp_old_basename);
+   if (dir_to_rename)
+      return dirRename(oldpath, newpath);
+   else
+      return fileRename(oldpath, newpath);
 #else
-    const std::string tmp_old_basename(smtpfs_basename(oldpath));
-    const std::string tmp_old_dirname(smtpfs_dirname(oldpath));
-    const std::string tmp_new_basename(smtpfs_basename(newpath));
-    const std::string tmp_new_dirname(smtpfs_dirname(newpath));
-    const TypeDir *dir_old_parent = dirFetchContentFromCache(tmp_old_dirname);
-    const TypeDir *dir_new_parent = dirFetchContentFromCache(tmp_new_dirname);
-    const TypeDir *dir_to_rename = dir_old_parent ? dir_old_parent->dir(tmp_old_basename) : nullptr;
-    const TypeFile *file_to_rename = dir_old_parent ? dir_old_parent->file(tmp_old_basename) : nullptr;
+   const std::string tmp_old_basename(smtpfs_basename(oldpath));
+   const std::string tmp_old_dirname(smtpfs_dirname(oldpath));
+   const std::string tmp_new_basename(smtpfs_basename(newpath));
+   const std::string tmp_new_dirname(smtpfs_dirname(newpath));
+   const TypeDir *dir_old_parent = dirFetchContentFromCache(tmp_old_dirname);
+   const TypeDir *dir_new_parent = dirFetchContentFromCache(tmp_new_dirname);
+   const TypeDir *dir_to_rename = dir_old_parent ? dir_old_parent->dir(tmp_old_basename) : nullptr;
+   const TypeFile *file_to_rename = dir_old_parent ? dir_old_parent->file(tmp_old_basename) : nullptr;
 
-    LogInfo("dir_to_rename:%x, file_to_rename:%x", dir_to_rename, file_to_rename);
+   LogInfo("dir_to_rename:%x, file_to_rename:%x", dir_to_rename, file_to_rename);
 
-    if (!dir_old_parent || !dir_new_parent || dir_old_parent->id() == 0)
-        return -EINVAL;
+   if (!dir_old_parent || !dir_new_parent || dir_old_parent->id() == 0)
+      return -EINVAL;
 
-    const TypeBasic *object_to_rename =  dir_to_rename ?
-        static_cast<const TypeBasic*>(dir_to_rename) :
-        static_cast<const TypeBasic*>(file_to_rename);
+   const TypeBasic *object_to_rename = dir_to_rename ? static_cast<const TypeBasic *>(dir_to_rename) : static_cast<const TypeBasic *>(file_to_rename);
 
-    LogInfo("object_to_rename:%x, object_to_rename->id():%d", object_to_rename, object_to_rename->id());
+   LogInfo("object_to_rename:%x, object_to_rename->id():%d", object_to_rename, object_to_rename->id());
 
-    if (!object_to_rename) {
-        LogError("No such file or directory to rename/move!");
-        return -ENOENT;
-    }
+   if (!object_to_rename)
+   {
+      LogError("No such file or directory to rename/move!");
+      return -ENOENT;
+   }
 
-    if (tmp_old_dirname != tmp_new_dirname) {
-        criticalEnter();
-        int rval = LIBMTP_Set_Object_u32(m_device, object_to_rename->id(),
-            LIBMTP_PROPERTY_ParentObject, dir_new_parent->id());
-        criticalLeave();
-        if (rval != 0) {
-            LogError("can't move %s to %s", oldpath.c_str(), newpath.c_str());
-            LIBMTP_Dump_Errorstack(m_device);
-            LIBMTP_Clear_Errorstack(m_device);
-            return -EINVAL;
-        }
-        const_cast<TypeBasic*>(object_to_rename)->setParent(dir_new_parent->id());
-    }
-    if (tmp_old_basename != tmp_new_basename) {
-        criticalEnter();
-        int rval = LIBMTP_Set_Object_String(m_device, object_to_rename->id(),
-            LIBMTP_PROPERTY_Name, tmp_new_basename.c_str());
-        criticalLeave();
-        if (rval != 0) {
-            LogError("can't move %s to %s", oldpath.c_str(), newpath.c_str());
-            LIBMTP_Dump_Errorstack(m_device);
-            LIBMTP_Clear_Errorstack(m_device);
-            return -EINVAL;
-        }
-    }
-    return 0;
+   if (tmp_old_dirname != tmp_new_dirname)
+   {
+      criticalEnter();
+      int rval = LIBMTP_Set_Object_u32(m_device, object_to_rename->id(),
+                                       LIBMTP_PROPERTY_ParentObject, dir_new_parent->id());
+      criticalLeave();
+      if (rval != 0)
+      {
+         LogError("can't move %s to %s", oldpath.c_str(), newpath.c_str());
+         LIBMTP_Dump_Errorstack(m_device);
+         LIBMTP_Clear_Errorstack(m_device);
+         return -EINVAL;
+      }
+      const_cast<TypeBasic *>(object_to_rename)->setParent(dir_new_parent->id());
+   }
+   if (tmp_old_basename != tmp_new_basename)
+   {
+      criticalEnter();
+      int rval = LIBMTP_Set_Object_String(m_device, object_to_rename->id(),
+                                          LIBMTP_PROPERTY_Name, tmp_new_basename.c_str());
+      criticalLeave();
+      if (rval != 0)
+      {
+         LogError("can't move %s to %s", oldpath.c_str(), newpath.c_str());
+         LIBMTP_Dump_Errorstack(m_device);
+         LIBMTP_Clear_Errorstack(m_device);
+         return -EINVAL;
+      }
+   }
+   return 0;
 #endif
 }
 
-int MTPDevice::filesplitPull(const std::string &src, const std::string &dst, uint32_t size, uint32_t offset, unsigned char* buf)
+int MTPDevice::filesplitPull(const std::string &src, const std::string &dst, uint32_t size, uint32_t offset, unsigned char *buf)
 {
-    bool isInCache = true;
-    int readLen = 0;
-    const std::string src_basename(smtpfs_basename(src));
-    const std::string src_dirname(smtpfs_dirname(src));
-
-    //LogInfo("basename: %s, dirname: %s", src_basename.c_str(), src_dirname.c_str());
-
-    //LogInfo("src: %s, size:%u, offset:%llu", src.c_str(), , offset);
-
-	//LogInfo("read path: %s, old path: %s", src.c_str(), m_fileName.c_str());
-
-   	if(m_fileName != src)
-	{	
-		const TypeDir *dir_parent = dirFetchContentFromCache(src_dirname);
-		const TypeFile *file_to_fetch = dir_parent ? dir_parent->file(src_basename) : nullptr;
-		if (!dir_parent) {
-			//LogDebug("dir_parent Can not fetch %s", src.c_str());
-			isInCache = false;
-		}
-
-		if (!file_to_fetch) {
-			//LogDebug("file_to_fetch No such file %s", src.c_str());
-			isInCache = false;
-		}
-
-		if(isInCache == true)
-		{
-			m_fileId = file_to_fetch->id();
-			m_fileSize = file_to_fetch->size();
-		}
-		else
-		{
-			string path = src.c_str();
-			#ifdef MTP_HAS_DB
-			queryFileID(path, getUUID(), &m_fileId);
-			if(!m_fileId)
-			#endif
-			{
-				LogError("queryFileID No such file %s", src.c_str());
-				return -EINVAL;
-			}
+   bool isInCache = true;
+   int readLen = 0;
+   const std::string src_basename(smtpfs_basename(src));
+   const std::string src_dirname(smtpfs_dirname(src));
 
-			criticalEnter1();
-			LIBMTP_file_t *file = LIBMTP_Get_Filemetadata(m_device, m_fileId);
-			criticalLeave1();
-			if(file)
-			{
-				m_fileSize = file->filesize;
-			}
-		}
+   //LogInfo("basename: %s, dirname: %s", src_basename.c_str(), src_dirname.c_str());
 
-		m_fileName = src;
-		m_fileOffset = 0;
-      	RingBuffer_Reset(m_rbuf);
-    }
+   //LogInfo("src: %s, size:%u, offset:%llu", src.c_str(), , offset);
+
+   //LogInfo("read path: %s, old path: %s", src.c_str(), m_fileName.c_str());
+
+   if (m_fileName != src)
+   {
+      const TypeDir *dir_parent = dirFetchContentFromCache(src_dirname);
+      const TypeFile *file_to_fetch = dir_parent ? dir_parent->file(src_basename) : nullptr;
+      if (!dir_parent)
+      {
+         //LogDebug("dir_parent Can not fetch %s", src.c_str());
+         isInCache = false;
+      }
+
+      if (!file_to_fetch)
+      {
+         //LogDebug("file_to_fetch No such file %s", src.c_str());
+         isInCache = false;
+      }
+
+      if (isInCache == true)
+      {
+         m_fileId = file_to_fetch->id();
+         m_fileSize = file_to_fetch->size();
+      }
+      else
+      {
+         string path = src.c_str();
+#ifdef MTP_HAS_DB
+         queryFileID(path, getUUID(), &m_fileId);
+         if (!m_fileId)
+#endif
+         {
+            LogError("queryFileID No such file %s", src.c_str());
+            return -EINVAL;
+         }
+
+         criticalEnter1();
+         LIBMTP_file_t *file = LIBMTP_Get_Filemetadata(m_device, m_fileId);
+         criticalLeave1();
+         if (file)
+         {
+            m_fileSize = file->filesize;
+         }
+      }
+
+      m_fileName = src;
+      m_fileOffset = 0;
+      RingBuffer_Reset(m_rbuf);
+   }
 
-    readLen = readByRingBuf(m_fileId, m_fileSize, size, offset, buf);
-	//if(readLen <= 0)
-    //LogInfo("%s, return dataLen: %d, ask size: %d, ask offset: %u, fileSize: %llu", src.c_str(), readLen, size, offset, m_fileSize);
-    return readLen;
+   readLen = readByRingBuf(m_fileId, m_fileSize, size, offset, buf);
+   if(readLen <= 0)
+   {
+      LogInfo("%s, return dataLen: %d, ask size: %d, ask offset: %u, fileSize: %llu", src.c_str(), readLen, size, offset, m_fileSize);
+   }
+   return readLen;
 }
 
-int MTPDevice::readByRingBuf(const uint32_t id, const uint64_t fileSize,  const uint32_t size, const uint32_t offset, const unsigned char* buf)
+int MTPDevice::readByRingBuf(const uint32_t id, const uint64_t fileSize, const uint32_t size, const uint32_t offset, const unsigned char *buf)
 {
-	//LogInfo("offset: %u, size: %u, m_fileOffset: %u, fileSize: %llu", offset, size, m_fileOffset, fileSize);
-	
-	#if 0
+//LogInfo("offset: %u, size: %u, m_fileOffset: %u, fileSize: %llu", offset, size, m_fileOffset, fileSize);
+
+#if 0
     //1st, check if the ringbuf valid or not
     if(m_rbuf == NULL)
     {   
@@ -722,305 +759,325 @@ int MTPDevice::readByRingBuf(const uint32_t id, const uint64_t fileSize,  const
     //get data from ring buf
     size_t rBufDataSize = RingBuffer_Out(m_rbuf, (void *)buf, size);
 	return rBufDataSize;
-	#else
-	{ 
-		m_read_data_cmd_coming = 1;
-        int rVal = 0;
-        uint32_t tmpLen = 0;
-        long diffTime;
-        unsigned char* tmpBuf = NULL;
-
-        long t1 = getSysRunTime();
-		//LogInfo("read get lock, 1111");
-        criticalEnter1();
-		//LogInfo("read get lock, 2222");
-        rVal = LIBMTP_GetPartialObject(m_device, id, offset, size, &tmpBuf, &tmpLen);
-		//LogInfo("read get lock, 3333");
-        criticalLeave1();
-		//LogInfo("read get lock, 4444");
-        long t2 = getSysRunTime();
-        diffTime = t2 - t1;
-        if(diffTime > 2000)
-        {
-            LogInfo("id: %d, retLen: %d, diffTime: %ld ms", id, rVal, diffTime);
-        }
-
-		m_read_data_cmd_coming = 0;
-
-        //LogInfo("LIBMTP_GetPartialObject rVal:%d, tmpLen:%d, willReadLen:%d", rVal, tmpLen, willReadLen);
-
-        if(rVal || (tmpLen > size)) 
-        {
-            LogError("LIBMTP_GetPartialObject, id: %u, rVal: %d, tmpLen[%d] < willReadLen[%d]", id, rVal, tmpLen, size);
-				
-            LIBMTP_Dump_Errorstack(m_device);
-            LIBMTP_Clear_Errorstack(m_device);
-			return -1;
-        }
-        else if(!rVal)
-		{
-			if(tmpLen && tmpBuf)
-			{ 
-				//push data into ringbuf
-				m_fileOffset += tmpLen;
-				if(m_fileOffset == fileSize)
-				{
-					m_fileOffset = 0;
-				}
-				memcpy((void *)buf, (void *)tmpBuf, tmpLen);
-				free(tmpBuf);
-				return tmpLen;
-			}  
-			else 
-			{
-				if(m_fileOffset != fileSize)
-				{
-					LogWarning("read return len == 0, ask app retry");
-					return -EAGAIN;
-				}
-				else
-				{
-					LogInfo("read reach eof");
-					return 0;
-				}
-			}
-
-		}
-    }
-	#endif
+#else
+   {
+      m_read_data_cmd_coming = 1;
+      int rVal = 0;
+      uint32_t tmpLen = 0;
+      long diffTime;
+      unsigned char *tmpBuf = NULL;
+
+      long t1 = getSysRunTime();
+      //LogInfo("read get lock, 1111");
+      criticalEnter1();
+      //LogInfo("read get lock, 2222");
+      rVal = LIBMTP_GetPartialObject(m_device, id, offset, size, &tmpBuf, &tmpLen);
+      //LogInfo("read get lock, 3333");
+      criticalLeave1();
+      //LogInfo("read get lock, 4444");
+      long t2 = getSysRunTime();
+      diffTime = t2 - t1;
+      if (diffTime > LIBMTP_REQUEST_TIMEOUT)
+      {
+         LogInfo("id: %d, retLen: %d, diffTime: %ld ms", id, rVal, diffTime);
+      }
+
+      m_read_data_cmd_coming = 0;
+
+      //LogInfo("LIBMTP_GetPartialObject rVal:%d, tmpLen:%d, willReadLen:%d", rVal, tmpLen, willReadLen);
+
+      if (rVal || (tmpLen > size))
+      {
+         LogError("LIBMTP_GetPartialObject, id: %u, rVal: %d, tmpLen[%d] < willReadLen[%d]", id, rVal, tmpLen, size);
+
+         LIBMTP_Dump_Errorstack(m_device);
+         LIBMTP_Clear_Errorstack(m_device);
+         return -1;
+      }
+      else if (!rVal)
+      {
+         if (tmpLen && tmpBuf)
+         {
+            //push data into ringbuf
+            m_fileOffset += tmpLen;
+            if (m_fileOffset == fileSize)
+            {
+               m_fileOffset = 0;
+            }
+            memcpy((void *)buf, (void *)tmpBuf, tmpLen);
+            free(tmpBuf);
+            return tmpLen;
+         }
+         else
+         {
+            if (m_fileOffset != fileSize)
+            {
+               LogWarning("read return len == 0, ask app retry");
+               return -EAGAIN;
+            }
+            else
+            {
+               LogInfo("read reach eof");
+               return 0;
+            }
+         }
+      }
+   }
+#endif
 }
 
 int MTPDevice::filePull(const std::string &src, const std::string &dst)
 {
-    const std::string src_basename(smtpfs_basename(src));
-    const std::string src_dirname(smtpfs_dirname(src));
-    const TypeDir *dir_parent = dirFetchContentFromCache(src_dirname);
-    const TypeFile *file_to_fetch = dir_parent ? dir_parent->file(src_basename) : nullptr;
-    if (!dir_parent) {
-        LogError("filePull, Can not fetch %s", src.c_str());
-        return -EINVAL;
-    }
-    if (!file_to_fetch) {
-        LogError("filePull, no such file %s", src.c_str());
-        return -ENOENT;
-    }
-    if (file_to_fetch->size() == 0) {
-        int fd = ::creat(dst.c_str(), S_IRUSR | S_IWUSR);
-        ::close(fd);
-    } else {
-        LogInfo("Started fetching %s", src.c_str());
-        criticalEnter();
-        int rval = LIBMTP_Get_File_To_File(m_device, file_to_fetch->id(),
-            dst.c_str(), nullptr, nullptr);
-        criticalLeave();
-        if (rval != 0) {
-            LogError("Could not fetch file %s", src.c_str());
-            LIBMTP_Dump_Errorstack(m_device);
-            LIBMTP_Clear_Errorstack(m_device);
-            return -ENOENT;
-        }
-    }
-    LogInfo("File %s Fetched", src.c_str());
-    return 0;
+   const std::string src_basename(smtpfs_basename(src));
+   const std::string src_dirname(smtpfs_dirname(src));
+   const TypeDir *dir_parent = dirFetchContentFromCache(src_dirname);
+   const TypeFile *file_to_fetch = dir_parent ? dir_parent->file(src_basename) : nullptr;
+   if (!dir_parent)
+   {
+      LogError("filePull, Can not fetch %s", src.c_str());
+      return -EINVAL;
+   }
+   if (!file_to_fetch)
+   {
+      LogError("filePull, no such file %s", src.c_str());
+      return -ENOENT;
+   }
+   if (file_to_fetch->size() == 0)
+   {
+      int fd = ::creat(dst.c_str(), S_IRUSR | S_IWUSR);
+      ::close(fd);
+   }
+   else
+   {
+      LogInfo("Started fetching %s", src.c_str());
+      criticalEnter();
+      int rval = LIBMTP_Get_File_To_File(m_device, file_to_fetch->id(),
+                                         dst.c_str(), nullptr, nullptr);
+      criticalLeave();
+      if (rval != 0)
+      {
+         LogError("Could not fetch file %s", src.c_str());
+         LIBMTP_Dump_Errorstack(m_device);
+         LIBMTP_Clear_Errorstack(m_device);
+         return -ENOENT;
+      }
+   }
+   LogInfo("File %s Fetched", src.c_str());
+   return 0;
 }
 
 int MTPDevice::filePush(const std::string &src, const std::string &dst)
 {
-    const std::string dst_basename(smtpfs_basename(dst));
-    const std::string dst_dirname(smtpfs_dirname(dst));
-    const TypeDir *dir_parent = dirFetchContentFromCache(dst_dirname);
-    const TypeFile *file_to_remove = dir_parent ? dir_parent->file(dst_basename) : nullptr;
-    if (dir_parent && file_to_remove) {
-        criticalEnter();
-        int rval = LIBMTP_Delete_Object(m_device, file_to_remove->id());
-        criticalLeave();
-        if (rval != 0) {
-            LogError("Can not upload %s to %s", src.c_str(), dst.c_str());
-            return -EINVAL;
-        }
-    }
+   const std::string dst_basename(smtpfs_basename(dst));
+   const std::string dst_dirname(smtpfs_dirname(dst));
+   const TypeDir *dir_parent = dirFetchContentFromCache(dst_dirname);
+   const TypeFile *file_to_remove = dir_parent ? dir_parent->file(dst_basename) : nullptr;
+   if (dir_parent && file_to_remove)
+   {
+      criticalEnter();
+      int rval = LIBMTP_Delete_Object(m_device, file_to_remove->id());
+      criticalLeave();
+      if (rval != 0)
+      {
+         LogError("Can not upload %s to %s", src.c_str(), dst.c_str());
+         return -EINVAL;
+      }
+   }
 
-    struct stat file_stat;
-    stat(src.c_str(), &file_stat);
-    TypeFile file_to_upload(0, dir_parent->id(), dir_parent->storageid(),
-        dst_basename, static_cast<uint64_t>(file_stat.st_size), 0);
-    LIBMTP_file_t *f = file_to_upload.toLIBMTPFile();
-    if (file_stat.st_size) {
-        LogInfo("Started uploading %s", dst.c_str());
-    }
-    criticalEnter();
-    int rval = LIBMTP_Send_File_From_File(m_device, src.c_str(), f, nullptr, nullptr);
-    criticalLeave();
-    if (rval != 0) {
-        LogError("Could not upload file %s", src.c_str());
-        LIBMTP_Dump_Errorstack(m_device);
-        LIBMTP_Clear_Errorstack(m_device);
-        rval = -EINVAL;
-    } else {
-        file_to_upload.setId(f->item_id);
-        file_to_upload.setParent(f->parent_id);
-        file_to_upload.setStorage(f->storage_id);
-        file_to_upload.setName(std::string(f->filename));
-        file_to_upload.setModificationDate(file_stat.st_mtime);
-        if (file_to_remove)
-            const_cast<TypeDir*>(dir_parent)->replaceFile(*file_to_remove, file_to_upload);
-        else
-            const_cast<TypeDir*>(dir_parent)->addFile(file_to_upload);
-    }
-    free(static_cast<void*>(f->filename));
-    free(static_cast<void*>(f));
-    LogInfo("File %s been %s", dst.c_str(), (file_stat.st_size ? " uploaded" : " created"));
-    return rval;
+   struct stat file_stat;
+   stat(src.c_str(), &file_stat);
+   TypeFile file_to_upload(0, dir_parent->id(), dir_parent->storageid(),
+                           dst_basename, static_cast<uint64_t>(file_stat.st_size), 0);
+   LIBMTP_file_t *f = file_to_upload.toLIBMTPFile();
+   if (file_stat.st_size)
+   {
+      LogInfo("Started uploading %s", dst.c_str());
+   }
+   criticalEnter();
+   int rval = LIBMTP_Send_File_From_File(m_device, src.c_str(), f, nullptr, nullptr);
+   criticalLeave();
+   if (rval != 0)
+   {
+      LogError("Could not upload file %s", src.c_str());
+      LIBMTP_Dump_Errorstack(m_device);
+      LIBMTP_Clear_Errorstack(m_device);
+      rval = -EINVAL;
+   }
+   else
+   {
+      file_to_upload.setId(f->item_id);
+      file_to_upload.setParent(f->parent_id);
+      file_to_upload.setStorage(f->storage_id);
+      file_to_upload.setName(std::string(f->filename));
+      file_to_upload.setModificationDate(file_stat.st_mtime);
+      if (file_to_remove)
+         const_cast<TypeDir *>(dir_parent)->replaceFile(*file_to_remove, file_to_upload);
+      else
+         const_cast<TypeDir *>(dir_parent)->addFile(file_to_upload);
+   }
+   free(static_cast<void *>(f->filename));
+   free(static_cast<void *>(f));
+   LogInfo("File %s been %s", dst.c_str(), (file_stat.st_size ? " uploaded" : " created"));
+   return rval;
 }
 
 int MTPDevice::fileRemove(const std::string &path)
 {
-    const std::string tmp_basename(smtpfs_basename(path));
-    const std::string tmp_dirname(smtpfs_dirname(path));
-    const TypeDir *dir_parent = dirFetchContentFromCache(tmp_dirname);
-    const TypeFile *file_to_remove = dir_parent ? dir_parent->file(tmp_basename) : nullptr;
-    if (!dir_parent || !file_to_remove) {
-        LogError("No such file '%s' to remove", path.c_str());
-        return -ENOENT;
-    }
-    criticalEnter();
-    int rval = LIBMTP_Delete_Object(m_device, file_to_remove->id());
-    criticalLeave();
-    if (rval != 0) {
-        LogError("Could not remove the directory '%s'", path.c_str());
-        return -EINVAL;
-    }
-    const_cast<TypeDir*>(dir_parent)->removeFile(*file_to_remove);
-    LogInfo("File '%s' removed", path.c_str());
-    return 0;
+   const std::string tmp_basename(smtpfs_basename(path));
+   const std::string tmp_dirname(smtpfs_dirname(path));
+   const TypeDir *dir_parent = dirFetchContentFromCache(tmp_dirname);
+   const TypeFile *file_to_remove = dir_parent ? dir_parent->file(tmp_basename) : nullptr;
+   if (!dir_parent || !file_to_remove)
+   {
+      LogError("No such file '%s' to remove", path.c_str());
+      return -ENOENT;
+   }
+   criticalEnter();
+   int rval = LIBMTP_Delete_Object(m_device, file_to_remove->id());
+   criticalLeave();
+   if (rval != 0)
+   {
+      LogError("Could not remove the directory '%s'", path.c_str());
+      return -EINVAL;
+   }
+   const_cast<TypeDir *>(dir_parent)->removeFile(*file_to_remove);
+   LogInfo("File '%s' removed", path.c_str());
+   return 0;
 }
 
 int MTPDevice::fileRename(const std::string &oldpath, const std::string &newpath)
 {
-    const std::string tmp_old_basename(smtpfs_basename(oldpath));
-    const std::string tmp_old_dirname(smtpfs_dirname(oldpath));
-    const std::string tmp_new_basename(smtpfs_basename(newpath));
-    const std::string tmp_new_dirname(smtpfs_dirname(newpath));
-    const TypeDir *dir_parent = dirFetchContentFromCache(tmp_old_dirname);
-    const TypeFile *file_to_rename = dir_parent ? dir_parent->file(tmp_old_basename) : nullptr;
-    if (!dir_parent || !file_to_rename || tmp_old_dirname != tmp_new_dirname) {
-        LogError("Can not rename %s to %s", oldpath.c_str(), tmp_new_basename.c_str());
-        return -EINVAL;
-    }
+   const std::string tmp_old_basename(smtpfs_basename(oldpath));
+   const std::string tmp_old_dirname(smtpfs_dirname(oldpath));
+   const std::string tmp_new_basename(smtpfs_basename(newpath));
+   const std::string tmp_new_dirname(smtpfs_dirname(newpath));
+   const TypeDir *dir_parent = dirFetchContentFromCache(tmp_old_dirname);
+   const TypeFile *file_to_rename = dir_parent ? dir_parent->file(tmp_old_basename) : nullptr;
+   if (!dir_parent || !file_to_rename || tmp_old_dirname != tmp_new_dirname)
+   {
+      LogError("Can not rename %s to %s", oldpath.c_str(), tmp_new_basename.c_str());
+      return -EINVAL;
+   }
 
-    LIBMTP_file_t *file = file_to_rename->toLIBMTPFile();
-    criticalEnter();
-    int rval = LIBMTP_Set_File_Name(m_device, file, tmp_new_basename.c_str());
-    criticalLeave();
-    free(static_cast<void*>(file->filename));
-    free(static_cast<void*>(file));
-    if (rval > 0) {
-        LogError("Can not rename %s to %s", oldpath.c_str(), newpath.c_str());
-        LIBMTP_Dump_Errorstack(m_device);
-        LIBMTP_Clear_Errorstack(m_device);
-        return -EINVAL;
-    }
-    const_cast<TypeFile*>(file_to_rename)->setName(tmp_new_basename);
-    LogError("File %s renamed to %s", oldpath.c_str(), tmp_new_basename.c_str());
-    return 0;
+   LIBMTP_file_t *file = file_to_rename->toLIBMTPFile();
+   criticalEnter();
+   int rval = LIBMTP_Set_File_Name(m_device, file, tmp_new_basename.c_str());
+   criticalLeave();
+   free(static_cast<void *>(file->filename));
+   free(static_cast<void *>(file));
+   if (rval > 0)
+   {
+      LogError("Can not rename %s to %s", oldpath.c_str(), newpath.c_str());
+      LIBMTP_Dump_Errorstack(m_device);
+      LIBMTP_Clear_Errorstack(m_device);
+      return -EINVAL;
+   }
+   const_cast<TypeFile *>(file_to_rename)->setName(tmp_new_basename);
+   LogError("File %s renamed to %s", oldpath.c_str(), tmp_new_basename.c_str());
+   return 0;
 }
 
 MTPDevice::Capabilities MTPDevice::getCapabilities() const
 {
-    return m_capabilities;
+   return m_capabilities;
 }
 
 MTPDevice::Capabilities MTPDevice::getCapabilities(const MTPDevice &device)
 {
-    MTPDevice::Capabilities capabilities;
+   MTPDevice::Capabilities capabilities;
 
 #ifdef HAVE_LIBMTP_CHECK_CAPABILITY
-    if (device.m_device) {
-        capabilities.setCanGetPartialObject(
-            static_cast<bool>(
-                LIBMTP_Check_Capability(
-                    device.m_device,
-                    LIBMTP_DEVICECAP_GetPartialObject)));
-        capabilities.setCanSendPartialobject(
-            static_cast<bool>(
-                LIBMTP_Check_Capability(
-                    device.m_device,
-                    LIBMTP_DEVICECAP_SendPartialObject)));
-        capabilities.setCanEditObjects(
-            static_cast<bool>(
-                LIBMTP_Check_Capability(
-                    device.m_device,
-                    LIBMTP_DEVICECAP_EditObjects)));
-    }
+   if (device.m_device)
+   {
+      capabilities.setCanGetPartialObject(
+          static_cast<bool>(
+              LIBMTP_Check_Capability(
+                  device.m_device,
+                  LIBMTP_DEVICECAP_GetPartialObject)));
+      capabilities.setCanSendPartialobject(
+          static_cast<bool>(
+              LIBMTP_Check_Capability(
+                  device.m_device,
+                  LIBMTP_DEVICECAP_SendPartialObject)));
+      capabilities.setCanEditObjects(
+          static_cast<bool>(
+              LIBMTP_Check_Capability(
+                  device.m_device,
+                  LIBMTP_DEVICECAP_EditObjects)));
+   }
 #endif
 
-    return capabilities;
+   return capabilities;
 }
 
 bool MTPDevice::listDevices(bool verbose, const std::string &dev_file)
 {
-    int raw_devices_cnt;
-    LIBMTP_raw_device_t *raw_devices;
-
-    // Do not output LIBMTP debug stuff
-    StreamHelper::off();
-    LIBMTP_error_number_t err = LIBMTP_Detect_Raw_Devices(
-        &raw_devices, &raw_devices_cnt);
-    StreamHelper::on();
-
-    if (err != 0) {
-        if (err == LIBMTP_ERROR_NO_DEVICE_ATTACHED)
-            std::cerr << "No raw devices found.\n";
-        return false;
-    }
+   int raw_devices_cnt;
+   LIBMTP_raw_device_t *raw_devices;
 
-    uint8_t bnum, dnum;
-    if (!dev_file.empty() && !smtpfs_usb_devpath(dev_file, &bnum, &dnum)) {
-        std::cerr << "Can not open such device '" << dev_file << "'.\n";
-        return false;
-    }
+   // Do not output LIBMTP debug stuff
+   StreamHelper::off();
+   LIBMTP_error_number_t err = LIBMTP_Detect_Raw_Devices(
+       &raw_devices, &raw_devices_cnt);
+   StreamHelper::on();
 
-    for (int i = 0; i < raw_devices_cnt; ++i) {
-        if (!dev_file.empty() &&
-            !(bnum == raw_devices[i].bus_location && dnum == raw_devices[i].devnum))
-            continue;
-        
-        char bus_num_str[4];
-        char dev_num_str[4];
-        sprintf(bus_num_str, "%03d", raw_devices[i].bus_location);
-        sprintf(dev_num_str, "%03d", raw_devices[i].devnum);
-
-        //printf("vid: %x, pid: %x\n", raw_devices[i].device_entry.vendor_id, raw_devices[i].device_entry.product_id);
-
-        Logger::off();
-        std::cout << i + 1 << ": "
-            << (raw_devices[i].device_entry.vendor ? raw_devices[i].device_entry.vendor : "Unknown vendor ")
-            << (raw_devices[i].device_entry.product ? raw_devices[i].device_entry.product : "Unknown product")
-            << " /dev/bus/usb/" << bus_num_str << "/" << dev_num_str
-            << std::endl;
+   if (err != 0)
+   {
+      if (err == LIBMTP_ERROR_NO_DEVICE_ATTACHED)
+         std::cerr << "No raw devices found.\n";
+      return false;
+   }
+
+   uint8_t bnum, dnum;
+   if (!dev_file.empty() && !smtpfs_usb_devpath(dev_file, &bnum, &dnum))
+   {
+      std::cerr << "Can not open such device '" << dev_file << "'.\n";
+      return false;
+   }
+
+   for (int i = 0; i < raw_devices_cnt; ++i)
+   {
+      if (!dev_file.empty() &&
+          !(bnum == raw_devices[i].bus_location && dnum == raw_devices[i].devnum))
+         continue;
+
+      char bus_num_str[4];
+      char dev_num_str[4];
+      sprintf(bus_num_str, "%03d", raw_devices[i].bus_location);
+      sprintf(dev_num_str, "%03d", raw_devices[i].devnum);
+
+      //printf("vid: %x, pid: %x\n", raw_devices[i].device_entry.vendor_id, raw_devices[i].device_entry.product_id);
+
+      Logger::off();
+      std::cout << i + 1 << ": "
+                << (raw_devices[i].device_entry.vendor ? raw_devices[i].device_entry.vendor : "Unknown vendor ")
+                << (raw_devices[i].device_entry.product ? raw_devices[i].device_entry.product : "Unknown product")
+                << " /dev/bus/usb/" << bus_num_str << "/" << dev_num_str
+                << std::endl;
 #ifdef HAVE_LIBMTP_CHECK_CAPABILITY
-            MTPDevice dev;
-            if (verbose) {
-                if (!dev.connect(&raw_devices[i]))
-                    return false;
-
-                const MTPDevice::Capabilities &cap = dev.getCapabilities();
-                std::cout << "  - can get  partial object: " << (cap.canGetPartialObject() ? "yes" : "no") << std::endl;
-                std::cout << "  - can send partial object: " << (cap.canSendPartialObject() ? "yes" : "no") << std::endl;
-                std::cout << "  - can edit objects       : " << (cap.canEditObjects() ? "yes" : "no") << std::endl;
-                dev.disconnect();
-            }
+      MTPDevice dev;
+      if (verbose)
+      {
+         if (!dev.connect(&raw_devices[i]))
+            return false;
+
+         const MTPDevice::Capabilities &cap = dev.getCapabilities();
+         std::cout << "  - can get  partial object: " << (cap.canGetPartialObject() ? "yes" : "no") << std::endl;
+         std::cout << "  - can send partial object: " << (cap.canSendPartialObject() ? "yes" : "no") << std::endl;
+         std::cout << "  - can edit objects       : " << (cap.canEditObjects() ? "yes" : "no") << std::endl;
+         dev.disconnect();
+      }
 #endif
-        Logger::on();
-    }
-    free(static_cast<void*>(raw_devices));
+      Logger::on();
+   }
+   free(static_cast<void *>(raw_devices));
 
-    return true;
+   return true;
 }
 
 int32_t MTPDevice::getFileInfoById(uint32_t id, struct stat *st)
 {
-   if(st == NULL)
+   if (st == NULL)
    {
       LogError("st is NULL");
       return -1;
@@ -1029,7 +1086,7 @@ int32_t MTPDevice::getFileInfoById(uint32_t id, struct stat *st)
    criticalEnter1();
    LIBMTP_file_t *file = LIBMTP_Get_Filemetadata(m_device, id);
    criticalLeave1();
-   if(file == NULL)
+   if (file == NULL)
    {
       st->st_ino = id;
       st->st_size = 1024;
@@ -1040,7 +1097,7 @@ int32_t MTPDevice::getFileInfoById(uint32_t id, struct stat *st)
       st->st_ctime = st->st_mtime;
       st->st_atime = st->st_mtime;
 
-	  LogDebug("id: %d file is NULL, fake it, size: %llu", id, st->st_size);
+      LogDebug("id: %d file is NULL, fake it, size: %llu", id, st->st_size);
       return 0;
    }
 
@@ -1058,380 +1115,432 @@ int32_t MTPDevice::getFileInfoById(uint32_t id, struct stat *st)
 
    LIBMTP_Free_Files_And_Folders(&file);
 
-    return 0;
- }
+   return 0;
+}
 
 bool MTPDevice::isFileExist(const uint32_t id)
 {
-	bool ret = false;
+   bool ret = false;
+
+   criticalEnter1();
+   ret = LIBMTP_Track_Exists(m_device, id);
+   criticalLeave1();
 
-	criticalEnter1();
-	ret = LIBMTP_Track_Exists(m_device, id);
-	criticalLeave1();
+   return ret;
+}
 
-	return ret;
-}   
-   
-int MTPDevice::getMediaFileType(LIBMTP_file_t *mtpFile)
+int MTPDevice::getMediaFileType(const std::string &filename)
 {
-	if(!mtpFile) return MTP_FILE_TYPE_UNKNOWN;
+   //track and image
+   int ret = MTP_FILE_TYPE_UNKNOWN;
+   if (reMatch(filename, mReExtNameAudio))
+   {
+      ret = MTP_FILE_TYPE_AUDIO;
+   }
+   else if (reMatch(filename, mReExtNameVideo))
+   {
+      ret = MTP_FILE_TYPE_VIDEO;
+   }
+   else if (reMatch(filename, mReExtNameImage))
+   {
+      ret = MTP_FILE_TYPE_IMAGE;
+   }
+   else if (reMatch(filename, mReExtNamePlaylist))
+   {
+      ret = MTP_FILE_TYPE_PLAYLIST;
+   }
+   else if (reMatch(filename, mReExtNameAudiobook))
+   {
+      ret = MTP_FILE_TYPE_AUDIOBOOKS;
+   }
 
-	//track and image
-	int ret = MTP_FILE_TYPE_UNKNOWN;
-	if( isAudioType(mtpFile->filename) )
-	{
-		ret = MTP_FILE_TYPE_AUDIO;
-	}
-	else if(isVideoType(mtpFile->filename))
-	{
-		ret = MTP_FILE_TYPE_VIDEO;
-	}
-	else if(isImageType(mtpFile->filename))
-	{
-		ret = MTP_FILE_TYPE_IMAGE;
-	}
-	else if(isPlayListType(mtpFile->filename))
-	{
-		ret = MTP_FILE_TYPE_PLAYLIST;
-	}
-	else if(isAudioBooksType(mtpFile->filename))
-	{
-		ret = MTP_FILE_TYPE_AUDIOBOOKS;
-	}
-	else
-	{
-		LogInfo("%s is unknown type, ignored", mtpFile->filename);
-	}
-	
-	return ret;
+   return ret;
 }
 
 int MTPDevice::getAllFolderAndFiles(LIBMTP_mtpdevice_t *device, LIBMTP_devicestorage_t *storage, uint32_t id, string &path, const string &lastModePath)
 {
-    int ret = 0;
-    ObjectHandles objHlds;
+   if (NULL == device)
+   {
+      LogError("the device is NULL");
+      return -1;
+   }
+   if (NULL == storage)
+   {
+      LogError("the storage is NULL");
+      return -1;
+   }
+   if (NULL == storage->StorageDescription)
+   {
+      LogError("the StorageDescription is NULL");
+      return -1;
+   }
+   // get the exclude regex
+   std::regex reExclude;
+   auto it = mReMapExclude.find(std::string(storage->StorageDescription));
 
-    objHlds.n = 0;
-    objHlds.Handler = NULL;
+   if (it == mReMapExclude.end())
+   {
+      LogWarning("found no regex for storage: %s", storage->StorageDescription);
+   }
+   else
+   {
+      reExclude = it->second;
+   }
 
-    //LogInfo("enter\n");
-    //LogInfo("search cache path: %s\n", path.c_str());
+   int ret = 0;
+   ObjectHandles objHlds;
 
-    TypeDir *parentDir = (TypeDir *)dirFetchContentFromCache(path);
-    if(parentDir == NULL)
-    {
-        LogError("dir is NULL");
-        return -1;
-    }
+   objHlds.n = 0;
+   objHlds.Handler = NULL;
 
-    while(m_read_data_cmd_coming)
-    {
-        LogInfo("in syncing, wait, let read cmd first\n");
-        usleep(200000);
-    }
+   //LogInfo("enter\n");
+   //LogInfo("search cache path: %s\n", path.c_str());
 
-	long t1 = 0, t2 = 0;
-    criticalEnter1();
-    //LogInfo("lock \n");
-	if(device)
-	{
-		t1 = getSysRunTime();
-    	ret = LIBMTP_Get_Files_And_Folders_Count(device, storage->id, id, &objHlds);
-		t2 = getSysRunTime();
-	}
-    //LogInfo("unlock \n");
-    criticalLeave1();
-	if((t2 - t1) >= 2000)
-	{
-		LogInfo("get(%s)count[%u] took: %lu ms\n", path.c_str(), objHlds.n, (t2-t1));
-	}
+   TypeDir *parentDir = (TypeDir *)dirFetchContentFromCache(path);
+   if (parentDir == NULL)
+   {
+      LogError("dir is NULL");
+      return -1;
+   }
 
-    if(ret < 0)
-    {
-        LogError("LIBMTP_Get_Files_And_Folders_Count: %s failed", path.c_str());
-        return -1;
-    }
+   while (m_read_data_cmd_coming)
+   {
+      LogInfo("in syncing, wait, let read cmd first");
+      usleep(200000);
+   }
 
-	uint32_t timeoutCnt = 0;
-    for(uint32_t i = 0; i < objHlds.n; i++)
-    {
-		while(m_read_data_cmd_coming)
-		{
-			LogInfo("in syncing, wait, let read cmd first\n");
-			usleep(200000);
-		}
-
-		if(device == NULL) break;
-
-		//LogInfo("lock 111\n");
-		long t3 = 0, t4 = 0;
-		criticalEnter1();
-		//LogInfo("lock 2222\n");
-		t3 = getSysRunTime();
-		LIBMTP_file_t *mtpFile = LIBMTP_Get_Files_And_Folders_ByHandle(device, objHlds.Handler[i]);
-		t4 = getSysRunTime();
-		//LogInfo("unlock 1111\n");
-		criticalLeave1();
-		//LogInfo("unlock 2222\n");
-		if((t4- t3) >= 2000)
-		{
-			if(mtpFile != NULL)
-			{
-				LogInfo("get (%s: %s) items took: %lu ms\n", path.c_str(), mtpFile->filename, (t4-t3));
-				timeoutCnt = 0;
-			}
-			else
-			{
-				LogInfo("get (%s: NULL) items took: %lu ms\n", path.c_str(), (t4-t3));
+   long t1 = 0, t2 = 0;
+   criticalEnter1();
+   //LogInfo("lock \n");
+   if (device)
+   {
+      t1 = getSysRunTime();
+      ret = LIBMTP_Get_Files_And_Folders_Count(device, storage->id, id, &objHlds);
+      t2 = getSysRunTime();
+   }
+   //LogInfo("unlock \n");
+   criticalLeave1();
+   if ((t2 - t1) >= LIBMTP_REQUEST_TIMEOUT)
+   {
+      LogInfo("get(%s)count[%u] took: %lu ms", path.c_str(), objHlds.n, (t2 - t1));
+   }
 
-				if((t4-t3) >= 50000)
-				{
-					timeoutCnt++;
-				}
+   if (ret < 0)
+   {
+      LogError("LIBMTP_Get_Files_And_Folders_Count: %s failed", path.c_str());
+      return -1;
+   }
 
-				//for Samsung s7 and s9, there is a 
-				if(timeoutCnt >= 2) 
-				{
-					LogWarning("can not get: %s items, skip it\n", path.c_str());
-					break;
-				}
-			}
-			
-		}
-        
-        while(mtpFile != NULL)
-        {
-			if(m_lastMode_sync_done && !lastModePath.empty())
-			{
-				LogInfo("----lastmode scan done----");
-				break;
-			}
+   uint32_t timeoutCnt = 0;
+   for (uint32_t i = 0; i < objHlds.n; i++)
+   {
+      while (m_read_data_cmd_coming)
+      {
+         LogInfo("in syncing, wait, let read cmd first");
+         usleep(200000);
+      }
+
+      if (device == NULL)
+         break;
+
+      //LogInfo("lock 111\n");
+      long t3 = 0, t4 = 0;
+      criticalEnter1();
+      //LogInfo("lock 2222\n");
+      t3 = getSysRunTime();
+      LIBMTP_file_t *mtpFile = LIBMTP_Get_Files_And_Folders_ByHandle(device, objHlds.Handler[i]);
+      t4 = getSysRunTime();
+      //LogInfo("unlock 1111\n");
+      criticalLeave1();
+      //LogInfo("unlock 2222\n");
+      if ((t4 - t3) >= LIBMTP_REQUEST_TIMEOUT)
+      {
+         if (mtpFile != NULL)
+         {
+            LogInfo("get (%s: %s) items took: %lu ms", path.c_str(), mtpFile->filename, (t4 - t3));
+            timeoutCnt = 0;
+         }
+         else
+         {
+            LogInfo("get (%s: NULL) items took: %lu ms", path.c_str(), (t4 - t3));
+
+            if ((t4 - t3) >= LIBMTP_REQUEST_TIMEOUT_ABORT)
+            {
+               timeoutCnt++;
+            }
+
+            //for Samsung s7 and s9, there is a
+            if (timeoutCnt >= 2)
+            {
+               LogWarning("can not get: %s items, skip it", path.c_str());
+               break;
+            }
+         }
+      }
+
+      while (mtpFile != NULL)
+      {
+         if (m_lastMode_sync_done && !lastModePath.empty())
+         {
+            LogInfo("----lastmode scan done----");
+            break;
+         }
+
+         if (device == NULL)
+            break;
+         LIBMTP_file_t *tmpFile = mtpFile;
+
+         if (tmpFile->filetype == LIBMTP_FILETYPE_FOLDER)
+         {
+            string folderPath = path + "/" + tmpFile->filename;
 
-			if(device == NULL) break;
-            LIBMTP_file_t *tmpFile = mtpFile;
-            
-            if(tmpFile->filetype == LIBMTP_FILETYPE_FOLDER)
+            //LogInfo("-----folder: %s, path: %s, size: %llu---------\n", tmpFile->filename, folderPath.c_str(), tmpFile->filesize);
+            if (reMatch(folderPath + "/", reExclude))
             {
-                string folderPath = path + "/" + tmpFile->filename;
-
-                //LogInfo("-----folder: %s, path: %s, size: %llu---------\n", tmpFile->filename, folderPath.c_str(), tmpFile->filesize);
-                if(ignoreFolder(tmpFile->filename) == true)
-                {
-					LogInfo("-----ignore folder: %s---------\n", tmpFile->filename);
-                }
-                else
-                {  
-					if( lastModePath.empty() || (!lastModePath.empty() && !lastModePath.find(folderPath)) )
-					{
-						parentDir->addDir(TypeDir(tmpFile));
-               			getAllFolderAndFiles(device, storage, tmpFile->item_id, folderPath, lastModePath);
-					}
-					else
-					{
-						LogInfo("-----lastmode skip folder: %s---------\n", tmpFile->filename);
-					}
-                }
+               LogInfo("-----ignore folder: %s---------", folderPath.c_str());
+               ++ mFolderIgnored;
             }
             else
             {
-                string filePath = path + "/" + tmpFile->filename;
-                //LogInfo("-----file: %s, path: %s---------\n", tmpFile->filename, filePath.c_str());
-
-                //save into db 
-				int fileType = getMediaFileType(tmpFile);
-                if(fileType)
-                {
-                    //LogInfo("writeFileID, filePath: %s", filePath.c_str());
-					parentDir->addFile(TypeFile(tmpFile));
-					#ifdef MTP_HAS_DB
-                    writeFileID(filePath, tmpFile->item_id, mUUID);
-					#endif
-
-					criticalEnter1();
-					LIBMTP_track_t *deviceTrack = LIBMTP_Get_Trackmetadata(m_device, tmpFile->item_id);
-					criticalLeave1();
-
-					smtpfs_trackInfo smtpfsTrack;
-					memset(&smtpfsTrack, 0x00, sizeof(smtpfs_trackInfo));
-					if(deviceTrack)
-					{
-						//LogInfo("have track info");
-						fillTrackInfo(&smtpfsTrack, deviceTrack, filePath.c_str(), fileType);
-					}
-					else
-					{
-						//LogInfo("no track info");
-						fillTrackInfoByFile(&smtpfsTrack, tmpFile, filePath.c_str(), fileType);
-					}
-					
-					if(deviceTrack) 
-					{
-						criticalEnter1();
-						LIBMTP_destroy_track_t(deviceTrack);
-						criticalLeave1();
-					}
-					
-					if(lastModePath.empty() && (m_lastmode_path != filePath))
-					{
-						m_trackMetaList.push_back(smtpfsTrack);
-					}
-
-					if(!lastModePath.empty() && (lastModePath == filePath))
-					{
-						m_trackMetaList.push_back(smtpfsTrack);
-						LogInfo("----find lastModePath: %s---", lastModePath.c_str());
-						m_lastMode_sync_done = true;
-						break;
-					}
-                }
+               if (lastModePath.empty() || (!lastModePath.empty() && !lastModePath.find(folderPath)))
+               {
+                  parentDir->addDir(TypeDir(tmpFile));
+                  getAllFolderAndFiles(device, storage, tmpFile->item_id, folderPath, lastModePath);
+               }
+               else
+               {
+                  LogInfo("-----lastmode skip folder: %s---------", folderPath.c_str());
+               }
             }
+         }
+         else
+         {
+            string filePath = path + "/" + tmpFile->filename;
+            //LogInfo("-----file: %s, path: %s---------\n", tmpFile->filename, filePath.c_str());
+
+            //save into db
+            int fileType = getMediaFileType(tmpFile->filename);
+            if (MTP_FILE_TYPE_UNKNOWN != fileType)
+            {
+               //LogInfo("writeFileID, filePath: %s", filePath.c_str());
+               parentDir->addFile(TypeFile(tmpFile));
+#ifdef MTP_HAS_DB
+               writeFileID(filePath, tmpFile->item_id, mUUID);
+#endif
 
-			mtpFile = tmpFile->next;
-			criticalEnter1();
-			LIBMTP_destroy_file_t(tmpFile);
-			criticalLeave1();
-        }
+               criticalEnter1();
+               t1 = getSysRunTime();
+               LIBMTP_track_t *deviceTrack = LIBMTP_Get_Trackmetadata(m_device, tmpFile->item_id);
+               t2 = getSysRunTime();
+               criticalLeave1();
+               if ((t2 - t1) >= LIBMTP_REQUEST_TIMEOUT)
+               {
+                  LogInfo("LIBMTP_Get_Trackmetadata, id: %x; path: %s; took: %lu ms", tmpFile->item_id, filePath.c_str(), (t2 - t1));
+               }
+
+               smtpfs_trackInfo smtpfsTrack;
+               memset(&smtpfsTrack, 0x00, sizeof(smtpfs_trackInfo));
+               if (deviceTrack)
+               {
+                  //LogInfo("have track info");
+                  fillTrackInfo(&smtpfsTrack, deviceTrack, filePath.c_str(), fileType);
+               }
+               else
+               {
+                  //LogInfo("no track info");
+                  fillTrackInfoByFile(&smtpfsTrack, tmpFile, filePath.c_str(), fileType);
+               }
+
+               if (deviceTrack)
+               {
+                  criticalEnter1();
+                  LIBMTP_destroy_track_t(deviceTrack);
+                  criticalLeave1();
+               }
+
+               if (lastModePath.empty() && (m_lastmode_path != filePath))
+               {
+                  m_trackMetaList.push_back(smtpfsTrack);
+               }
+
+               if (!lastModePath.empty() && (lastModePath == filePath))
+               {
+                  m_trackMetaList.push_back(smtpfsTrack);
+                  LogInfo("----find lastModePath: %s---", lastModePath.c_str());
+                  m_lastMode_sync_done = true;
+                  break;
+               }
+            }
+            else
+            {
+               LogDebug("%s is unknown type; ignored", tmpFile->filename);
+               ++ mFileIgnored;
+            }
+         }
+
+         mtpFile = tmpFile->next;
+         criticalEnter1();
+         LIBMTP_destroy_file_t(tmpFile);
+         criticalLeave1();
+      }
+
+      if (m_lastMode_sync_done && !lastModePath.empty())
+      {
+         LogInfo("----lastmode scan done----");
+         break;
+      }
+   }
 
-		if(m_lastMode_sync_done && !lastModePath.empty())
-		{
-			LogInfo("----lastmode scan done----");
-			break;
-		}
-    }
+   criticalEnter1();
+   LIBMTP_Free_ObjHandles(&objHlds);
+   criticalLeave1();
+   parentDir->setFetched();
 
-	criticalEnter1();
-	LIBMTP_Free_ObjHandles(&objHlds);
-	criticalLeave1();
-	parentDir->setFetched();
-   
    return 0;
 }
 
 int32_t MTPDevice::autoListAll()
 {
-    if(m_device == NULL)
-    {
-        LogError("m_device is NULL\n");
-        return -1;
-    }
+   setThreadPriority(mScanThPolicy, mScanThPriority);
+   if (m_device == NULL)
+   {
+      LogError("m_device is NULL\n");
+      return -1;
+   }
 
-	LogInfo("enter\n");
+   LogInfo("enter\n");
 
-    LIBMTP_devicestorage_t *storage = NULL;
-    string path = "/";
+   LIBMTP_devicestorage_t *storage = NULL;
+   string path = "/";
 
+   long whole_t1 = getSysRunTime();
 
-	long whole_t1 = getSysRunTime();
+   dirFetchContentFromCache(path);
 
-    dirFetchContentFromCache(path);
+   m_lastMode_sync_done = false;
 
-	m_lastMode_sync_done = false;
+   // make the regex for all of the storages
+   for (storage = m_device->storage; storage != 0; storage = storage->next)
+   {
+      // make the regex for the specified storage
+      std::string pattern = std::string("\\/") + std::string(storage->StorageDescription) + Config::instance().getExcPattern();
+      std::regex re;
+
+      if (makeRegEx(re, pattern))
+      {
+         LogError("has made the regex for the storage : %s; pattern: %s", storage->StorageDescription, pattern.c_str());
+         mReMapExclude[std::string(storage->StorageDescription)] = re;
+      }
+      else
+      {
+         LogError("make the regex for the storage failed; sotrage: %s; pattern: %s", storage->StorageDescription, pattern.c_str());
+      }
+   }
 
-	//check if sync lastmode firstly
-	if(!m_lastmode_path.empty() && (m_lastmode_path != path))
-	{
-		for(storage = m_device->storage; storage != 0; storage = storage->next) 
-		{
-			//get all items
-			LogInfo( "start lastmode scan Storage: %s\n", storage->StorageDescription);
-			string tmpPath = path + storage->StorageDescription;
+   //check if sync lastmode firstly
+   if (!m_lastmode_path.empty() && (m_lastmode_path != path))
+   {
+      for (storage = m_device->storage; storage != 0; storage = storage->next)
+      {
+         //get all items
+         LogInfo("start lastmode scan Storage: %s", storage->StorageDescription);
+         string tmpPath = path + storage->StorageDescription;
+
+         if (m_lastmode_path.find(tmpPath))
+         {
+            LogInfo("lastmode, m_lastmode_path: %s, tmpPath: %s", m_lastmode_path.c_str(), tmpPath.c_str());
+            continue;
+         }
 
-			if(m_lastmode_path.find(tmpPath))
-			{
-				LogInfo( "lastmode, m_lastmode_path: %s, tmpPath: %s\n", m_lastmode_path.c_str(), tmpPath.c_str());
-				continue;
-			}
+         long t1 = getSysRunTime();
 
-			long t1 = getSysRunTime();
-			
-			if(m_device)
-			{
-				getAllFolderAndFiles(m_device, storage, LIBMTP_FILES_AND_FOLDERS_ROOT, tmpPath, m_lastmode_path);
-			}
-			long t2 = getSysRunTime();
-			
-			LogInfo( "end lastmode scan Storage: %s, storage->id: %x, took: %lu ms\n", storage->StorageDescription, storage->id, (t2 - t1));
-		}
-	}
+         if (m_device)
+         {
+            getAllFolderAndFiles(m_device, storage, LIBMTP_FILES_AND_FOLDERS_ROOT, tmpPath, m_lastmode_path);
+         }
+         long t2 = getSysRunTime();
 
-    for(storage = m_device->storage; storage != 0; storage = storage->next) 
-    {
-		long t1 = getSysRunTime();
-        //get all items
-		LogInfo( "start scan Storage: %s\n", storage->StorageDescription);
-        string tmpPath = path + storage->StorageDescription;
-		if(m_device)
-		{
-			getAllFolderAndFiles(m_device, storage, LIBMTP_FILES_AND_FOLDERS_ROOT, tmpPath);
-		}
-		long t2 = getSysRunTime();
-        
-        LogInfo( "end scan Storage: %s, storage->id: %x, took: %lu ms\n", storage->StorageDescription, storage->id, (t2 - t1));
-    }
+         LogInfo("end lastmode scan Storage: %s, storage->id: %x, took: %lu ms", storage->StorageDescription, storage->id, (t2 - t1));
+      }
+   }
 
-	m_list_all_done = 1;
+   for (storage = m_device->storage; storage != 0; storage = storage->next)
+   {
+      long t1 = getSysRunTime();
+      //get all items
+      LogInfo("start scan Storage: %s", storage->StorageDescription);
+      string tmpPath = path + storage->StorageDescription;
+      if (m_device)
+      {
+         getAllFolderAndFiles(m_device, storage, LIBMTP_FILES_AND_FOLDERS_ROOT, tmpPath);
+      }
+      long t2 = getSysRunTime();
+
+      LogInfo("end scan Storage: %s, storage->id: %x, took: %lu ms", storage->StorageDescription, storage->id, (t2 - t1));
+   }
 
-	long whole_t2 = getSysRunTime();
+   m_list_all_done = 1;
 
-    LogInfo("scan whole phone took: %lu ms, total file: %d\n", (whole_t2 - whole_t1), m_trackMetaList.size());
+   long whole_t2 = getSysRunTime();
 
-    return 0;
-}
+   LogInfo("scan whole phone took: %lu ms, total file: %d; file ignored: %u; folder ignored: %u", 
+      (whole_t2 - whole_t1), m_trackMetaList.size(), mFileIgnored, mFolderIgnored);
 
+   return 0;
+}
 
-static void* autoScanItemsRun(void *arg)
+static void *autoScanItemsRun(void *arg)
 {
-    LogInfo("enter");
-	if(!gMTPDev)
-	{
-		LogInfo("gMTPDev is NULL");
-		return NULL;
-	}
-
-    setThreadPriority(20);
+   LogInfo("enter");
+   if (!gMTPDev)
+   {
+      LogInfo("gMTPDev is NULL");
+      return NULL;
+   }
 
-    do
-    {
+   do
+   {
       LogInfo("wait sem");
       sem_wait(&gMTPDev->device_connect_sem);
       LogInfo("wait sem, reach");
-      if(gMTPDev) gMTPDev->autoListAll();
-    }while(0);
+      if (gMTPDev)
+         gMTPDev->autoListAll();
+   } while (0);
+
+   LogInfo("exit");
 
-    LogInfo("exit");
-    
-    return NULL;
+   return NULL;
 }
 
 int MTPDevice::launchTasks()
 {
    LogInfo("enter");
 
-   if(!scanThreadRun)
+   if (!scanThreadRun)
    {
-		//detached thread
-		pthread_attr_t attr;
-		int ret = 0;
-		pthread_t pid; 
-
-		pthread_attr_init(&attr);
-
-		ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-		if(ret)
-		{
-			LogInfo("pthread_attr_setdetachstate fail");
-			return -1;
-		}
-
-		scanThreadRun = true;
-		ret = pthread_create(&pid, &attr, autoScanItemsRun, this);
-		if(ret)
-		{
-			LogError("pthread_create failed\n");
-			return -1;
-		}
-
-		pthread_attr_destroy(&attr);
+      //detached thread
+      pthread_attr_t attr;
+      int ret = 0;
+      pthread_t pid;
+
+      pthread_attr_init(&attr);
+
+      ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+      if (ret)
+      {
+         LogInfo("pthread_attr_setdetachstate fail");
+         return -1;
+      }
+
+      scanThreadRun = true;
+      ret = pthread_create(&pid, &attr, autoScanItemsRun, this);
+      if (ret)
+      {
+         LogError("pthread_create failed\n");
+         return -1;
+      }
+
+      pthread_attr_destroy(&attr);
    }
 
    LogInfo("exit");
@@ -1440,257 +1549,297 @@ int MTPDevice::launchTasks()
 
 void MTPDevice::printTrackInfo(const smtpfs_trackInfo *track)
 {
-	if(track == NULL) return;
+   if (track == NULL)
+      return;
 
-	LogInfo("---------------track Info-------------");
+   LogInfo("---------------track Info-------------");
 
-	string typeStr = "unknown";
-	if(track->type == MTP_FILE_TYPE_AUDIO)
-	{
-		typeStr = "audio";
-	}
-	else if(track->type == MTP_FILE_TYPE_VIDEO)
-	{
-		typeStr = "video";
-	}
-	else if(track->type == MTP_FILE_TYPE_IMAGE)
-	{
-		typeStr = "image";
-	}
-	else if(track->type == MTP_FILE_TYPE_PLAYLIST)
-	{
-		typeStr = "playlist";
-	}
-	else if(track->type == MTP_FILE_TYPE_AUDIOBOOKS)
-	{
-		typeStr = "audiobooks";
-	}
-	else
-	{
-		typeStr = "unknown";
-	}
+   string typeStr = "unknown";
+   if (track->type == MTP_FILE_TYPE_AUDIO)
+   {
+      typeStr = "audio";
+   }
+   else if (track->type == MTP_FILE_TYPE_VIDEO)
+   {
+      typeStr = "video";
+   }
+   else if (track->type == MTP_FILE_TYPE_IMAGE)
+   {
+      typeStr = "image";
+   }
+   else if (track->type == MTP_FILE_TYPE_PLAYLIST)
+   {
+      typeStr = "playlist";
+   }
+   else if (track->type == MTP_FILE_TYPE_AUDIOBOOKS)
+   {
+      typeStr = "audiobooks";
+   }
+   else
+   {
+      typeStr = "unknown";
+   }
 
-	LogInfo("path: %s", track->path);
-	LogInfo("type: %s", typeStr.c_str());
-	LogInfo("title: %s", track->title);
-	LogInfo("artist: %s", track->artist);
-	//LogInfo("composer: %s", track->composer);
-	LogInfo("genre: %s", track->genre);
-	LogInfo("album: %s", track->album);
-	LogInfo("duration: %u", track->duration);
-	LogInfo("samplerate: %u", track->samplerate);
-	LogInfo("nochannels: %u", track->nochannels);
-	LogInfo("wavecodec: %u", track->wavecodec);
-	LogInfo("bitrate: %u", track->bitrate);
-	LogInfo("filesize: %llu", track->filesize);
-	LogInfo("modificationdate: %lu", track->modificationdate);
+   LogInfo("path: %s", track->path);
+   LogInfo("type: %s", typeStr.c_str());
+   LogInfo("title: %s", track->title);
+   LogInfo("artist: %s", track->artist);
+   //LogInfo("composer: %s", track->composer);
+   LogInfo("genre: %s", track->genre);
+   LogInfo("album: %s", track->album);
+   LogInfo("duration: %u", track->duration);
+   LogInfo("samplerate: %u", track->samplerate);
+   LogInfo("nochannels: %u", track->nochannels);
+   LogInfo("wavecodec: %u", track->wavecodec);
+   LogInfo("bitrate: %u", track->bitrate);
+   LogInfo("filesize: %llu", track->filesize);
+   LogInfo("modificationdate: %lu", track->modificationdate);
    LogInfo("tracknumber: %d", track->tracknumber);
-	LogInfo("rating: %d", track->rating);
-
+   LogInfo("rating: %d", track->rating);
 }
 
 int MTPDevice::fillTrackInfo(smtpfs_trackInfo *dst, const LIBMTP_track_t *src, const char *path, int type)
 {
-	const char *ignoreKey = "<unknown>";
-	if(!dst || !path || !src)
-	{
-		LogError("dst or path is NULL");
-		return -1;
-	}
+   const char *ignoreKey = "<unknown>";
+   if (!dst || !path || !src)
+   {
+      LogError("dst or path is NULL");
+      return -1;
+   }
 
-	dst->type = type;
+   dst->type = type;
 
-	if(path)
-		strncpy(dst->path, path, (sizeof(dst->path) - 1));
+   if (path)
+      strncpy(dst->path, path, (sizeof(dst->path) - 1));
 
-	// if(src->filename)
-	// 	strncpy(dst->fileName, src->filename, (sizeof(dst->fileName) - 1));
+   // if(src->filename)
+   // 	strncpy(dst->fileName, src->filename, (sizeof(dst->fileName) - 1));
 
-	if(src->title)
-		strncpy(dst->title, src->title, (sizeof(dst->title) - 1));
+   if (src->title)
+      strncpy(dst->title, src->title, (sizeof(dst->title) - 1));
 
-	if(src->artist && strcmp(src->artist, ignoreKey))
-		strncpy(dst->artist, src->artist, (sizeof(dst->artist) - 1));
+   if (src->artist && strcmp(src->artist, ignoreKey))
+      strncpy(dst->artist, src->artist, (sizeof(dst->artist) - 1));
 
-	// if(src->composer)
-	// 	strncpy(dst->composer, src->composer, (sizeof(dst->composer) - 1));
+   // if(src->composer)
+   // 	strncpy(dst->composer, src->composer, (sizeof(dst->composer) - 1));
 
-	if(src->genre && strcmp(src->genre, ignoreKey))
-		strncpy(dst->genre, src->genre, (sizeof(dst->genre) - 1));
+   if (src->genre && strcmp(src->genre, ignoreKey))
+      strncpy(dst->genre, src->genre, (sizeof(dst->genre) - 1));
 
-	if(src->album && strcmp(src->album, ignoreKey))
-		strncpy(dst->album, src->album, (sizeof(dst->album) - 1));
+   if (src->album && strcmp(src->album, ignoreKey))
+      strncpy(dst->album, src->album, (sizeof(dst->album) - 1));
 
-	dst->duration = src->duration;
-	dst->samplerate = src->samplerate;
-	dst->nochannels = src->nochannels;
-	dst->wavecodec = src->wavecodec;
-	dst->bitrate = src->bitrate;
-	dst->filesize = src->filesize;
-	dst->modificationdate = src->modificationdate;
+   dst->duration = src->duration;
+   dst->samplerate = src->samplerate;
+   dst->nochannels = src->nochannels;
+   dst->wavecodec = src->wavecodec;
+   dst->bitrate = src->bitrate;
+   dst->filesize = src->filesize;
+   dst->modificationdate = src->modificationdate;
    dst->tracknumber = src->tracknumber;
    dst->rating = src->rating;
 
-	//printTrackInfo(dst);
+   //printTrackInfo(dst);
 
-	return 0;
+   return 0;
 }
 
 int MTPDevice::fillTrackInfoByFile(smtpfs_trackInfo *dst, const LIBMTP_file_t *src, const char *path, int type)
 {
-	if(!dst || !path || !src)
-	{
-		LogError("dst or path is NULL");
-		return -1;
-	}
+   if (!dst || !path || !src)
+   {
+      LogError("dst or path is NULL");
+      return -1;
+   }
 
-	dst->type = type;
+   dst->type = type;
 
-	if(path)
-		strncpy(dst->path, path, (sizeof(dst->path) - 1));
+   if (path)
+      strncpy(dst->path, path, (sizeof(dst->path) - 1));
 
-	dst->filesize = src->filesize;
-	dst->modificationdate = src->modificationdate;
+   dst->filesize = src->filesize;
+   dst->modificationdate = src->modificationdate;
 
-	//printTrackInfo(dst);
+   //printTrackInfo(dst);
 
-	return 0;
+   return 0;
 }
 
 int MTPDevice::getEvent(char *buf, uint32_t bufLen)
 {
-	if(!buf || (bufLen < (int)sizeof(smtpfs_event)))
-	{
-		LogError("buf: %p, bufLen: %d", buf, bufLen);
-		return -1;
-	}
-
-	//event header
-	int dataLen = 0;
-	
-	smtpfs_event *pEvent = (smtpfs_event *)buf;
-
-	if(!isIndexingDone)
-	{
-		//LogInfo(" track list");
-		if( bufLen < (sizeof(smtpfs_event) + sizeof(smtpfs_trackList) + sizeof(smtpfs_trackInfo)) )
-		{
-			LogError("bufLen[%u] is too small", bufLen);
-			return -1;
-		}
-
-		if(!m_list_all_done && (m_trackList_offset >= m_trackMetaList.size()))
-		{
-			//LogError("m_trackList_offset: %d >= total: %d", m_trackList_offset, m_trackMetaList.size());
-			if(m_list_all_done)
-			{
-				LogInfo("set isIndexingDone == ture done");
-				isIndexingDone = true;
-				m_trackMetaList.clear();
-				vector<smtpfs_trackInfo>().swap(m_trackMetaList);
-				return -1;
-			}
-			return 0;
-		}
-
-		uint32_t trackNum = (bufLen - sizeof(smtpfs_event) - sizeof(smtpfs_trackList))/sizeof(smtpfs_trackInfo);
-
-		//LogInfo("-----trackList, trackNum: %d------------", trackNum);
-
-		//fill event header
-		pEvent->eventType = SMTPFS_EVENT_TRACKLIST;
-		dataLen += sizeof(smtpfs_event);
-
-		//fill smtpfs_trackList
-		smtpfs_trackList *trackListHeader = (smtpfs_trackList *)(buf + dataLen);
-		trackListHeader->fragment = 1;
-		dataLen += sizeof(smtpfs_trackList);
-
-		uint32_t total = m_trackMetaList.size();
-		uint32_t i = 0, sum = 0;
-		for(i = m_trackList_offset; i < total && sum < trackNum; i++, sum++)
-		{
-			//LogInfo("-----trackList, sum: %d------------", sum);
-			//fill track info
-			smtpfs_trackInfo *track = (smtpfs_trackInfo *)(buf + dataLen + sum*sizeof(smtpfs_trackInfo));
-
-			*track = m_trackMetaList[i];
-
-			//printTrackInfoprintTrackInfo(track);
-		}
-
-		//LogInfo("-----trackList, sum: %d, total: %d, m_trackList_offset: %d, trackNum: %d------------", sum, total, m_trackList_offset, trackNum);
+   if (!buf || (bufLen < (int)sizeof(smtpfs_event)))
+   {
+      LogError("buf: %p, bufLen: %d", buf, bufLen);
+      return -1;
+   }
 
-		dataLen += sum*sizeof(smtpfs_trackInfo);
+   //event header
+   int dataLen = 0;
 
-		m_trackList_offset = i;
+   smtpfs_event *pEvent = (smtpfs_event *)buf;
 
-		pEvent->len = dataLen;
-		
-		if(m_list_all_done && (m_trackList_offset >= m_trackMetaList.size()))
-		{
-			trackListHeader->fragment = 0;
-			LogInfo("isIndexingDone is true");
-			isIndexingDone = true;
-			m_trackMetaList.clear();
-			vector<smtpfs_trackInfo>().swap(m_trackMetaList);
-		}
-
-		trackListHeader->count = sum;
-		//LogInfo("bufLen: %u, dataLen: %d", bufLen, dataLen);
-	}
+   if (!isIndexingDone)
+   {
+      //LogInfo(" track list");
+      if (bufLen < (sizeof(smtpfs_event) + sizeof(smtpfs_trackList) + sizeof(smtpfs_trackInfo)))
+      {
+         LogError("bufLen[%u] is too small", bufLen);
+         return -1;
+      }
+
+      if (!m_list_all_done && (m_trackList_offset >= m_trackMetaList.size()))
+      {
+         //LogError("m_trackList_offset: %d >= total: %d", m_trackList_offset, m_trackMetaList.size());
+         if (m_list_all_done)
+         {
+            LogInfo("set isIndexingDone == ture done");
+            isIndexingDone = true;
+            m_trackMetaList.clear();
+            vector<smtpfs_trackInfo>().swap(m_trackMetaList);
+            return -1;
+         }
+         return 0;
+      }
+
+      uint32_t trackNum = (bufLen - sizeof(smtpfs_event) - sizeof(smtpfs_trackList)) / sizeof(smtpfs_trackInfo);
+
+      //LogInfo("-----trackList, trackNum: %d------------", trackNum);
+
+      //fill event header
+      pEvent->eventType = SMTPFS_EVENT_TRACKLIST;
+      dataLen += sizeof(smtpfs_event);
+
+      //fill smtpfs_trackList
+      smtpfs_trackList *trackListHeader = (smtpfs_trackList *)(buf + dataLen);
+      trackListHeader->fragment = 1;
+      dataLen += sizeof(smtpfs_trackList);
+
+      uint32_t total = m_trackMetaList.size();
+      uint32_t i = 0, sum = 0;
+      for (i = m_trackList_offset; i < total && sum < trackNum; i++, sum++)
+      {
+         //LogInfo("-----trackList, sum: %d------------", sum);
+         //fill track info
+         smtpfs_trackInfo *track = (smtpfs_trackInfo *)(buf + dataLen + sum * sizeof(smtpfs_trackInfo));
+
+         *track = m_trackMetaList[i];
+
+         //printTrackInfoprintTrackInfo(track);
+      }
+
+      //LogInfo("-----trackList, sum: %d, total: %d, m_trackList_offset: %d, trackNum: %d------------", sum, total, m_trackList_offset, trackNum);
+
+      dataLen += sum * sizeof(smtpfs_trackInfo);
+
+      m_trackList_offset = i;
+
+      pEvent->len = dataLen;
+
+      if (m_list_all_done && (m_trackList_offset >= m_trackMetaList.size()))
+      {
+         trackListHeader->fragment = 0;
+         LogInfo("isIndexingDone is true");
+         isIndexingDone = true;
+         m_trackMetaList.clear();
+         vector<smtpfs_trackInfo>().swap(m_trackMetaList);
+      }
+
+      trackListHeader->count = sum;
+      //LogInfo("bufLen: %u, dataLen: %d", bufLen, dataLen);
+   }
 
-	//LogInfo("dataLen: %d", dataLen);
+   //LogInfo("dataLen: %d", dataLen);
 
-	return dataLen;
+   return dataLen;
 }
 
-
 int MTPDevice::setEvent(char *buf, uint32_t bufLen)
 {
-	if(!buf || (bufLen < (int)sizeof(smtpfs_event)))
-	{
-		LogError("buf: %p, bufLen: %d", buf, bufLen);
-		return -1;
-	}
-
-	//event header
-	smtpfs_event *pEvent = (smtpfs_event *)buf;
-	if(!pEvent)
-	{
-		LogError("pEvent is NULL");
-		return -1;
-	}
+   if (!buf || (bufLen < (int)sizeof(smtpfs_event)))
+   {
+      LogError("buf: %p, bufLen: %d", buf, bufLen);
+      return -1;
+   }
 
-	if(pEvent->eventType == SMTPFS_EVENT_SYNC_LASTMODE)
-	{
-		smtpfs_sync_lastmode *lastModeEvent = (smtpfs_sync_lastmode *)(buf + sizeof(smtpfs_event));
-		if(!lastModeEvent)
-		{
-			LogError("lastModeEvent is NULL");
-			return -1;
-		}
+   //event header
+   smtpfs_event *pEvent = (smtpfs_event *)buf;
+   if (!pEvent)
+   {
+      LogError("pEvent is NULL");
+      return -1;
+   }
 
-		setLastModeSyncPath(lastModeEvent->path);
-	}
+   if (pEvent->eventType == SMTPFS_EVENT_SYNC_LASTMODE)
+   {
+      smtpfs_sync_lastmode *lastModeEvent = (smtpfs_sync_lastmode *)(buf + sizeof(smtpfs_event));
+      if (!lastModeEvent)
+      {
+         LogError("lastModeEvent is NULL");
+         return -1;
+      }
+
+      setLastModeSyncPath(lastModeEvent->path);
+   }
 
-	return 0;
+   return 0;
 }
 
-
 int MTPDevice::setLastModeSyncPath(string path)
 {
-	if(path.empty())
-	{
-		LogError("path is empty");
-		return -1;
-	}
+   if (path.empty())
+   {
+      LogError("path is empty");
+      return -1;
+   }
+   // initialize scanning, get config from MediaOne
+   std::string logLevelSMTP;
+   std::string pattern;
+   std::vector<std::string> extNameAudio = Config::instance().getExtNameAudio();
+   std::vector<std::string> extNameVideo = Config::instance().getExtNameVideo();
+   std::vector<std::string> extNameImage = Config::instance().getExtNameImage();
+   std::vector<std::string> extNamePlaylist = Config::instance().getExtNamePlaylist();
+   std::vector<std::string> extNameAudiobook = Config::instance().getExtNameAudiobook();
+
+   // set the log level
+   Logger::setLogLevel(Config::instance().getSMTPFSLogLevel());
+
+   if (!makeRegExStrArray(mReExtNameAudio, extNameAudio))
+   {
+      LogError("make regEx for audio extension name failed");
+   }
+   if (!makeRegExStrArray(mReExtNameVideo, extNameVideo))
+   {
+      LogError("make regEx for video extension name failed");
+   }
+   if (!makeRegExStrArray(mReExtNameImage, extNameImage))
+   {
+      LogError("make regEx for image extension name failed");
+   }
+   if (!makeRegExStrArray(mReExtNamePlaylist, extNamePlaylist))
+   {
+      LogError("make regEx for playlist extension name failed");
+   }
+   if (!makeRegExStrArray(mReExtNameAudiobook, extNameAudiobook))
+   {
+      LogError("make regEx for audiobook extension name failed");
+   }
+
+   mScanThPolicy = Config::instance().getScanThrPolicy();
+   mScanThPriority = Config::instance().getScanThrPriority();
+   // end of initialize
+
 
-	LogInfo("lastmode path: %s", path.c_str());
+   LogInfo("lastmode path: %s", path.c_str());
 
-	m_lastmode_path = path;
+   m_lastmode_path = path;
 
-	sem_post(&device_connect_sem);
+   sem_post(&device_connect_sem);
 
-	return 0;
+   return 0;
 }
+
+bool MTPDevice::isMediaType(const std::string &path)
+{
+   return (MTP_FILE_TYPE_UNKNOWN != getMediaFileType(path));
+}
\ No newline at end of file
diff --git a/src/simple-mtpfs-mtp-device.h b/src/simple-mtpfs-mtp-device.h
index 4d57e12..c04923c 100755
--- a/src/simple-mtpfs-mtp-device.h
+++ b/src/simple-mtpfs-mtp-device.h
@@ -41,135 +41,147 @@ class MTPDevice : public SIMPLE_DB
 class MTPDevice
 #endif
 {
-public:
-    class Capabilities
-    {
+ public:
+   class Capabilities
+   {
     public:
-        Capabilities()
-            : m_get_partial_object(false)
-            , m_send_partial_object(false)
-            , m_edit_objects(false)
-        {
-        }
+      Capabilities()
+          : m_get_partial_object(false), m_send_partial_object(false), m_edit_objects(false)
+      {
+      }
 
-        void setCanGetPartialObject(bool b) { m_get_partial_object = b; }
-        void setCanSendPartialobject(bool b) { m_send_partial_object = b; }
-        void setCanEditObjects(bool b) { m_edit_objects = b; }
+      void setCanGetPartialObject(bool b) { m_get_partial_object = b; }
+      void setCanSendPartialobject(bool b) { m_send_partial_object = b; }
+      void setCanEditObjects(bool b) { m_edit_objects = b; }
 
-        bool canGetPartialObject()  const { return m_get_partial_object; }
-        bool canSendPartialObject() const { return m_send_partial_object; }
-        bool canEditObjects() const { return m_edit_objects; }
+      bool canGetPartialObject() const { return m_get_partial_object; }
+      bool canSendPartialObject() const { return m_send_partial_object; }
+      bool canEditObjects() const { return m_edit_objects; }
 
     private:
-        bool m_get_partial_object;
-        bool m_send_partial_object;
-        bool m_edit_objects;
-    };
-
-    // -------------------------------------------------------------------------
-
-    MTPDevice();
-    ~MTPDevice();
-
-    bool connect(LIBMTP_raw_device_t *dev);
-    bool connect(int dev_no = 0);
-    bool connect(const std::string &dev_file);
-    void disconnect();
-
-    void enableMove(bool e = true) { m_move_enabled = e; }
-
-    uint64_t storageTotalSize() const;
-    uint64_t storageFreeSize() const;
-
-    int dirCreateNew(const std::string &path);
-    int dirRemove(const std::string &path);
-    int dirRename(const std::string &oldpath, const std::string &newpath);
-    const TypeDir *dirFetchContentFromCache(std::string path);
-    
-    //the item type: 0 unknown, 1:folder, 2:file
-    //#define MTP_ITEMTYPE_UNKOWN (0)
-    //#define MTP_ITEMTYPE_FOLDER (1)
-    //#define MTP_ITEMTYPE_FILE (2)
-    //const TypeDir *dirFetchContent(std::string path, int *itemType);
-    //int dirFetchCount(std::string path);
-
-    int rename(const std::string &oldpath, const std::string &newpath);
-
-    int filePull(const std::string &src, const std::string &dst);
-    int filePush(const std::string &src, const std::string &dst);
-    int fileRemove(const std::string &path);
-    int fileRename(const std::string &oldpath, const std::string &newpath);
-	int filesplitPull(const std::string &src,const std::string &dst,uint32_t size, uint32_t offset,unsigned char* buf);
-    Capabilities getCapabilities() const;
-
-    static bool listDevices(bool verbose, const std::string &dev_file);
-    string& getUUID(){return mUUID;}
-    int32_t getFileInfoById(uint32_t id, struct stat *st);
-    void criticalEnter1() { m_device_mutex.lock(); }
-    void criticalLeave1() { m_device_mutex.unlock(); }
-    bool isFileExist(const uint32_t id);
-    int32_t autoListAll();
-    int getEvent(char *buf, uint32_t bufLen);
-	int setEvent(char *buf, uint32_t bufLen);
-    int launchTasks();
-    bool indexingDone(){return isIndexingDone;};
-
-private:
-
+      bool m_get_partial_object;
+      bool m_send_partial_object;
+      bool m_edit_objects;
+   };
+
+   // -------------------------------------------------------------------------
+
+   MTPDevice();
+   ~MTPDevice();
+
+   bool connect(LIBMTP_raw_device_t *dev);
+   bool connect(int dev_no = 0);
+   bool connect(const std::string &dev_file);
+   void disconnect();
+
+   void enableMove(bool e = true) { m_move_enabled = e; }
+
+   uint64_t storageTotalSize() const;
+   uint64_t storageFreeSize() const;
+
+   int dirCreateNew(const std::string &path);
+   int dirRemove(const std::string &path);
+   int dirRename(const std::string &oldpath, const std::string &newpath);
+   const TypeDir *dirFetchContentFromCache(std::string path);
+
+   //the item type: 0 unknown, 1:folder, 2:file
+   //#define MTP_ITEMTYPE_UNKOWN (0)
+   //#define MTP_ITEMTYPE_FOLDER (1)
+   //#define MTP_ITEMTYPE_FILE (2)
+   //const TypeDir *dirFetchContent(std::string path, int *itemType);
+   //int dirFetchCount(std::string path);
+
+   int rename(const std::string &oldpath, const std::string &newpath);
+
+   int filePull(const std::string &src, const std::string &dst);
+   int filePush(const std::string &src, const std::string &dst);
+   int fileRemove(const std::string &path);
+   int fileRename(const std::string &oldpath, const std::string &newpath);
+   int filesplitPull(const std::string &src, const std::string &dst, uint32_t size, uint32_t offset, unsigned char *buf);
+   Capabilities getCapabilities() const;
+
+   static bool listDevices(bool verbose, const std::string &dev_file);
+   string &getUUID() { return mUUID; }
+   int32_t getFileInfoById(uint32_t id, struct stat *st);
+   void criticalEnter1() { m_device_mutex.lock(); }
+   void criticalLeave1() { m_device_mutex.unlock(); }
+   bool isFileExist(const uint32_t id);
+   int32_t autoListAll();
+   int getEvent(char *buf, uint32_t bufLen);
+   int setEvent(char *buf, uint32_t bufLen);
+   int launchTasks();
+   bool indexingDone() { return isIndexingDone; };
+   bool isMediaType(const std::string &path);
+
+ private:
 #if 0
     void criticalEnter() { m_device_mutex.lock(); }
     void criticalLeave() { m_device_mutex.unlock(); }
 #else
-    void criticalEnter() {  }
-    void criticalLeave() {  }
+   void criticalEnter()
+   {
+   }
+   void criticalLeave() {}
 #endif
 
-    bool enumStorages();
-    static Capabilities getCapabilities(const MTPDevice &device);
-    bool connect_priv(int dev_no, const std::string &dev_file);
-    int getAllFolderAndFiles(LIBMTP_mtpdevice_t *device, LIBMTP_devicestorage_t *storage, const uint32_t id, string &path, const string &lastModePath = "");
-    int readByRingBuf(const uint32_t id, const uint64_t fileSize, const uint32_t size, const uint32_t offset, const unsigned char* buf);
-    void printTrackInfo(const smtpfs_trackInfo *track);
-    int fillTrackInfo(smtpfs_trackInfo *dst, const LIBMTP_track_t *src, const char *path, int type);
-    int fillTrackInfoByFile(smtpfs_trackInfo *dst, const LIBMTP_file_t *src, const char *path, int type);
-    int getMediaFileType(LIBMTP_file_t *mtpFile);
-	int setLastModeSyncPath(string path);
-
-private:
-	LIBMTP_mtpdevice_t *m_device;
-	Capabilities m_capabilities;
-	std::mutex m_device_mutex;
-	TypeDir  m_root_dir;
-	bool m_move_enabled;
-	static uint32_t s_root_node;
-	string mUUID;
-	int m_list_all_done;
-	int m_read_data_cmd_coming;
-	RingBuffer *m_rbuf;
-	//below variable is used for current playing file
-	string m_fileName;
-	uint32_t m_fileId;
-	uint64_t m_fileSize;
-	uint64_t m_fileOffset;
-
-	//for event notify
-	uint32_t m_trackList_offset;
-	std::vector<smtpfs_trackInfo> m_trackMetaList;
-
-	// for thread flag
-	bool scanThreadRun;
-	//scan track done
-	bool isIndexingDone;
-	//last mode path
-	string m_lastmode_path;
+   bool enumStorages();
+   static Capabilities getCapabilities(const MTPDevice &device);
+   bool connect_priv(int dev_no, const std::string &dev_file);
+   int getAllFolderAndFiles(LIBMTP_mtpdevice_t *device, LIBMTP_devicestorage_t *storage, const uint32_t id, string &path, const string &lastModePath = "");
+   int readByRingBuf(const uint32_t id, const uint64_t fileSize, const uint32_t size, const uint32_t offset, const unsigned char *buf);
+   void printTrackInfo(const smtpfs_trackInfo *track);
+   int fillTrackInfo(smtpfs_trackInfo *dst, const LIBMTP_track_t *src, const char *path, int type);
+   int fillTrackInfoByFile(smtpfs_trackInfo *dst, const LIBMTP_file_t *src, const char *path, int type);
+   int getMediaFileType(const std::string &filename);
+   int setLastModeSyncPath(string path);
+
+ private:
+   LIBMTP_mtpdevice_t *m_device;
+   Capabilities m_capabilities;
+   std::mutex m_device_mutex;
+   TypeDir m_root_dir;
+   bool m_move_enabled;
+   static uint32_t s_root_node;
+   string mUUID;
+   int m_list_all_done;
+   int m_read_data_cmd_coming;
+   RingBuffer *m_rbuf;
+   //below variable is used for current playing file
+   string m_fileName;
+   uint32_t m_fileId;
+   uint64_t m_fileSize;
+   uint64_t m_fileOffset;
+
+   //for event notify
+   uint32_t m_trackList_offset;
+   std::vector<smtpfs_trackInfo> m_trackMetaList;
+
+   // for thread flag
+   bool scanThreadRun;
+   //scan track done
+   bool isIndexingDone;
+   //last mode path
+   string m_lastmode_path;
 
    //lastmode sync done
    bool m_lastMode_sync_done;
 
-public:
-	//for device connected
-	sem_t device_connect_sem;
-
+   int32_t mScanThPolicy;
+   int32_t mScanThPriority;
+   std::map<std::string, std::regex> mReMapExclude;
+   std::regex mReExtNameAudio;
+   std::regex mReExtNameVideo;
+   std::regex mReExtNameImage;
+   std::regex mReExtNamePlaylist;
+   std::regex mReExtNameAudiobook;
+
+   // performance statistics
+   uint32_t mFolderIgnored;
+   uint32_t mFileIgnored;
+
+ public:
+   //for device connected
+   sem_t device_connect_sem;
 };
 
 #endif // SMTPFS_MTP_DEVICE_H
diff --git a/src/simple-mtpfs-util.cpp b/src/simple-mtpfs-util.cpp
index cc56969..502aa64 100755
--- a/src/simple-mtpfs-util.cpp
+++ b/src/simple-mtpfs-util.cpp
@@ -33,6 +33,7 @@ extern "C" {
 #include <time.h>
 #include <string.h>
 }
+// #include <sstream>
 #ifdef HAVE_LIBUSB1
 #  include <climits>
 extern "C" {
@@ -351,233 +352,365 @@ void mytoupper(string& s)
 }
 
 
-bool isAudioType(const char *fileName)
+// bool isAudioType(const char *fileName)
+// {
+//    const char* extArray[] = 
+//    {
+// 		".mp3",
+// 		".wma",
+// 		".aac",
+// 		".wav",
+// 		".wave",
+// 		".flac",
+// 		".oga",
+// 		".ogg",
+// 		".mka",
+//     };
+
+//    if(fileName == NULL)
+//    {
+//       LogError("file name is NULL");
+//       return false;
+//    }
+
+//    string str = fileName;
+//    mytolower(str);
+
+//    int i = 0;
+//    int total = sizeof(extArray)/sizeof(char *);
+//    string extStr = "";
+//    for(i = 0; i < total; i++)
+//    {
+//       extStr = extArray[i];
+//       if(endWith(str, extStr))
+//       {
+//          return true;
+//       }
+//    }
+
+//    return false;
+// }
+
+// bool isVideoType(const char *fileName)
+// {
+//    const char* extArray[] = 
+//    {
+// 		".avi",
+// 		".asf",
+// 		".wmv",
+// 		".mkv",
+// 		".mebm",
+// 		".mpg",
+// 		".dat",
+// 		".mpeg",
+// 		".evo",
+// 		".vob",
+// 		".vdr",
+// 		".mod",
+// 		".ts",
+// 		".trp",
+// 		".mts",
+// 		".m2t",
+// 		".m2ts",
+// 		".tod",
+// 		".mp4",
+// 		".m4v",
+// 		".3gp",
+// 		".mov",
+// 		".qt",
+//     };
+
+//    if(fileName == NULL)
+//    {
+//       LogError("file name is NULL");
+//       return false;
+//    }
+
+//    string str = fileName;
+//    mytolower(str);
+
+//    int i = 0;
+//    int total = sizeof(extArray)/sizeof(char *);
+//    string extStr = "";
+//    for(i = 0; i < total; i++)
+//    {
+//       extStr = extArray[i];
+//       if(endWith(str, extStr))
+//       {
+//          return true;
+//       }
+//    }
+
+//    return false;
+// }
+
+// bool isImageType(const char *fileName)
+// {
+//    const char* extArray[] = 
+//    {
+// 		".bmp",
+// 		".jpg",
+// 		".jpeg",
+// 		".gif",
+// 		".tif",
+// 		".png",
+//     };
+
+//    if(fileName == NULL)
+//    {
+//       LogError("file name is NULL");
+//       return false;
+//    }
+
+//    string str = fileName;
+//    mytolower(str);
+
+//    int i = 0;
+//    int total = sizeof(extArray)/sizeof(char *);
+//    string extStr = "";
+//    for(i = 0; i < total; i++)
+//    {
+//       extStr = extArray[i];
+//       if(endWith(str, extStr))
+//       {
+//          return true;
+//       }
+//    }
+
+//    return false;
+// }
+
+// bool isPlayListType(const char *fileName)
+// {
+//    const char* extArray[] = 
+//    {
+//       ".m3u",
+//       ".m3u8",
+//       ".pls",
+//       ".asx",
+//       ".wpl",
+//       ".xspf",
+//    };
+
+//    if(fileName == NULL)
+//    {
+//       LogError("file name is NULL");
+//       return false;
+//    }
+
+//    string str = fileName;
+//    mytolower(str);
+
+//    int i = 0;
+//    int total = sizeof(extArray)/sizeof(char *);
+//    string extStr = "";
+//    for(i = 0; i < total; i++)
+//    {
+//       extStr = extArray[i];
+//       if(endWith(str, extStr))
+//       {
+//          return true;
+//       }
+//    }
+
+//    return false;
+// }
+
+// bool isAudioBooksType(const char *fileName)
+// {
+//    const char* extArray[] = 
+//    {
+//       ".m4a",
+//       ".m4b",
+//    };
+
+//    if(fileName == NULL)
+//    {
+//       LogError("file name is NULL");
+//       return false;
+//    }
+
+//    string str = fileName;
+//    mytolower(str);
+
+//    int i = 0;
+//    int total = sizeof(extArray)/sizeof(char *);
+//    string extStr = "";
+//    for(i = 0; i < total; i++)
+//    {
+//       extStr = extArray[i];
+//       if(endWith(str, extStr))
+//       {
+//          return true;
+//       }
+//    }
+
+//    return false;
+// }
+
+// bool isMediaType(const char *fileName)
+// {
+//    if(   isAudioType(fileName) 
+//       || isVideoType(fileName) 
+// 	  || isImageType(fileName) 
+// 	  || isPlayListType(fileName)
+// 	  || isAudioBooksType(fileName)
+// 	)
+// 	{
+// 		return true;
+// 	}
+// 	else
+// 	{
+// 		return false;
+// 	}
+// }
+
+// bool isMatchExtName(const std::string &name, const std::regex& re)
+// {
+//    if (name.empty())
+//    {
+//       LogError("file name is empty");
+//       return false;
+//    }
+//    std::string nameLower = name;
+
+//    std::transform(nameLower.begin(), nameLower.end(), nameLower.begin(), ::tolower);
+//    auto it = std::find_if(extNameLowerList.cbegin(), extNameLowerList.cend(), [nameLower](const std::string &extNameLower) {
+//       if (endWith(nameLower, extNameLower))
+//       {
+//          return true;
+//       }
+//       else
+//       {
+//          return false;
+//       }
+//    });
+
+//    return (it != extNameLowerList.end());
+// }
+
+bool makePatternStrArray(std::string &pattern, const std::vector<std::string> &arr)
 {
-   const char* extArray[] = 
+   if (arr.empty())
    {
-		".mp3",
-		".wma",
-		".aac",
-		".wav",
-		".wave",
-		".flac",
-		".oga",
-		".ogg",
-		".mka",
-    };
-
-   if(fileName == NULL)
-   {
-      LogError("file name is NULL");
+      LogError("the string vector is empty");
       return false;
    }
-
-   string str = fileName;
-   mytolower(str);
-
-   int i = 0;
-   int total = sizeof(extArray)/sizeof(char *);
-   string extStr = "";
-   for(i = 0; i < total; i++)
+   try
    {
-      extStr = extArray[i];
-      if(endWith(str, extStr))
+      std::regex reExtName("(\\.).+", std::regex_constants::icase);
+      std::stringstream ss;
+
+      for (auto it = arr.begin(); it != arr.end(); ++ it)
       {
-         return true;
+         if (!std::regex_match(*it, reExtName))
+         {
+            LogInfo("not a extension string: %s", it->c_str());
+         }
+         else
+         {
+            if (it != arr.begin())
+            {
+               ss << "|";
+            }
+            ss << ".+(\\.)" << it->substr(1, it->length());
+         }
       }
-   }
+      pattern = ss.str();
+      LogInfo("make the regex pattern: %s", ss.str().c_str());
 
-   return false;
-}
-
-bool isVideoType(const char *fileName)
-{
-   const char* extArray[] = 
-   {
-		".avi",
-		".asf",
-		".wmv",
-		".mkv",
-		".mebm",
-		".mpg",
-		".dat",
-		".mpeg",
-		".evo",
-		".vob",
-		".vdr",
-		".mod",
-		".ts",
-		".trp",
-		".mts",
-		".m2t",
-		".m2ts",
-		".tod",
-		".mp4",
-		".m4v",
-		".3gp",
-		".mov",
-		".qt",
-    };
-
-   if(fileName == NULL)
+      return true;
+   }
+   catch (std::regex_error e)
    {
-      LogError("file name is NULL");
-      return false;
+      LogError("regex exception: %d; %s", e.code(), e.what());
    }
-
-   string str = fileName;
-   mytolower(str);
-
-   int i = 0;
-   int total = sizeof(extArray)/sizeof(char *);
-   string extStr = "";
-   for(i = 0; i < total; i++)
+   catch (...)
    {
-      extStr = extArray[i];
-      if(endWith(str, extStr))
-      {
-         return true;
-      }
+      LogError("catch unknown exception while match excluding string");
    }
 
    return false;
 }
 
-bool isImageType(const char *fileName)
+bool makeRegEx(std::regex &re, const std::string &pattern)
 {
-   const char* extArray[] = 
-   {
-		".bmp",
-		".jpg",
-		".jpeg",
-		".gif",
-		".tif",
-		".png",
-    };
-
-   if(fileName == NULL)
+   if (pattern.empty())
    {
-      LogError("file name is NULL");
-      return false;
+      LogWarning("the pattern is empty");
    }
-
-   string str = fileName;
-   mytolower(str);
-
-   int i = 0;
-   int total = sizeof(extArray)/sizeof(char *);
-   string extStr = "";
-   for(i = 0; i < total; i++)
+   try
    {
-      extStr = extArray[i];
-      if(endWith(str, extStr))
-      {
-         return true;
-      }
+      LogInfo("make regular expression for pattern: %s", pattern.c_str());
+      re = std::regex(pattern, std::regex_constants::icase);
+      return true;
    }
-
-   return false;
-}
-
-bool isPlayListType(const char *fileName)
-{
-   const char* extArray[] = 
-   {
-      ".m3u",
-      ".m3u8",
-      ".pls",
-      ".asx",
-      ".wpl",
-      ".xspf",
-   };
-
-   if(fileName == NULL)
+   catch (std::regex_error e)
    {
-      LogError("file name is NULL");
-      return false;
+      LogError("regex exception: %d; %s", e.code(), e.what());
    }
-
-   string str = fileName;
-   mytolower(str);
-
-   int i = 0;
-   int total = sizeof(extArray)/sizeof(char *);
-   string extStr = "";
-   for(i = 0; i < total; i++)
+   catch (...)
    {
-      extStr = extArray[i];
-      if(endWith(str, extStr))
-      {
-         return true;
-      }
+      LogError("catch unknown exception while match excluding string");
    }
 
    return false;
 }
 
-bool isAudioBooksType(const char *fileName)
+bool makeRegExStrArray(std::regex &re, const std::vector<std::string> &strVec)
 {
-   const char* extArray[] = 
-   {
-      ".m4a",
-      ".m4b",
-   };
+   std::string pattern;
 
-   if(fileName == NULL)
+   if (makePatternStrArray(pattern, strVec))
    {
-      LogError("file name is NULL");
-      return false;
-   }
-
-   string str = fileName;
-   mytolower(str);
-
-   int i = 0;
-   int total = sizeof(extArray)/sizeof(char *);
-   string extStr = "";
-   for(i = 0; i < total; i++)
-   {
-      extStr = extArray[i];
-      if(endWith(str, extStr))
+      if (makeRegEx(re, pattern))
       {
          return true;
       }
+      else
+      {
+         LogError("make regEx for audio extension name failed");
+      }
+   }
+   else
+   {
+      LogError("make pattern failed");
    }
 
    return false;
 }
 
-bool isMediaType(const char *fileName)
+bool reMatch(const std::string& str, const std::regex& re)
 {
-   if(   isAudioType(fileName) 
-      || isVideoType(fileName) 
-	  || isImageType(fileName) 
-	  || isPlayListType(fileName)
-	  || isAudioBooksType(fileName)
-	)
-	{
-		return true;
-	}
-	else
-	{
-		return false;
-	}
+    //  use c++ regex match
+    try
+    {
+        return std::regex_match(str, re);
+    }
+    catch (std::regex_error e)
+    {
+        LogError("regex exception: %d; %s; str: %s;", e.code(), e.what(), str.c_str());
+    }
+    catch (...)
+    {
+        LogError("catch unknown exception while match excluding string; str: %s", str.c_str());
+    }
+
+    return false;
 }
 
-int setThreadPriority(uint32_t priority)
+int setThreadPriority(int32_t policy, int32_t priority)
 {
    sched_param param;
-   int p = SCHED_RR;
 
-   //LogInfo("enter");
+   LogInfo("set thread sched policy: %d, priority: %d", policy, priority);
 
    memset(&param, 0, sizeof(param));
 
-   if (p != SCHED_OTHER)
+   if (policy != SCHED_OTHER)
    {
-      LogInfo("set FIFO, %d", priority);
       param.sched_priority = (int)priority;
-      if (pthread_setschedparam(pthread_self(), p, &param) != 0)
+      if (pthread_setschedparam(pthread_self(), policy, &param) != 0)
       {
          LogError("pthread_setschedparam failed!");
          return -1;
@@ -585,88 +718,4 @@ int setThreadPriority(uint32_t priority)
    }
 
    return 0;
-}
-
-
-bool ignoreFolder(char* name)
-{
-   //complete match
-   const char* ignoreList0[] = 
-   {
-      "data",
-      "doc",
-      "documents",
-      "document",
-   };
-
-   //partern match
-   const char* ignoreList[] = 
-   {
-      "android",
-      "navi",
-      "backup",
-      "baidu",
-      "log",
-      "tencent",
-      "qq",
-      "map",
-      "lib",
-      "tempdata",
-      "cache",
-      "360",
-      "alipay",
-      "setting",
-      "message",
-      "sdk",
-      "alarm",
-      "document",
-      "download",
-      "notification",
-      "samsung",
-      "catfish",
-      "yellowpage",
-   };
-
-   if(name == NULL)
-   {
-      LogError("name is NULL");
-      return true;
-   }
-
-   string fileStr = name;
-
-   mytolower(fileStr);
-
-   int i = 0;
-   int total = 0;
-
-   //complete match
-   total = sizeof(ignoreList0)/sizeof(char *);
-   for(i = 0; i < total; i++)
-   {
-      string str = ignoreList0[i];
-      if(str == fileStr)
-      {
-         return true;
-      }
-   }
-
-   //partern match
-   total = sizeof(ignoreList)/sizeof(char *);
-
-   for(i = 0; i < total; i++)
-   {
-      string subStr = ignoreList[i];
-      if(fileStr.length() < subStr.length())
-      {
-         continue;
-      }
-
-      if(fileStr.find(subStr.c_str()) != string::npos)
-      {
-         return true;
-      }
-   }
-
-   return false;
 }
\ No newline at end of file
diff --git a/src/simple-mtpfs-util.h b/src/simple-mtpfs-util.h
index c08b724..b7bb773 100755
--- a/src/simple-mtpfs-util.h
+++ b/src/simple-mtpfs-util.h
@@ -21,6 +21,7 @@
 #include <config.h>
 #include <cstdint>
 #include <string>
+#include <regex>
 #include <sys/ioctl.h>
 #include <linux/limits.h>
 
@@ -28,6 +29,8 @@
 #  include <libmtp.h>
 #endif // HAVE_LIBUSB1
 
+#include "simple-mtpfs.h"
+
 // typedef char int8_t;
 // typedef unsigned char uint8_t;
 // typedef short int16_t;
@@ -69,12 +72,17 @@ bool smtpfs_reset_device(LIBMTP_raw_device_t *device);
 #endif // HAVE_LIBUSB1
 
 bool endWith(const std::string& str, const std::string& substr);
-bool isAudioType(const char *fileName);
-bool isVideoType(const char *fileName);
-bool isImageType(const char *fileName);
-bool isPlayListType(const char *fileName);
-bool isAudioBooksType(const char *fileName);
-bool isMediaType(const char *fileName);
+// bool isAudioType(const char *fileName);
+// bool isVideoType(const char *fileName);
+// bool isImageType(const char *fileName);
+// bool isPlayListType(const char *fileName);
+// bool isAudioBooksType(const char *fileName);
+// bool isMediaType(const char *fileName);
+// bool isMatchExtName(const std::string &name, const std::regex& re);
+bool makePatternStrArray(std::string &pattern, const std::vector<std::string> &strVec);
+bool makeRegEx(std::regex &re, const std::string &pattern);
+bool makeRegExStrArray(std::regex &re, const std::vector<std::string> &strVec);
+bool reMatch(const std::string &str, const std::regex &re);
 
 inline long getSysRunTime()
 {
@@ -84,71 +92,6 @@ inline long getSysRunTime()
          ts.tv_nsec / 1000000L;
 }
 
-int setThreadPriority(uint32_t priority);
-bool ignoreFolder(char* name);
-
-#define SMTPFS_EVENT_MAXLEN      (8*1024)//128k
-
-typedef struct
-{
-   #define SMTPFS_EVENT_SYNC_LASTMODE  (0x01)
-   #define SMTPFS_EVENT_TRACKLIST      (0x02)
-   int eventType;
-   int len;//include the event struct itself
-}smtpfs_event;
-
-#define MTP_PATHNAME_MAXLEN (512)
-#define MTP_METADATA_NAME_MAXLEN (128)
-typedef struct
-{ 
-   #define MTP_FILE_TYPE_UNKNOWN (0x0)
-   #define MTP_FILE_TYPE_AUDIO (0x1)
-   #define MTP_FILE_TYPE_VIDEO (0x2)
-   #define MTP_FILE_TYPE_IMAGE (0x4)
-   #define MTP_FILE_TYPE_PLAYLIST (0x8)
-   #define MTP_FILE_TYPE_AUDIOBOOKS (0x10)
-   int   type;
-   char  path[MTP_PATHNAME_MAXLEN];//folder path
-   //char  fileName[NAME_MAX];//filename
-   char  title[MTP_METADATA_NAME_MAXLEN]; /**< Track title */
-   char  artist[MTP_METADATA_NAME_MAXLEN]; /**< Name of recording artist */
-   //char  composer[NAME_MAX]; /**< Name of recording composer */
-   char  genre[MTP_METADATA_NAME_MAXLEN]; /**< Genre name for track */
-   char  album[MTP_METADATA_NAME_MAXLEN]; /**< Album name for track */
-   uint32_t duration; /**< Duration in milliseconds */
-   uint32_t samplerate; /**< Sample rate of original file, min 0x1f80 max 0xbb80 */
-   uint32_t nochannels; /**< Number of channels in this recording 0 = unknown, 1 or 2 */
-   uint32_t wavecodec; /**< FourCC wave codec name */
-   uint32_t bitrate; /**< (Average) bitrate for this file min=1 max=0x16e360 */
-   uint64_t filesize; /**< Size of track file in bytes */
-   time_t modificationdate; /**< Date of last alteration of the track */
-   uint16_t tracknumber; /**< Track number (in sequence on recording) */
-   uint16_t rating; /**< User rating 0-100 (0x00-0x64) */
-} smtpfs_trackInfo;
-
-//for track list: smtpfs_event + smtpfs_trackList + N*smtpfs_trackInfo
-typedef struct
-{
-   int   fragment;
-   int   count; 
-   smtpfs_trackInfo trackList[0];
-}smtpfs_trackList;
-
-
-//for sync lastmode: smtpfs_event + smtpfs_sync_lastmode
-typedef struct
-{
-   char path[MTP_PATHNAME_MAXLEN];
-}smtpfs_sync_lastmode;
-
-#define SMTPFSIOCTLNODE "mediaone_smtpfs_node"
-#define SMTPFSMAGIC 'm'
-
-//write  event
-#define SMTPFS_SETEVENT _IOW(SMTPFSMAGIC, 1, char[SMTPFS_EVENT_MAXLEN])
-
-//read event
-#define SMTPFS_GETEVENT _IOR(SMTPFSMAGIC, 2, char[SMTPFS_EVENT_MAXLEN])
-
+int setThreadPriority(int32_t policy, int32_t priority);
 
 #endif // SIMPLE_MTPFS_UTIL
diff --git a/src/simple-mtpfs.h b/src/simple-mtpfs.h
new file mode 100755
index 0000000..fae2b9b
--- /dev/null
+++ b/src/simple-mtpfs.h
@@ -0,0 +1,117 @@
+/******************************************************************************
+ * Project         Harman Car Multimedia System
+ * (c) copyright   2017-2020
+ * Company         Harman Automotive Systems
+ *                 All rights reserved
+ * Secrecy Level   STRICTLY CONFIDENTIAL
+ ******************************************************************************/
+/**
+ * @file           simple-mtpfs.h
+ * @author         Xiaojun.Zou@harman.com
+ * @brief          the interface for simple-mtpfs
+ * 
+ * @ATTENTION      this file is used to define the interface for simple-mtpfs. it could only be 
+ *                 modified from simple-mtpfs.
+ */
+
+#ifndef SIMPLE_MTPFS_H
+#define SIMPLE_MTPFS_H
+
+#include <stdint.h>
+
+#include <sys/ioctl.h>
+
+#define SMTPFS_EVENT_MAXLEN (8 * 1024) //128k
+
+typedef struct
+{
+#define SMTPFS_EVENT_SYNC_LASTMODE (0x01)
+#define SMTPFS_EVENT_TRACKLIST (0x02)
+   int eventType;
+   int len; //include the event struct itself
+} smtpfs_event;
+
+#define MTP_PATHNAME_MAXLEN (512)
+#define MTP_METADATA_NAME_MAXLEN (128)
+typedef struct
+{
+#define MTP_FILE_TYPE_UNKNOWN (0x0)
+#define MTP_FILE_TYPE_AUDIO (0x1)
+#define MTP_FILE_TYPE_VIDEO (0x2)
+#define MTP_FILE_TYPE_IMAGE (0x4)
+#define MTP_FILE_TYPE_PLAYLIST (0x8)
+#define MTP_FILE_TYPE_AUDIOBOOKS (0x10)
+   int type;
+   char path[MTP_PATHNAME_MAXLEN]; //folder path
+   //char  fileName[NAME_MAX];//filename
+   char title[MTP_METADATA_NAME_MAXLEN];  /**< Track title */
+   char artist[MTP_METADATA_NAME_MAXLEN]; /**< Name of recording artist */
+   //char  composer[NAME_MAX]; /**< Name of recording composer */
+   char genre[MTP_METADATA_NAME_MAXLEN]; /**< Genre name for track */
+   char album[MTP_METADATA_NAME_MAXLEN]; /**< Album name for track */
+   uint32_t duration;                    /**< Duration in milliseconds */
+   uint32_t samplerate;                  /**< Sample rate of original file, min 0x1f80 max 0xbb80 */
+   uint32_t nochannels;                  /**< Number of channels in this recording 0 = unknown, 1 or 2 */
+   uint32_t wavecodec;                   /**< FourCC wave codec name */
+   uint32_t bitrate;                     /**< (Average) bitrate for this file min=1 max=0x16e360 */
+   uint64_t filesize;                    /**< Size of track file in bytes */
+   time_t modificationdate;              /**< Date of last alteration of the track */
+   uint16_t tracknumber;                 /**< Track number (in sequence on recording) */
+   uint16_t rating;                      /**< User rating 0-100 (0x00-0x64) */
+} smtpfs_trackInfo;
+
+//for track list: smtpfs_event + smtpfs_trackList + N*smtpfs_trackInfo
+typedef struct
+{
+   int fragment;
+   int count;
+   smtpfs_trackInfo trackList[0];
+} smtpfs_trackList;
+
+//for sync lastmode: smtpfs_event + smtpfs_sync_lastmode
+typedef struct
+{
+   char path[MTP_PATHNAME_MAXLEN];
+} smtpfs_sync_lastmode;
+
+//  for SMTPFS_SETCONFIG.
+//  use this IO to set config from MediaOne.
+//  TODO. please consider the config content is passed twice or more; because the
+//  length of the config content is more that the limitation: SMTPFS_EVENT_MAXLEN.
+//	for smtpfs config, there are only two field for every one: key, and value.
+#define SMTPFS_CONFIG_UNKNOWN (~0)
+#define SMTPFS_CONFIG_THREAD_POLICY (0x1)
+#define SMTPFS_CONFIG_THREAD_PRIORITY (0x2)
+#define SMTPFS_CONFIG_EXCLUDE_PATTERN (0x3)
+// for these following support extension name config, it should push the extension name to supported list for per ioctl calling.
+#define SMTPFS_CONFIG_EXTAUDIO (0x4)
+#define SMTPFS_CONFIG_EXTVIDEO (0x5)
+#define SMTPFS_CONFIG_EXTIMAGE (0x6)
+#define SMTPFS_CONFIG_EXTPLAYLIST (0x7)
+#define SMTPFS_CONFIG_EXTAUDIOBOOK (0x8)
+// for log config
+#define SMTPFS_CONFIG_LOGLEVEL (0x9)
+#define SMTPFS_CONFIG_LIBMTP_LOGLEVEL (0xa)
+typedef struct
+{
+   //	the config type
+   uint32_t type;
+   //  including the smtpfs_config itself
+   uint32_t len;
+   //  the value string are followed; no zero-terminate.
+   //  char value[0];
+} smtpfs_config;
+
+#define SMTPFSIOCTLNODE "mediaone_smtpfs_node"
+#define SMTPFSMAGIC 'm'
+
+//write  event
+#define SMTPFS_SETEVENT _IOW(SMTPFSMAGIC, 1, char[SMTPFS_EVENT_MAXLEN])
+
+//read event
+#define SMTPFS_GETEVENT _IOR(SMTPFSMAGIC, 2, char[SMTPFS_EVENT_MAXLEN])
+
+//  set config from MediaOne
+#define SMTPFS_SETCONFIG _IOW(SMTPFSMAGIC, 3, char[SMTPFS_EVENT_MAXLEN])
+
+#endif

