*******************************************************************************
Date         : 2018-07-25
Author       : Jing Deng
Harman International Industries, Incorporated

Description  : This patch is for medialaunch connect MTP bugs.
ChangeList   : 5232958
*******************************************************************************

diff --git a/src/makefile.am b/src/makefile.am
old mode 100644
new mode 100755
index b9b7da0..6753158
--- a/src/makefile.am
+++ b/src/makefile.am
@@ -1,7 +1,7 @@
 bin_PROGRAMS          = simple-mtpfs
 simple_mtpfs_CXXFLAGS = -Wall -pedantic $(FUSE_CFLAGS) $(LIBUSB1_CFLAGS)
 simple_mtpfs_CPPFLAGS = -DFUSE_USE_VERSION=28
-simple_mtpfs_LDADD    = $(MTP_LIBS) $(FUSE_LIBS) $(LIBUSB1_LIBS)
+simple_mtpfs_LDADD    = $(MTP_LIBS) $(FUSE_LIBS) $(LIBUSB1_LIBS) -lsqlite3
 simple_mtpfs_SOURCES  =                 \
 	simple-mtpfs-fuse.h             \
 	simple-mtpfs-libmtp.h           \
@@ -14,6 +14,7 @@ simple_mtpfs_SOURCES  =                 \
 	simple-mtpfs-type-file.h        \
 	simple-mtpfs-type-tmp-file.h    \
 	simple-mtpfs-util.h             \
+	simple-mtpfs-db.hpp             \
 	simple-mtpfs-fuse.cpp           \
 	simple-mtpfs-libmtp.cpp         \
 	simple-mtpfs-log.cpp            \
@@ -24,4 +25,5 @@ simple_mtpfs_SOURCES  =                 \
 	simple-mtpfs-type-dir.cpp       \
 	simple-mtpfs-type-file.cpp      \
 	simple-mtpfs-type-tmp-file.cpp  \
-	simple-mtpfs-util.cpp
+	simple-mtpfs-util.cpp           \
+	simple-mtpfs-db.cpp
diff --git a/src/simple-mtpfs-db.cpp b/src/simple-mtpfs-db.cpp
new file mode 100755
index 0000000..4a4bb95
--- /dev/null
+++ b/src/simple-mtpfs-db.cpp
@@ -0,0 +1,459 @@
+#include "simple-mtpfs-db.hpp"
+#include "simple-mtpfs-log.h"
+
+using namespace std;
+
+static int sqliteBusyHandler(void *p, int retryTimes)
+{
+    //printf("retryTimes: %d\n", retryTimes);
+    sqlite3_sleep(50);
+    return 1;
+}
+
+sqlite3 *SIMPLE_DB::doConnect( const string &path )
+{
+   int32_t status = 0;
+   sqlite3 *db = NULL;
+
+   if ( path.empty()) 
+   {
+      return NULL;
+   }
+
+   status = sqlite3_open( path.c_str(), &db );
+   if ( SQLITE_OK != status ) 
+   {
+      sqlite3_close(db);
+      return NULL;
+   }
+
+   sqlite3_busy_handler(db, sqliteBusyHandler, (void *)db);
+
+   return db;
+}
+
+int queryDeviceCb(void* userData, int argc, char** argv, char** col)
+{
+   uint32_t *fileId = (uint32_t *)userData;
+   int32_t i = 0;
+
+   for(i = 0; i < argc; i++)
+   {
+      //printf("%s = %s\n", col[i], argv[i] ? argv[i] : "NULL");
+      if(argv[i])
+      {
+         *fileId = atoi(argv[i]);
+      }
+   }
+
+   return 0;
+}
+
+int32_t SIMPLE_DB::doCommit(const string &sqlStr, DBQueryCallback cb, void *userData, uint32_t retryTime)
+{
+   int32_t ret = 0;
+   
+   if(!mPsqlite3)
+   {
+      logmsg(" doCommit, mPsqlite3 is NULL\n");
+      return -1;
+   }
+
+   //printf("doCommit, sqlStr: %s\n", sqlStr.c_str());
+
+   ret = sqlite3_exec(mPsqlite3, sqlStr.c_str(), cb, userData, NULL);
+
+   //printf(" doCommit, ret: %d\n", ret);
+
+   return ret;
+}
+
+SIMPLE_DB::SIMPLE_DB(const string DBName)
+   : mPsqlite3(NULL)
+{
+   if(!DBName.empty())
+   {
+      mPsqlite3 = doConnect(DBName);
+   }
+
+#if 0
+   //create table
+   if(access(SMTPFSDBPATH, F_OK))
+   {
+      string zSQLDevices = "CREATE TABLE mtpdevices (\
+                           uuid       TEXT PRIMARY KEY  DEFAULT '' NOT NULL,\
+                           mtime      INTEGER DEFAULT 0 NOT NULL\
+                           );";
+      
+      string zSQLFile = "CREATE TABLE mtpfile (\
+                           path       TEXT    DEFAULT '' NOT NULL,\
+                           mtpId      INTEGER DEFAULT 0 NOT NULL,\
+                           uuid       TEXT    DEFAULT '' NOT NULL\
+                           );";
+
+
+      if(doCommit(zSQLDevices, NULL, NULL, 0))
+      {
+         printf(" doCommit, create device table failed\n");
+      }
+
+      if(doCommit(zSQLFile, NULL, NULL, 0))
+      {
+         printf(" doCommit, create file table failed\n");
+      }
+   }
+#endif
+}
+
+SIMPLE_DB::~SIMPLE_DB()
+{
+    if(mPsqlite3)
+    {
+        sqlite3_close(mPsqlite3);
+    }
+}
+
+int32_t SIMPLE_DB::queryDevice(string &uuid)
+{
+   char *zSQL = NULL;
+   int ret = 0;
+   int exist = 0;
+
+   if(!mPsqlite3)
+   {
+      logmsg(" queryDevice, mPsqlite3 is NULL\n");
+      return -1;
+   }
+
+   zSQL = sqlite3_mprintf("select uuid from mtpdevices where uuid = '%q'", uuid.c_str());
+
+   ret = doCommit(zSQL, queryDeviceCb, &exist, 0);
+   if(ret)
+   {
+      logmsg(" queryDevice, doCommit failed \n");
+      logmsg(" queryDevice, zSQL: ", zSQL, " \n");
+   }
+   
+   if(zSQL)
+   {
+      sqlite3_free(zSQL);
+   }
+
+   if(exist)
+   {
+      return 0;
+   }
+   
+   return -1;
+}
+
+int queryDeviceCountCb(void* userData, int argc, char** argv, char** col)
+{
+   int32_t *count = (int32_t *)userData;
+   int32_t i = 0;
+
+   for(i = 0; i < argc; i++)
+   {
+      //printf("%s = %s\n", col[i], argv[i] ? argv[i] : "NULL");
+      *count = atoi(argv[i]);
+   }
+
+   return 0;
+}
+
+int32_t SIMPLE_DB::getDeviceCount(int32_t *count)
+{
+   string sqlFmt;
+
+   if(!mPsqlite3)
+   {
+      logmsg(" getDeviceCount, mPsqlite3 is NULL\n");
+      return -1;
+   }
+
+   if(!count)
+   {
+      logmsg(" getDeviceCount, count is NULL\n");
+      return -1;
+   }
+
+   sqlFmt = "select count(*) from mtpdevices;";
+
+   //printf(" getDeviceCount, sqlStr: %s\n", sqlFmt.c_str());
+
+   if(doCommit(sqlFmt, queryDeviceCountCb, count, 0))
+   {
+      logmsg(" getDeviceCount, doCommit failed \n");
+      logmsg(" getDeviceCount, sqlStr: ", sqlFmt, "\n");
+      return -1;
+   }
+   
+   return 0;
+}
+
+
+int queryOldestDeviceCb(void* userData, int argc, char** argv, char** col)
+{
+   char *uuid = (char *)userData;
+   int32_t i = 0;
+
+   for(i = 0; i < argc; i++)
+   {
+      //printf("%s = %s\n", col[i], argv[i] ? argv[i] : "NULL");
+
+      if(argv[i])
+      {
+         memcpy(uuid, argv[i], strlen(argv[i]));
+      }
+   }
+
+   return 0;
+}
+
+int32_t SIMPLE_DB::getOldestDevice(const char *uuid)
+{
+   string sqlFmt;
+
+   if(!mPsqlite3)
+   {
+      logmsg(" getOldestDevice, mPsqlite3 is NULL\n");
+      return -1;
+   }
+
+   if(!uuid)
+   {
+      logmsg(" getOldestDevice, uuid is NULL\n");
+      return -1;
+   }
+
+   sqlFmt = "SELECT UUID FROM MTPDEVICES ORDER BY MTIME ASC LIMIT 0,1;";
+
+   //printf(" getOldestDevice, sqlStr: %s\n", sqlFmt.c_str());
+
+   if(doCommit(sqlFmt, queryOldestDeviceCb, (void *)uuid, 0))
+   {
+      logmsg(" getOldestDevice, doCommit failed \n");
+      logmsg(" getOldestDevice, sqlStr: ", sqlFmt, " \n");
+      return -1;
+   }
+
+   return 0;
+}
+
+int32_t SIMPLE_DB::checkDeviceCount()
+{
+   //firset check device count, delete more MAX_MTPDEVICE_COUNT device
+   int32_t devCount = 0;
+   getDeviceCount(&devCount);
+   printf("writeDevice, devCount: %d\n", devCount);
+   
+   if(devCount >= MAX_MTPDEVICE_COUNT)
+   {
+      //get the device uuid with the oldest time
+      char myUUID[256] = {""};
+      getOldestDevice(myUUID);
+
+      logmsg("writeDevice, myUUID: ", myUUID, "\n");
+
+      //delete the device
+      string tmpUUID = myUUID;
+      deleteDevice(tmpUUID);
+
+      //delete all the files for the device
+      deleteFileID(tmpUUID);
+   }
+
+   return 0;
+}
+
+int32_t SIMPLE_DB::writeDevice(string &uuid)
+{
+   int32_t ret = 0;
+   char *zSQL = NULL;
+
+   ret = queryDevice(uuid);
+   //insert
+   if(ret)
+   { 
+      checkDeviceCount();
+      
+      zSQL = sqlite3_mprintf("insert into mtpdevices values ('%q', '%d')", uuid.c_str(), time(NULL));
+   }
+   //update
+   else
+   {   
+      zSQL = sqlite3_mprintf("update mtpdevices set mtime = '%d' where uuid = '%q'", time(NULL), uuid.c_str());
+   }
+   
+   ret = doCommit(zSQL, NULL, NULL, 0);
+   if(ret)
+   {
+      logmsg(" writeDevice, doCommit failed \n");
+      logmsg(" writeDevice, zSQL: ", zSQL, "\n");
+   }
+   
+   if(zSQL)
+   {
+      sqlite3_free(zSQL);
+   }
+
+   return ret;
+}
+
+int32_t SIMPLE_DB::deleteDevice(string &uuid)
+{
+   int32_t ret = 0;
+   char *zSQL = NULL;
+
+   if(!mPsqlite3)
+   {
+      logmsg(" deleteDevice, mPsqlite3 is NULL\n");
+      return -1;
+   }
+   
+   zSQL = sqlite3_mprintf("delete from mtpdevices where uuid = '%q'", uuid.c_str());
+   
+   ret = doCommit(zSQL, NULL, NULL, 0);
+   if(ret)
+   {
+      logmsg(" deleteDevice, doCommit failed \n");
+      logmsg(" deleteDevice, zSQL: ", zSQL, "\n");
+   }
+   
+   if(zSQL)
+   {
+      sqlite3_free(zSQL);
+   }
+
+   return ret;;
+}
+
+
+int32_t SIMPLE_DB::queryFileID(string &path, string &uuid, uint32_t *mtpFileId)
+{
+   int ret = 0;
+   char *zSQL = NULL;
+
+   if(!mPsqlite3)
+   {
+      logmsg(" queryFileID, mPsqlite3 is NULL\n");
+      return -1;
+   }
+
+   if(!mtpFileId)
+   {
+      logmsg(" queryFileID, mtpFileId is NULL\n");
+      return -1;
+   }
+
+   zSQL = sqlite3_mprintf("select mtpId from mtpfile where path = '%q' and uuid = '%q'", path.c_str(), uuid.c_str());
+   //printf(" queryFileID, zSQL: %s\n", zSQL);
+
+   ret = doCommit(zSQL, queryDeviceCb, mtpFileId, 0);
+   if(ret)
+   {
+      logmsg(" queryFileID, doCommit failed \n");
+      logmsg(" queryFileID, zSQL: ", zSQL, "\n");
+   }   
+   
+   if(zSQL)
+   {
+      sqlite3_free(zSQL);
+   }
+   
+   return ret;
+}
+
+int32_t SIMPLE_DB::writeFileID(string &path, uint32_t fileId, string &uuid)
+{
+   int32_t ret = 0;
+   char *zSQL = NULL;
+   uint32_t queryFileId = 0;
+
+   ret = queryFileID(path, uuid, &queryFileId);
+
+   //printf(" writeFileID, queryFileId: %d\n", queryFileId);
+   
+   if(!queryFileId)
+   {
+      zSQL = sqlite3_mprintf("insert into mtpfile values ('%q','%d', '%q')", path.c_str(), fileId, uuid.c_str());
+   }
+   //update
+   else
+   {
+      zSQL = sqlite3_mprintf("update mtpfile set mtpId = '%d' where path = '%q' and uuid = '%q'", fileId, path.c_str(), uuid.c_str());
+   }
+   
+   ret = doCommit(zSQL, NULL, NULL, 0);
+   if(ret)
+   {
+      logmsg(" writeFileID, doCommit failed \n");
+      logmsg(" writeFileID, zSQL: ", zSQL, "\n");
+   }
+   
+   if(zSQL)
+   {
+      sqlite3_free(zSQL);
+   }
+
+   return ret;
+}
+
+int32_t SIMPLE_DB::deleteFileID(string &uuid)
+{
+   int ret = 0;
+   char *zSQL = NULL;
+
+   if(!mPsqlite3)
+   {
+      logmsg(" deleteFileID, mPsqlite3 is NULL\n");
+      return -1;
+   }
+
+   zSQL = sqlite3_mprintf("delete from mtpfile where uuid = '%q'", uuid.c_str());
+   
+   ret = doCommit(zSQL, NULL, NULL, 0);
+   if(ret)
+   {
+      logmsg(" deleteFileID, doCommit failed \n");
+      logmsg(" deleteFileID, zSQL: ", zSQL, "\n");
+   }
+   
+   if(zSQL)
+   {
+      sqlite3_free(zSQL);
+   }
+   
+   return ret;
+}
+
+#if 0
+int main()
+{
+    SIMPLE_DB smtp_db = SIMPLE_DB(SMTPFSDBPATH);
+    
+    string str = "111'111";
+    string &uuid = str;
+    string path = "/tmp/mtp1.0/dir/file'1.mp3";
+
+    smtp_db.writeDevice(uuid);
+    smtp_db.writeFileID(path, 1, uuid);
+
+    str = "222'222";
+    path = "/tmp/mtp1.0/dir/file'2.mp3";
+    smtp_db.writeDevice(uuid);
+    smtp_db.writeFileID(path, 2, uuid);
+
+    str = "333'333";
+    path = "/tmp/mtp1.0/dir/file'3.mp3";
+    smtp_db.writeDevice(uuid);
+    smtp_db.writeFileID(path, 3, uuid);
+    
+    str = "444'444";
+    path = "/tmp/mtp1.0/dir/file'4.mp3";
+    smtp_db.writeDevice(uuid);
+    smtp_db.writeFileID(path, 4, uuid);
+
+    return 0;
+}
+#endif
diff --git a/src/simple-mtpfs-db.hpp b/src/simple-mtpfs-db.hpp
new file mode 100755
index 0000000..574be57
--- /dev/null
+++ b/src/simple-mtpfs-db.hpp
@@ -0,0 +1,62 @@
+/******************************************************************************
+ * Project         Harman Car Multimedia System
+ * (c) copyright   2017-2020
+ * Company         Harman Automotive Systems
+ *                 All rights reserved
+ * Secrecy Level   STRICTLY CONFIDENTIAL
+ ******************************************************************************/
+/**
+ * @file           simple-mtpfs-db.hpp
+ * @author         Jing.Deng@harman.com
+ * @brief          the database class for simple-mtpfs
+ */
+
+#ifndef SIMPLE_MTPFS_DB_HPP
+#define SIMPLE_MTPFS_DB_HPP
+
+//header files
+#include <string>
+#include <cstdlib>
+#include <sqlite3.h>
+#include <cstdio>
+#include <sstream>
+#include <cstring>
+#include <unistd.h>
+
+typedef unsigned int uint32_t;
+typedef int int32_t;
+typedef int (*DBQueryCallback)(void*, int, char**, char**);
+
+#define SMTPFSDBPATH "/mnt/media/smtpfs.db"
+
+#define MAX_MTPDEVICE_COUNT (5)
+
+using namespace std;
+
+class SIMPLE_DB
+{
+public:
+   SIMPLE_DB(const string DBName = SMTPFSDBPATH);
+   ~SIMPLE_DB();
+
+   int32_t queryDevice(string &uuid);
+   int32_t writeDevice(string &uuid);
+   int32_t deleteDevice(string &uuid);
+   int32_t getDeviceCount(int32_t *count);
+   int32_t getOldestDevice(const char *uuid);
+   int32_t checkDeviceCount();
+
+   int32_t queryFileID(string &path, string &uuid, uint32_t *mtpFileId);
+   int32_t writeFileID(string &path, uint32_t fileId, string &uuid);
+   int32_t deleteFileID(string &uuid);
+
+private:
+   sqlite3 *mPsqlite3;
+
+private:
+   sqlite3 *doConnect( const string &url);
+   int32_t doCommit(const string &sqlStr, DBQueryCallback cb, void *data, uint32_t retryTime);
+
+};
+
+#endif
diff --git a/src/simple-mtpfs-fuse.cpp b/src/simple-mtpfs-fuse.cpp
old mode 100644
new mode 100755
index c8c28c3..55535b7
--- a/src/simple-mtpfs-fuse.cpp
+++ b/src/simple-mtpfs-fuse.cpp
@@ -29,6 +29,7 @@ extern "C" {
 
 int wrap_getattr(const char *path, struct stat *statbuf)
 {
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", enter\n");
     return SMTPFileSystem::instance()->getattr(path, statbuf);
 }
 
@@ -79,14 +80,22 @@ int wrap_utime(const char *path, struct utimbuf *ubuf)
 
 int wrap_open(const char *path, struct fuse_file_info *file_info)
 {
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", enter\n");
     //return SMTPFileSystem::instance()->open(path, file_info);
     return 0;
 }
 
+int wrap_access(const char *path, int mask)
+{
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", enter\n");
+    return SMTPFileSystem::instance()->access(path, mask);
+}
+
 int wrap_read(const char *path, char *buf, size_t size, off_t offset,
     struct fuse_file_info *file_info)
 {
-    logerr("size is ",size,"offset is ",offset,"\n");
+    //logmsg("size is ",size,"offset is ",offset,"\n");
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", enter\n");
     return SMTPFileSystem::instance()->read(path, buf, size, offset, file_info);
 	
 }
@@ -94,7 +103,8 @@ int wrap_read(const char *path, char *buf, size_t size, off_t offset,
 int wrap_readbuf(const char *path, struct fuse_bufvec **bufp, size_t size, off_t off, struct fuse_file_info *fileinfo)
 {
 
-	logerr("size is ",size,"offset is ",off,"\n");
+   //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", enter\n");
+	//logmsg("size is ",size,"offset is ",off,"\n");
 	int readsize = 0;
 	struct fuse_bufvec* fbuf =(struct fuse_bufvec*)malloc(sizeof(struct fuse_bufvec));
    if(!fbuf)
@@ -119,44 +129,52 @@ int wrap_write(const char *path, const char *buf, size_t size, off_t offset,
 
 int wrap_statfs(const char *path, struct statvfs *stat_info)
 {
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", enter\n");
     return SMTPFileSystem::instance()->statfs(path, stat_info);
 }
 
 int wrap_flush(const char *path, struct fuse_file_info *file_info)
 {
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", enter\n");
     return SMTPFileSystem::instance()->flush(path, file_info);
 }
 
 int wrap_release(const char *path, struct fuse_file_info *file_info)
 {
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", enter\n");
     //return SMTPFileSystem::instance()->release(path, file_info);
 	 return 0;
 }
 
 int wrap_fsync(const char *path, int datasync, struct fuse_file_info *file_info)
 {
+   //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", enter\n");
     return SMTPFileSystem::instance()->fsync(path, datasync, file_info);
 }
 
 int wrap_opendir(const char *path, struct fuse_file_info *file_info)
-{
+{   
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", enter\n");
     return SMTPFileSystem::instance()->opendir(path, file_info);
 }
 
 int wrap_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
     off_t offset, struct fuse_file_info *file_info)
 {
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", enter\n");
     return SMTPFileSystem::instance()->readdir(path, buf, filler,
         offset, file_info);
 }
 
 int wrap_releasedir(const char *path, struct fuse_file_info *file_info)
 {
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", enter\n");
     return SMTPFileSystem::instance()->releasedir(path, file_info);
 }
 
 int wrap_fsyncdir(const char *path, int datasync, struct fuse_file_info *file_info)
 {
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", enter\n");
     return SMTPFileSystem::instance()->fsyncdir(path, datasync, file_info);
 }
 
@@ -237,21 +255,21 @@ SMTPFileSystem::SMTPFileSystem():
     m_fuse_operations.getattr = wrap_getattr;
     m_fuse_operations.readlink = nullptr;
     m_fuse_operations.getdir = nullptr;
-    m_fuse_operations.mknod = wrap_mknod;
-    m_fuse_operations.mkdir = wrap_mkdir;
-    m_fuse_operations.unlink = wrap_unlink;
-    m_fuse_operations.rmdir = wrap_rmdir;
+    m_fuse_operations.mknod = nullptr;//wrap_mknod;
+    m_fuse_operations.mkdir = nullptr;//wrap_mkdir;
+    m_fuse_operations.unlink = nullptr;//wrap_unlink;
+    m_fuse_operations.rmdir = nullptr;//wrap_rmdir;
     m_fuse_operations.symlink = nullptr;
-    m_fuse_operations.rename = wrap_rename;
+    m_fuse_operations.rename = nullptr;//wrap_rename;
     m_fuse_operations.link = nullptr;
-    m_fuse_operations.chmod = wrap_chmod;
-    m_fuse_operations.chown = wrap_chown;
-    m_fuse_operations.truncate = wrap_truncate;
-    m_fuse_operations.utime = wrap_utime;
+    m_fuse_operations.chmod = nullptr;//wrap_chmod;
+    m_fuse_operations.chown = nullptr;//wrap_chown;
+    m_fuse_operations.truncate = nullptr;//wrap_truncate;
+    m_fuse_operations.utime = nullptr;//wrap_utime;
     m_fuse_operations.open = wrap_open;
     m_fuse_operations.read = wrap_read;
 	 m_fuse_operations.read_buf = wrap_readbuf;
-    m_fuse_operations.write = wrap_write;
+    m_fuse_operations.write = nullptr;//wrap_write;
     m_fuse_operations.statfs = wrap_statfs;
     m_fuse_operations.flush = wrap_flush;
     m_fuse_operations.release = wrap_release;
@@ -266,9 +284,9 @@ SMTPFileSystem::SMTPFileSystem():
     m_fuse_operations.fsyncdir = wrap_fsyncdir;
     m_fuse_operations.init = wrap_init;
     m_fuse_operations.destroy = nullptr;
-    m_fuse_operations.access = nullptr;
-    m_fuse_operations.create = wrap_create;
-    m_fuse_operations.ftruncate = wrap_ftruncate;
+    m_fuse_operations.access = wrap_access;
+    m_fuse_operations.create = nullptr;//wrap_create;
+    m_fuse_operations.ftruncate = nullptr;//wrap_ftruncate;
     m_fuse_operations.fgetattr = nullptr;
 }
 
@@ -296,7 +314,7 @@ bool SMTPFileSystem::parseOptions(int argc, char **argv)
     };
 
     if (argc < 2) {
-        logerr("Wrong usage.\n");
+        logmsg("Wrong usage.\n");
         m_options.m_good = false;
         return false;
     }
@@ -319,7 +337,7 @@ bool SMTPFileSystem::parseOptions(int argc, char **argv)
     }
 
     if (!m_options.m_mount_point) {
-        logerr("Mount point missing.\n");
+        logmsg("Mount point missing.\n");
         m_options.m_good = false;
         return false;
     }
@@ -395,12 +413,12 @@ bool SMTPFileSystem::exec()
         return true;
 
     if (!smtpfs_check_dir(m_options.m_mount_point)) {
-        logerr("Can not mount the device to '", m_options.m_mount_point, "'.\n");
+        logmsg("Can not mount the device to '", m_options.m_mount_point, "'.\n");
         return false;
     }
 
     if (!m_tmp_files_pool.createTmpDir()) {
-        logerr("Can not create a temporary directory.\n");
+        logmsg("Can not create a temporary directory.\n");
         return false;
     }
 
@@ -417,9 +435,13 @@ bool SMTPFileSystem::exec()
     if (fuse_main(m_args.argc, m_args.argv, &m_fuse_operations, nullptr) > 0) {
         return false;
     }
+
+    logmsg("m_device.disconnect.\n");
     m_device.disconnect();
+    logmsg("m_device.disconnect ok.\n");
 
     m_tmp_files_pool.removeTmpDir();
+    logmsg("removeTmpDir ok.\n");
 
     return true;
 }
@@ -431,6 +453,8 @@ void* SMTPFileSystem::init(struct fuse_conn_info *conn)
 
 int SMTPFileSystem::getattr(const char *path, struct stat *buf)
 {
+    //logmsg("  fun: ", __FUNCTION__, "  path: ", path, ", enter\n");
+
     memset(buf, 0, sizeof(struct stat));
     struct fuse_context *fc = fuse_get_context();
     buf->st_uid = fc->uid;
@@ -438,12 +462,14 @@ int SMTPFileSystem::getattr(const char *path, struct stat *buf)
     if (path == std::string("/")) {
         buf->st_mode = S_IFDIR | 0775;
         buf->st_nlink = 2;
+        //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", err000 \n");
         return 0;
     } else {
         std::string tmp_path(smtpfs_dirname(path));
         std::string tmp_file(smtpfs_basename(path));
-        const TypeDir *content = m_device.dirFetchContent(tmp_path);
+        const TypeDir *content = m_device.dirFetchContentFromCache(tmp_path);
         if (!content) {
+           logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", err111\n");
             return -ENOENT;
         }
 
@@ -464,10 +490,33 @@ int SMTPFileSystem::getattr(const char *path, struct stat *buf)
             buf->st_ctime = buf->st_mtime;
             buf->st_atime = buf->st_mtime;
         } else {
-            return -ENOENT;
+
+            //logmsg("  fun: ", __FUNCTION__, "  path: ", path, ", err222\n");
+
+            //find the file from smtpfs.db
+            uint32_t fileId = 0;
+            string pathStr = path;
+            m_device.queryFileID(pathStr, m_device.getUUID(), &fileId);
+            if(!fileId)
+            {
+               logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", pathStr: ", pathStr, " , fileId is 0\n");
+               logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", tmp_path: ", tmp_path, " \n");
+               logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", tmp_file: ", tmp_file, " \n");
+               return 0;
+            }
+
+            //got the fileid
+            //logmsg("  fun: ", __FUNCTION__, "  path: ", path, ", fileId: ", fileId, "\n");
+            if(m_device.getFileInfoById(fileId, buf))
+            {
+               logmsg("  fun: ", __FUNCTION__, "  path: ", path, ", fileId: ", fileId, ", err333\n");
+               return -ENOENT;
+            }
         }
     }
-
+   
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", exit\n");
+    
     return 0;
 }
 
@@ -577,7 +626,7 @@ int SMTPFileSystem::utime(const char *path, struct utimbuf *ubuf)
     std::string tmp_basename(smtpfs_basename(std::string(path)));
     std::string tmp_dirname(smtpfs_dirname(std::string(path)));
 
-    const TypeDir *parent = m_device.dirFetchContent(tmp_dirname);
+    const TypeDir *parent = m_device.dirFetchContentFromCache(tmp_dirname);
     if (!parent)
         return -ENOENT;
 
@@ -742,40 +791,196 @@ int SMTPFileSystem::fsync(const char *path, int datasync,
 
 int SMTPFileSystem::opendir(const char *path, struct fuse_file_info *file_info)
 {
-    const TypeDir *content = m_device.dirFetchContent(std::string(path));
-    if (!content)
-        return -ENOENT;
+   //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", path: ", path, ", enter\n");
 
-    return 0;
+   //note: for sunsang s5 or other non-reach device, 
+   //invoked LIBMTP_Get_Files_And_Folders_Count() to get the items totle count takes 22 seconds.
+   // for the 22 seconds, it will block read, so I create a detached pthread to get the count.
+   //Although the  LIBMTP_Get_Files_And_Folders_Count keep taking 22 seconds, but the openuri return 
+   //immediately, if the application invoke the readdir duration the 22 seconds, the readdir return . every 60ms.
+   int ret = m_device.dirFetchCount(std::string(path));
+   //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", exit\n");
+
+   return ret;
 }
 
 int SMTPFileSystem::readdir(const char *path, void *buf, fuse_fill_dir_t filler,
     off_t offset, struct fuse_file_info *file_info)
 {
-    const TypeDir *content = m_device.dirFetchContent(std::string(path));
-    if (!content)
-        return -ENOENT;
-
-    const std::set<TypeDir> dirs = content->dirs();
-    const std::set<TypeFile> files = content->files();
-
-    for (const TypeDir &d : dirs) {
-        struct stat st;
-        memset(&st, 0, sizeof(st));
-        st.st_ino = d.id();
-        st.st_mode = S_IFDIR | 0775;
-        filler(buf, d.name().c_str(), &st, 0);
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ",path: ", path, ",offset: ", offset, ", enter\n");
+    const TypeDir *contentCache = m_device.dirFetchContentFromCache(std::string(path));
+    if (!contentCache)
+    {   
+      logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", content is NULL\n");
+      return -ENOENT;
     }
+    bool fetchedHandleOld = contentCache->getFetchHandleDone();
+    uint32_t oldFetcheOffset = contentCache->getFetchedOffset();
 
-    for (const TypeFile &f : files) {
-        struct stat st;
-        memset(&st, 0, sizeof(st));
-        st.st_ino = f.id();
-        st.st_mode = S_IFREG | 0644;
-        filler(buf, f.name().c_str(), &st, 0);
+    int itemType = 0;
+    const TypeDir *content = m_device.dirFetchContent(std::string(path), &itemType);
+    if (!content)
+    {   
+      logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", content is NULL\n");
+      return -ENOENT;
     }
 
-    return 0;
+    bool fetchedHandleNew = content->getFetchHandleDone();
+    //check if the LIBMTP_Get_Files_And_Folders_Count() had done or not.
+    //if LIBMTP_Get_Files_And_Folders_Count() had not done, return . dir to application.
+    // so the application may get many . dirs, application just need ignore more . dirs
+    if((fetchedHandleOld == false) && (fetchedHandleOld == fetchedHandleNew))
+    {
+      //please do not remove the delay
+      //because simple-mtpfs will always return . dir to application until 
+      //the LIBMTP_Get_Files_And_Folders_Count() return, so it may lead to endless loop or 
+      //make cpu usage upon to high level, so simple-mtpfs itself do a usleep(60000) to reduce
+      //the . dir counts and avoid cpu high usage.       
+      usleep(60000);
+      struct stat tmpst;
+      memset(&tmpst, 0, sizeof(tmpst));
+      tmpst.st_mode = S_IFDIR | 0775;
+
+      filler(buf, ".", &tmpst, offset+1);
+
+      //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", fill .\n");
+      
+      return 0;
+    }
+    //if LIBMTP_Get_Files_And_Folders_Count() had done, 
+    //first reset the offset, then return the read items.
+    else if((fetchedHandleOld == false) && (fetchedHandleOld != fetchedHandleNew))
+    {
+      offset = 0;
+      //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", reset offset to 0\n");
+    }
+    else if((fetchedHandleOld == fetchedHandleNew) && !oldFetcheOffset && content->getFetchedOffset())
+    {
+      offset = 0;
+      //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", reset offset to 0 again\n");
+    }
+    
+    const std::vector<TypeDir> dirs = content->dirs();
+    const std::vector<TypeFile> files = content->files();
+    uint32_t id = 0;
+    
+    if(offset >= content->getItemCount())
+    {
+       //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", reach max\n");
+       return -ENOENT;
+    }
+    //item type is folder 
+    if(dirs.size() && (itemType == MTP_ITEMTYPE_FOLDER))
+    {
+       //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, "\n");
+      TypeDir d = dirs[dirs.size() - 1];
+
+      struct stat st;
+      memset(&st, 0, sizeof(st));
+      st.st_ino = d.id();
+      st.st_mode = S_IFDIR | 0775;
+
+      #if 0
+      if(content->getItemCount() == (dirs.size() + files.size()))
+      {
+         id = 0;
+      }
+      else
+      #endif
+      {
+         id = offset + 1;
+      }
+
+      filler(buf, d.name().c_str(), &st, id);
+      
+      //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", id: ", id, "-",d.name().c_str() ,", is dir\n");
+    }
+    //item type is file
+    else if(files.size() && (itemType == MTP_ITEMTYPE_FILE)) 
+    {
+      TypeFile f = files[files.size() - 1];
+      struct stat st;
+      memset(&st, 0, sizeof(st));
+      st.st_ino = f.id();
+      st.st_mode = S_IFREG | 0644;
+
+      #if 0
+      if(content->getItemCount() == (dirs.size() + files.size()))
+      {
+         id = 0;
+      }
+      else
+      #endif
+      {
+         id = offset + 1;
+      }
+
+      filler(buf, f.name().c_str(), &st, id);
+
+      //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", id: ", id, "-",f.name().c_str() ,", is file\n");
+   }
+   //item type is unknow type,it presents the item had exist
+   else
+   {
+      //for exist item, first fetch the dir by offset
+      if(dirs.size() && (offset < dirs.size()))
+      {
+         TypeDir d = dirs[offset];
+
+         struct stat st;
+         memset(&st, 0, sizeof(st));
+         st.st_ino = d.id();
+         st.st_mode = S_IFDIR | 0775;
+
+         #if 0
+         if((content->getItemCount() == dirs.size()) && (offset == (dirs.size() - 1)))
+         {
+            id = 0;
+         }
+         else
+         #endif
+         {
+            id = offset + 1;
+         }
+
+         filler(buf, d.name().c_str(), &st, id);
+         
+         //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", id: ", id, "-",d.name().c_str(), ", is old dir\n");
+      }
+      //for exist item,  fetch the file by offset
+      else if(files.size() && (offset < (files.size() + dirs.size())))
+      {
+         TypeFile f = files[offset - dirs.size()];
+         struct stat st;
+         memset(&st, 0, sizeof(st));
+         st.st_ino = f.id();
+         st.st_mode = S_IFREG | 0644;
+         
+         #if 0
+         if((content->getItemCount() == (files.size() + dirs.size())) && (offset == (dirs.size() + files.size() - 1)))
+         {
+            id = 0;
+         }
+         else
+         #endif
+         {
+            id = offset + 1;
+         }
+         filler(buf, f.name().c_str(), &st, id);
+
+         //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", id: ", id, "-",f.name().c_str() ,", is old file\n");
+      }
+      //exception, no items
+      else
+      {
+          logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", id: ", id, ", unknown\n");
+      }
+   }
+
+
+   //logerr("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", exit\n");
+
+   return 0;
 }
 
 int SMTPFileSystem::releasedir(const char *path, struct fuse_file_info *file_info)
@@ -798,3 +1003,76 @@ int SMTPFileSystem::ftruncate(const char *path, off_t offset,
     const_cast<TypeTmpFile*>(tmp_file)->setModified();
     return 0;
 }
+
+int SMTPFileSystem::access(const char *path, int mask)
+{
+   logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", path: ", path, "\n");
+
+   if(!path)
+   {
+      logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", path is NULL\n");
+      return -EINVAL;
+   }
+
+   //1st,check if the path is exist or not from cache pool
+   std::string tmp_basename(smtpfs_basename(std::string(path)));
+   std::string tmp_dirname(smtpfs_dirname(std::string(path)));
+   bool isInCache = true;
+
+   logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", basepath: ", tmp_basename, "\n");
+   logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", dirpath: ", tmp_dirname, "\n");
+   
+   const TypeDir *parent = m_device.dirFetchContentFromCache(tmp_dirname);
+   if (!parent)
+   {
+      logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, "dirname: ", tmp_dirname, " is not exist\n");
+      isInCache = false;
+   }
+
+   if(tmp_basename == tmp_dirname)
+   {
+      logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", basename == dirname\n");
+      return 0;
+   }
+
+   if(tmp_basename.empty())
+   {
+      logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", basename is empty\n");
+      return 0;
+   }
+
+   const TypeFile *file = parent->file(tmp_basename);
+   if (!file)
+   {
+      logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, "basename: ", tmp_basename, " is not exist\n");
+      isInCache = false;
+   }
+
+   if(isInCache == false)
+   {
+      uint32_t fileId = 0;
+      string pathStr = path;
+      m_device.queryFileID(pathStr, m_device.getUUID(), &fileId);
+      if(!fileId)
+      {
+         logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, "basename: ", tmp_basename, " is not exist\n");
+         return -ENOENT;
+      }
+   }
+
+   if(mask & W_OK)
+   {
+      logmsg(" access, query W_OK return EINVAL\n");
+      return -EINVAL;
+   }
+
+   if(mask & X_OK)
+   {
+      logmsg(" access, query X_OK return EINVAL\n");
+      return -EINVAL; 
+   }
+
+   logmsg(" access, return ok\n");
+   return 0;
+}
+
diff --git a/src/simple-mtpfs-fuse.h b/src/simple-mtpfs-fuse.h
old mode 100644
new mode 100755
index 70aa944..22847db
--- a/src/simple-mtpfs-fuse.h
+++ b/src/simple-mtpfs-fuse.h
@@ -102,6 +102,7 @@ public:
     int ftruncate(const char *path, off_t offset, struct fuse_file_info *file_info);
     void* init(struct fuse_conn_info *conn);
     int create(const char *path, mode_t mode, fuse_file_info *file_info);
+    int access(const char *path, int mask);
 
 private:
     static bool removeDir(const std::string &dirname);
diff --git a/src/simple-mtpfs-libmtp.cpp b/src/simple-mtpfs-libmtp.cpp
old mode 100644
new mode 100755
index e2071e5..4c21153
--- a/src/simple-mtpfs-libmtp.cpp
+++ b/src/simple-mtpfs-libmtp.cpp
@@ -38,4 +38,17 @@ void LIBMTP_Free_Files_And_Folders(LIBMTP_file_t **files)
     *files = nullptr;
 }
 
+
+void LIBMTP_Free_ObjHandles(ObjectHandles *handles)
+{
+   if(handles)
+   {
+      if(handles->Handler)
+      {
+         free(handles->Handler);
+         handles->n = 0;
+      }
+   }
+}
+
 }
diff --git a/src/simple-mtpfs-libmtp.h b/src/simple-mtpfs-libmtp.h
old mode 100644
new mode 100755
index c8f7525..6a772a0
--- a/src/simple-mtpfs-libmtp.h
+++ b/src/simple-mtpfs-libmtp.h
@@ -22,6 +22,7 @@ extern "C" {
 #  include <libmtp.h>
 
 void LIBMTP_Free_Files_And_Folders(LIBMTP_file_t **files);
+void LIBMTP_Free_ObjHandles(ObjectHandles *handles);
 
 }
 #endif // SMTPFS_LIBMTP_H
diff --git a/src/simple-mtpfs-log.cpp b/src/simple-mtpfs-log.cpp
old mode 100644
new mode 100755
index 5ed948e..ab41c07
--- a/src/simple-mtpfs-log.cpp
+++ b/src/simple-mtpfs-log.cpp
@@ -21,8 +21,6 @@
 #include "simple-mtpfs-log.h"
 
 Logger logmsg;
-Logger logerr("Error");
-Logger logdebug("Debug");
 
 bool Logger::s_verbose;
 std::mutex Logger::s_output_mutex;
diff --git a/src/simple-mtpfs-log.h b/src/simple-mtpfs-log.h
old mode 100644
new mode 100755
index 4adc38e..a903006
--- a/src/simple-mtpfs-log.h
+++ b/src/simple-mtpfs-log.h
@@ -19,36 +19,82 @@
 #define SMTPFS_LOG_H
 
 #include <iostream>
+#include <fstream>
 #include <iomanip>
 #include <sstream>
 #include <mutex>
 
 class  Logger;
 extern Logger logmsg;
-extern Logger logerr;
-extern Logger logdebug;
+
+using namespace std;
 
 class Logger
 {
 public:
-    Logger(const std::string &fixed_message = std::string()):
+    Logger(const string &fixed_message = string()):
         m_fixed_message(fixed_message),
         m_verbose(false)
     {
+        
+    }
+
+    ~Logger()
+    {
+       if(mLog.is_open() == true)
+       {
+           mLog << "close smtpfs.log" << endl;
+           //mLog.flush();
+           mLog.close();
+       }
     }
 
     template <typename t, typename ...p>
     void output(t data, p ...args)
     {
-        if (!s_verbose && !m_verbose)
-            return;
+        if(!m_verbose && !s_verbose)
+        {
+            if(mLog.is_open() == false)
+            {
+                mLog.open("/tmp/smtpfs.log", ios::out|ios::app);
+                mLog << "open smtpfs.log" << endl;
+            }
+        }
+
+        //if (!s_verbose && !m_verbose)
+        //    return;
+        
         criticalEnter();
-        std::cout << timestamp();
-        if (!m_fixed_message.empty())
-            std::cout << ": " << m_fixed_message;
-        std::cout << ": ";
+        if(mLog.is_open() == true)
+        {
+            mLog << timestamp();
+
+            if (!m_fixed_message.empty())
+            {
+                mLog << ": " << m_fixed_message;
+            }
+            mLog << ": ";
+        }
+        else
+        {
+            cout << timestamp();
+
+            if (!m_fixed_message.empty())
+            {
+                cout << ": " << m_fixed_message;
+            }
+            cout << ": ";
+        }
+
         outputHelper(data, args...);
+
+        if(mLog.is_open() == true)
+        {
+            mLog.flush();
+        }
+
         criticalLeave();
+        
     }
 
     template<typename t, typename ...p>
@@ -70,15 +116,24 @@ private:
     template <typename T, typename ...P>
     void outputHelper(T t, P ...p)
     {
-        std::cout << t;
+        if(mLog.is_open() == true)
+        {
+            mLog << t;
+        }
+        else
+        {
+            cout << t;
+        }
+        
         if (sizeof...(p))
             outputHelper(p...);
     }
 
     static bool s_verbose;
-    static std::mutex s_output_mutex;
-    std::string m_fixed_message;
+    static mutex s_output_mutex;
+    string m_fixed_message;
     bool m_verbose;
+    ofstream mLog;
 };
 
 #endif // SMTPFS_LOG_H
diff --git a/src/simple-mtpfs-ls.cpp b/src/simple-mtpfs-ls.cpp
old mode 100644
new mode 100755
index 7384bd6..10e4b4d
--- a/src/simple-mtpfs-ls.cpp
+++ b/src/simple-mtpfs-ls.cpp
@@ -89,7 +89,8 @@ int main(int argc, char **argv)
     }
 
     for (std::string &i : o.positionalOptions()) {
-        const TypeDir *dir = device.dirFetchContent(i);
+        int itemType;
+        const TypeDir *dir = device.dirFetchContent(i, &itemType);
     }
 
     return 0;
diff --git a/src/simple-mtpfs-mtp-device.cpp b/src/simple-mtpfs-mtp-device.cpp
old mode 100644
new mode 100755
index ebeeeeb..c50ec1b
--- a/src/simple-mtpfs-mtp-device.cpp
+++ b/src/simple-mtpfs-mtp-device.cpp
@@ -12,7 +12,7 @@
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
-*   along with this program. If not, see <http://www.gnu.org/licenses/>.
+*   along with this program. If not, see <http://www.gnu.org/licenses,.
 * ***** END LICENSE BLOCK ***** */
 
 #include <config.h>
@@ -36,13 +36,19 @@ extern "C" {
 
 uint32_t MTPDevice::s_root_node = ~0;
 
+static LIBMTP_mtpdevice_t *g_device = NULL;
+static MTPDevice *gMTPDev = NULL;
+
 MTPDevice::MTPDevice():
+    SIMPLE_DB(),
     m_device(nullptr),
     m_capabilities(),
     m_device_mutex(),
     m_root_dir(),
-    m_move_enabled(false)
+    m_move_enabled(false),
+    mUUID("")
 {
+    gMTPDev = this;
     StreamHelper::off();
     LIBMTP_Init();
     StreamHelper::on();
@@ -51,12 +57,13 @@ MTPDevice::MTPDevice():
 MTPDevice::~MTPDevice()
 {
     disconnect();
+    gMTPDev = NULL;
 }
 
 bool MTPDevice::connect(LIBMTP_raw_device_t *dev)
 {
     if (m_device) {
-        logerr("Already connected.\n");
+        logmsg("Already connected.\n");
         return true;
     }
 
@@ -76,6 +83,21 @@ bool MTPDevice::connect(LIBMTP_raw_device_t *dev)
     // Retrieve capabilities.
     m_capabilities = MTPDevice::getCapabilities(*this);
 
+    g_device = m_device;
+
+    char tmpStr[128] = "";
+
+    //printf("vendor_id: %x, product_id: %x\n", dev->device_entry.vendor_id, dev->device_entry.product_id);
+
+    //sprintf(tmpStr, "%x_%x_", dev->device_entry.vendor_id, dev->device_entry.product_id);
+
+    string seriaID = LIBMTP_Get_Serialnumber(m_device);
+
+    //printf("seriaID: %s\n", seriaID.c_str());
+
+    mUUID = tmpStr + seriaID;
+
+    writeDevice(mUUID);
     logmsg("Connected.\n");
     return true;
 }
@@ -83,7 +105,7 @@ bool MTPDevice::connect(LIBMTP_raw_device_t *dev)
 bool MTPDevice::connect_priv(int dev_no, const std::string &dev_file)
 {
     if (m_device) {
-        logerr("Already connected.\n");
+        logmsg("Already connected.\n");
         return true;
     }
 
@@ -99,19 +121,19 @@ bool MTPDevice::connect_priv(int dev_no, const std::string &dev_file)
     if (err != LIBMTP_ERROR_NONE) {
         switch(err) {
         case LIBMTP_ERROR_NO_DEVICE_ATTACHED:
-            logerr("No raw devices found.\n");
+            logmsg("No raw devices found.\n");
             break;
         case LIBMTP_ERROR_CONNECTING:
-            logerr("There has been an error connecting. Exiting.\n");
+            logmsg("There has been an error connecting. Exiting.\n");
             break;
         case LIBMTP_ERROR_MEMORY_ALLOCATION:
-            logerr("Encountered a Memory Allocation Error. Exiting.\n");
+            logmsg("Encountered a Memory Allocation Error. Exiting.\n");
             break;
         case LIBMTP_ERROR_GENERAL:
-            logerr("General error occured. Exiting.\n");
+            logmsg("General error occured. Exiting.\n");
             break;
         case LIBMTP_ERROR_USB_LAYER:
-            logerr("USB Layer error occured. Exiting.\n");
+            logmsg("USB Layer error occured. Exiting.\n");
             break;
         default:
             break;
@@ -131,7 +153,7 @@ bool MTPDevice::connect_priv(int dev_no, const std::string &dev_file)
                     break;
 
         if (dev_no == raw_devices_cnt) {
-            logerr("Can not open such device '", dev_file, "'.\n");
+            logmsg("Can not open such device '", dev_file, "'.\n");
             free(static_cast<void*>(raw_devices));
             return false;
         }
@@ -139,13 +161,21 @@ bool MTPDevice::connect_priv(int dev_no, const std::string &dev_file)
 #endif // !HAVE_LIBUSB1
 
     if (dev_no < 0 || dev_no >= raw_devices_cnt) {
-        logerr("Can not connect to device no. ", dev_no + 1, ".\n");
+        logmsg("Can not connect to device no. ", dev_no + 1, ".\n");
         free(static_cast<void*>(raw_devices));
         return false;
     }
 
     LIBMTP_raw_device_t *raw_device = &raw_devices[dev_no];
 
+    char tmpStr[128] = "";
+
+    //printf("vendor_id: %x, product_id: %x\n", raw_device->device_entry.vendor_id, raw_device->device_entry.product_id);
+
+    sprintf(tmpStr, "%x_%x_", raw_device->device_entry.vendor_id, raw_device->device_entry.product_id);
+
+    //printf("tmpStr: %s\n", tmpStr);
+
     // Do not output LIBMTP debug stuff
     StreamHelper::off();
     m_device = LIBMTP_Open_Raw_Device_Uncached(raw_device);
@@ -164,6 +194,15 @@ bool MTPDevice::connect_priv(int dev_no, const std::string &dev_file)
     m_capabilities = MTPDevice::getCapabilities(*this);
 
     logmsg("Connected.\n");
+    g_device = m_device;
+
+    string seriaID = LIBMTP_Get_Serialnumber(m_device);
+
+    //printf("seriaID: %s\n", LIBMTP_Get_Serialnumber(m_device));
+    
+    mUUID = tmpStr + seriaID;
+
+    writeDevice(mUUID);
     return true;
 }
 
@@ -176,13 +215,13 @@ bool MTPDevice::connect(int dev_no)
 bool MTPDevice::connect(const std::string &dev_file)
 {
     if (m_device) {
-        logerr("Already connected.\n");
+        logmsg("Already connected.\n");
         return true;
     }
 
     LIBMTP_raw_device_t *raw_device = smtpfs_raw_device_new(dev_file);
     if (!raw_device) {
-        logerr("Can not open such device '", dev_file, "'.\n");
+        logmsg("Can not open such device '", dev_file, "'.\n");
         return false;
     }
 
@@ -205,9 +244,18 @@ void MTPDevice::disconnect()
     if (!m_device)
         return;
 
+    logmsg("MTPDevice::disconnect start.\n");
+    
     LIBMTP_Release_Device(m_device);
+
+    logmsg("MTPDevice::disconnect 1111.\n");
     m_device = nullptr;
-    logmsg("Disconnected.\n");
+    logmsg("MTPDevice::disconnect 2222.\n");
+    g_device = m_device;
+    logmsg("MTPDevice::disconnect 33333.\n");
+    mUUID = "";
+    
+    logmsg("Disconnected ok.\n");
 }
 
 uint64_t MTPDevice::storageTotalSize() const
@@ -233,7 +281,7 @@ bool MTPDevice::enumStorages()
     if (LIBMTP_Get_Storage(m_device, LIBMTP_STORAGE_SORTBY_NOTSORTED) < 0) {
         std::cerr << "Could not retrieve device storage.\n";
         std::cerr << "For android phones make sure the screen is unlocked.\n";
-        logerr("Could not retrieve device storage. Exiting.\n");
+        logmsg("Could not retrieve device storage. Exiting.\n");
         LIBMTP_Dump_Errorstack(m_device);
         LIBMTP_Clear_Errorstack(m_device);
         return false;
@@ -242,12 +290,14 @@ bool MTPDevice::enumStorages()
     return true;
 }
 
-const TypeDir *MTPDevice::dirFetchContent(std::string path)
+const TypeDir *MTPDevice::dirFetchContentFromCache(std::string path)
 {
+    //logmsg("  fun: ", __FUNCTION__, ", line: ", __LINE__, ",path: ", path, ", enter\n");
+
     if (!m_root_dir.isFetched()) {
         for (LIBMTP_devicestorage_t *s = m_device->storage; s; s = s->next) {
-            m_root_dir.addDir(TypeDir(s_root_node, 0, s->id,
-                std::string(s->StorageDescription)));
+            m_root_dir.addDir(TypeDir(s_root_node, 0, s->id, std::string(s->StorageDescription)));
+            //logmsg("  fun: ", __FUNCTION__, ", line: ", __LINE__, ",path: ", path, ", setFetched()\n");
             m_root_dir.setFetched();
         }
     }
@@ -256,62 +306,393 @@ const TypeDir *MTPDevice::dirFetchContent(std::string path)
         path = '/' + m_root_dir.dirs().begin()->name() + path;
 
     if (path == "/")
+    {
+       //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, "\n");
         return &m_root_dir;
+    }
 
     std::string member;
     std::istringstream ss(path);
     TypeDir *dir = &m_root_dir;
+
+    //logmsg("  fun: ", __FUNCTION__, ", line: ", __LINE__, ",path: ", path, "\n");
+
     while (std::getline(ss, member, '/')) {
+		
         if (member.empty())
             continue;
 
         const TypeDir *tmp = dir->dir(member);
-        if (!tmp && !dir->isFetched()) {
-            criticalEnter();
-            LIBMTP_file_t *content = LIBMTP_Get_Files_And_Folders(
-                m_device, dir->storageid(), dir->id());
-            criticalLeave();
-            for (LIBMTP_file_t *f = content; f; f = f->next) {
-                if (f->filetype == LIBMTP_FILETYPE_FOLDER)
-                    dir->addDir(TypeDir(f));
-                else
-                    dir->addFile(TypeFile(f));
-            }
-            LIBMTP_Free_Files_And_Folders(&content);
-            dir->setFetched();
-            tmp = dir->dir(member);
-        }
-
         if (!tmp)
+        {
+            logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", not found\n");
             return nullptr;
+        }
+		
         dir = const_cast<TypeDir*>(tmp);
     }
 
-    if (dir->isFetched())
-        return dir;
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", dir->name: ", dir->name(), ", exit\n");
+    return dir;
+}
 
-    criticalEnter();
-    dir->setFetched();
-    LIBMTP_file_t *content = LIBMTP_Get_Files_And_Folders(
-        m_device, dir->storageid(), dir->id());
-    criticalLeave();
-    for (LIBMTP_file_t *f = content; f; f = f->next) {
-        if (f->filetype == LIBMTP_FILETYPE_FOLDER)
-            dir->addDir(TypeDir(f));
-        else
-            dir->addFile(TypeFile(f));
+void* dirFetchCountThreadRUn(void *arg)
+{
+   TypeDir *dir = (TypeDir *)arg;
+   
+   if(dir == NULL)
+   {
+      logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", dir is NULL\n");
+      return NULL;
+   }
+
+   if(g_device == NULL)
+   {
+      logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", g_device is NULL\n");
+      return NULL;
+   }
+
+   do
+   {
+      uint32_t i = dir->getFetchedOffset();
+      ObjectHandles *handles = dir->getObjHandles();
+      if(!handles)
+      {
+         logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", handles is NULL\n");
+         return NULL;
+      }
+
+      //get handles by libmtp
+      //if never read the items by libmtp under this path, go to get the count 
+      //cover conditions following
+      //1 the count changed 
+      //2 the count get failed previous
+      //3 the count is 0, but the real count is not 0.
+      if(!i)
+      {
+         //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", LIBMTP_Get_Files_And_Folders_Count: ", dir->name(), "\n");
+         
+         dir->setFetchHandleDone(false);
+         int retryCnt = 10;
+
+         int32_t ret = 0;
+         do 
+         {
+            //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", 1111.\n");
+            //criticalEnter1();
+            if(!g_device) break;
+            if(!gMTPDev) break;
+
+            //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", 2222.\n");
+            gMTPDev->criticalEnter1();
+            ret = LIBMTP_Get_Files_And_Folders_Count(g_device,
+                     dir->storageid(),
+                     dir->id(),
+                     handles);
+            gMTPDev->criticalLeave1();
+
+            //criticalLeave1();
+            //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", 3333.\n");
+
+            //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", LIBMTP_Get_Files_And_Folders_Count done\n");
+
+            if(ret < 0)
+            {
+               logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", dir: ", dir->name(), ", LIBMTP_Get_Files_And_Folders_Count failed,go retry.\n");
+               usleep(50000);
+            }
+            else
+            {
+               break;
+            }
+         }while(--retryCnt);
+
+         if(ret >= 0)
+         {
+            dir->setFetchHandleDone(true);
+            dir->setItemCount(handles->n);
+            //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", count: ",handles->n, "\n");
+            //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", done ok.\n");
+         }
+      }
+
+   }while(0);
+
+   //logmsg("exit dirFetchCountThreadRUn \n");
+
+   return NULL;
+}
+
+int MTPDevice::dirFetchCount(std::string path)
+{
+   //logmsg("  fun: ", __FUNCTION__, ", line: ", __LINE__, ",path: ", path, ", enter\n");
+
+   TypeDir *dir = (TypeDir *)dirFetchContentFromCache(path);
+   if (!dir || dir->isFetched())
+   {
+      //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", dir: ", dir, "isFetched: ", dir->isFetched(), "\n");
+      //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", feteched or NULL\n");
+      return 0;
+   }
+
+   if(dir->getFetchHandleDone() || dir->getItemCount()) 
+   {
+      //logmsg("  fun: ", __FUNCTION__, ", line: ", __LINE__, ",path: ", path, ", count: ", dir->getItemCount(), ", had get count,return\n");
+      return 0;
+   }
+
+   //detached thread
+   pthread_attr_t attr;
+   int ret = 0;
+   pthread_t pid; 
+
+   pthread_attr_init(&attr);
+   ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+   if(ret)
+   {
+      return -1;
+   }
+
+   ret = pthread_create(&pid, &attr, &dirFetchCountThreadRUn, (void *)dir);
+   if(ret)
+   {
+      return -1;
+   }
+
+   pthread_attr_destroy(&attr);
+
+   //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", exit\n");
+   return 0;
+}
+
+bool MTPDevice::isMediaType(const char *fileName)
+{
+   const char* extArray[] = 
+   {
+      ".mp3",
+      ".wma",
+      ".aac",
+      ".wav",
+      ".wave",
+      ".flac",
+      ".oga",
+      ".ogg",
+      ".mka",
+      ".m4a",
+      ".m4b",
+      ".avi",
+      ".asf",
+      ".wmv",
+      ".mkv",
+      ".mebm",
+      ".mpg",
+      ".dat",
+      ".mpeg",
+      ".evo",
+      ".vob",
+      ".vdr",
+      ".mod",
+      ".ts",
+      ".trp",
+      ".mts",
+      ".m2t",
+      ".m2ts",
+      ".tod",
+      ".mp4",
+      ".m4v",
+      ".3gp",
+      ".mov",
+      ".qt",
+      ".bmp",
+      ".jpg",
+      ".jpeg",
+      ".gif",
+      ".tif",
+      ".png",
+      ".pls",
+      ".m3u",
+      ".wpl",
+      ".m4b",
+   };
+
+   if(fileName == NULL)
+   {
+      logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", fileName is NULL\n");
+      return false;
+   }
+
+   string fileStr = fileName;
+   int i = 0;
+   int totle = sizeof(extArray)/sizeof(char *);
+   string extStr = "";
+   for(i = 0; i < totle; i++)
+   {
+      extStr = extArray[i];
+      if(endWith(fileStr, extStr))
+      {
+         return true;
+      }
+   }
+
+   return false;
+}
+
+const TypeDir *MTPDevice::dirFetchContent(std::string path, int *itemType)
+{
+    //logmsg("  fun: ", __FUNCTION__, ", line: ", __LINE__, ",path: ", path, ", enter\n");
+
+    if(itemType == NULL)
+    {
+       logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", itemType is NULL\n");
+       return nullptr;
     }
-    LIBMTP_Free_Files_And_Folders(&content);
+
+   TypeDir *dir = (TypeDir *)dirFetchContentFromCache(path);
+
+   //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", isFetched: ", dir->isFetched(), "\n");
+
+   //if(dir && dir->getItemCount())
+   if (!dir || dir->isFetched())
+   {
+      itemType = MTP_ITEMTYPE_UNKOWN;
+      //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", feteched or NULL\n");
+      return dir;
+   }
+
+   //criticalEnter();
+
+	uint32_t i = dir->getFetchedOffset();
+	ObjectHandles *handles = dir->getObjHandles();
+	if(!handles)
+	{
+		logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", handles is NULL\n");
+		return nullptr;
+	}
+
+   #if 0
+    //get handles by libmtp
+    if(!i)
+    {
+		logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", LIBMTP_Get_Files_And_Folders_Count\n");
+
+      int32_t ret = 0;
+		ret = LIBMTP_Get_Files_And_Folders_Count(m_device,
+					dir->storageid(),
+					dir->id(),
+					handles);
+
+      logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", LIBMTP_Get_Files_And_Folders_Count done\n");
+
+		if(ret < 0)
+		{
+			logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", LIBMTP_Get_Files_And_Folders_Count failed.\n");
+			return nullptr;
+		}
+
+      dir->setItemCount(handles->n);
+    }
+    #else
+    if(dir->getFetchHandleDone() == false)
+    {
+       //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", getFetchHandleDone return\n");
+       return dir;
+    }
+    #endif
+
+	//get files by libmtp
+	
+   //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", i:", i,",\n");
+   uint32_t tmpn = 1 + i;
+	
+   //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", handles->n:", handles->n,",\n");
+
+	if(tmpn >= handles->n)
+	{
+		tmpn = handles->n;
+	}
+
+	for( ; i < tmpn; i++)
+   {
+       criticalEnter1();
+       LIBMTP_file_t *f = LIBMTP_Get_Files_And_Folders_ByHandle(m_device, handles->Handler[i]);
+       criticalLeave1();
+       if(f == NULL)
+       {
+          logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", i: ", i, ",\n");
+          logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", handles->Handler:", handles->Handler[i],",\n");
+          logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", f is null\n");
+          continue;
+       }
+
+	    dir->setFetchedOffset(i+1);
+
+       //logmsg(i, "_filename:  ", f->filename, ", type: ", f->filetype, "\n");
+
+       if (f->filetype == LIBMTP_FILETYPE_FOLDER)
+       {
+            dir->addDir(TypeDir(f));
+            *itemType = MTP_ITEMTYPE_FOLDER;
+       }
+      else
+      {
+         dir->addFile(TypeFile(f));
+         *itemType = MTP_ITEMTYPE_FILE;
+
+         //save into db 
+         if(isMediaType(f->filename))
+         {
+            std::string filePath = "";
+            //printf("writeFileID, path: %s, dirname: %s\n", path.c_str(), dir->name().c_str());
+
+            if(path != "/")
+            {
+               filePath = path + "/" + f->filename;
+            }
+            else
+            {
+               filePath = path + f->filename;
+            }
+
+            //printf("writeFileID, filePath: %s\n", filePath.c_str());
+            
+            writeFileID(filePath, f->item_id, mUUID);
+         }
+      }
+
+       LIBMTP_Free_Files_And_Folders(&f); 
+   }
+
+   //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ",setFetchedOffset: ", i, ", exit\n");
+
+   #if 0
+   if(*itemType == MTP_ITEMTYPE_UNKOWN)
+   {
+      dir->setFetchedOffset(i);
+   }
+   #endif
+
+	if(dir->getFetchedOffset() == handles->n)
+	{
+		//logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", LIBMTP_Free_ObjHandles\n");
+    	LIBMTP_Free_ObjHandles(handles);
+      //logmsg("  fun: ", __FUNCTION__, ", line: ", __LINE__, ",path: ", path, ", setFetched()\n");
+		dir->setFetched();
+	}
+	
+	 //criticalLeave();
+
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", exit\n");
     return dir;
 }
 
+
 int MTPDevice::dirCreateNew(const std::string &path)
 {
     const std::string tmp_basename(smtpfs_basename(path));
     const std::string tmp_dirname(smtpfs_dirname(path));
-    const TypeDir *dir_parent = dirFetchContent(tmp_dirname);
+    const TypeDir *dir_parent = dirFetchContentFromCache(tmp_dirname);
     if (!dir_parent || dir_parent->id() == 0) {
-        logerr("Can not remove directory '", path, "'.\n");
+        logmsg("Can not remove directory '", path, "'.\n");
         return -EINVAL;
     }
     char *c_name = strdup(tmp_basename.c_str());
@@ -320,7 +701,7 @@ int MTPDevice::dirCreateNew(const std::string &path)
         dir_parent->id(), dir_parent->storageid());
     criticalLeave();
     if (new_id == 0) {
-        logerr("Could not create directory '", path, "'.\n");
+        logmsg("Could not create directory '", path, "'.\n");
         LIBMTP_Dump_Errorstack(m_device);
         LIBMTP_Clear_Errorstack(m_device);
     } else {
@@ -336,10 +717,10 @@ int MTPDevice::dirRemove(const std::string &path)
 {
     const std::string tmp_basename(smtpfs_basename(path));
     const std::string tmp_dirname(smtpfs_dirname(path));
-    const TypeDir *dir_parent = dirFetchContent(tmp_dirname);
+    const TypeDir *dir_parent = dirFetchContentFromCache(tmp_dirname);
     const TypeDir *dir_to_remove = dir_parent ? dir_parent->dir(tmp_basename) : nullptr;
     if (!dir_parent || !dir_to_remove || dir_parent->id() == 0) {
-        logerr("No such directory '", path, "' to remove.\n");
+        logmsg("No such directory '", path, "' to remove.\n");
         return -ENOENT;
     }
     if (!dir_to_remove->isEmpty())
@@ -348,7 +729,7 @@ int MTPDevice::dirRemove(const std::string &path)
     int rval = LIBMTP_Delete_Object(m_device, dir_to_remove->id());
     criticalLeave();
     if (rval != 0){
-        logerr("Could not remove the directory '", path, "'.\n");
+        logmsg("Could not remove the directory '", path, "'.\n");
         LIBMTP_Dump_Errorstack(m_device);
         LIBMTP_Clear_Errorstack(m_device);
         return -EINVAL;
@@ -364,15 +745,15 @@ int MTPDevice::dirRename(const std::string &oldpath, const std::string &newpath)
     const std::string tmp_old_dirname(smtpfs_dirname(oldpath));
     const std::string tmp_new_basename(smtpfs_basename(newpath));
     const std::string tmp_new_dirname(smtpfs_dirname(newpath));
-    const TypeDir *dir_parent = dirFetchContent(tmp_old_dirname);
+    const TypeDir *dir_parent = dirFetchContentFromCache(tmp_old_dirname);
     const TypeDir *dir_to_rename = dir_parent ? dir_parent->dir(tmp_old_basename) : nullptr;
     if (!dir_parent || !dir_to_rename || dir_parent->id() == 0) {
-        logerr("Can not rename '", tmp_old_basename, "' to '",
+        logmsg("Can not rename '", tmp_old_basename, "' to '",
             tmp_new_basename, "'.\n");
         return -EINVAL;
     }
     if (tmp_old_dirname != tmp_new_dirname) {
-        logerr("Can not move '", oldpath, "' to '", newpath, "'.\n");
+        logmsg("Can not move '", oldpath, "' to '", newpath, "'.\n");
         return -EINVAL;
     }
 
@@ -383,7 +764,7 @@ int MTPDevice::dirRename(const std::string &oldpath, const std::string &newpath)
     free(static_cast<void*>(folder->name));
     free(static_cast<void*>(folder));
     if (ret != 0) {
-        logerr("Could not rename '", oldpath, "' to '",  tmp_new_basename, "'.\n");
+        logmsg("Could not rename '", oldpath, "' to '",  tmp_new_basename, "'.\n");
         LIBMTP_Dump_Errorstack(m_device);
         LIBMTP_Clear_Errorstack(m_device);
         return -EINVAL;
@@ -402,7 +783,7 @@ int MTPDevice::rename(const std::string &oldpath, const std::string &newpath)
     if (tmp_old_dirname != tmp_new_dirname)
         return -EINVAL;
 
-    const TypeDir *dir_parent = dirFetchContent(tmp_old_dirname);
+    const TypeDir *dir_parent = dirFetchContentFromCache(tmp_old_dirname);
     if (!dir_parent || dir_parent->id() == 0)
         return -EINVAL;
     const TypeDir *dir_to_rename = dir_parent->dir(tmp_old_basename);
@@ -415,13 +796,13 @@ int MTPDevice::rename(const std::string &oldpath, const std::string &newpath)
     const std::string tmp_old_dirname(smtpfs_dirname(oldpath));
     const std::string tmp_new_basename(smtpfs_basename(newpath));
     const std::string tmp_new_dirname(smtpfs_dirname(newpath));
-    const TypeDir *dir_old_parent = dirFetchContent(tmp_old_dirname);
-    const TypeDir *dir_new_parent = dirFetchContent(tmp_new_dirname);
+    const TypeDir *dir_old_parent = dirFetchContentFromCache(tmp_old_dirname);
+    const TypeDir *dir_new_parent = dirFetchContentFromCache(tmp_new_dirname);
     const TypeDir *dir_to_rename = dir_old_parent ? dir_old_parent->dir(tmp_old_basename) : nullptr;
     const TypeFile *file_to_rename = dir_old_parent ? dir_old_parent->file(tmp_old_basename) : nullptr;
 
-    logdebug("dir_to_rename:    ", dir_to_rename, "\n");
-    logdebug("file_to_rename:   ", file_to_rename, "\n");
+    logmsg("dir_to_rename:    ", dir_to_rename, "\n");
+    logmsg("file_to_rename:   ", file_to_rename, "\n");
 
     if (!dir_old_parent || !dir_new_parent || dir_old_parent->id() == 0)
         return -EINVAL;
@@ -430,11 +811,11 @@ int MTPDevice::rename(const std::string &oldpath, const std::string &newpath)
         static_cast<const TypeBasic*>(dir_to_rename) :
         static_cast<const TypeBasic*>(file_to_rename);
 
-    logdebug("object_to_rename: ", object_to_rename, "\n");
-    logdebug("object_to_rename->id(): ", object_to_rename->id(), "\n");
+    logmsg("object_to_rename: ", object_to_rename, "\n");
+    logmsg("object_to_rename->id(): ", object_to_rename->id(), "\n");
 
     if (!object_to_rename) {
-        logerr("No such file or directory to rename/move!\n");
+        logmsg("No such file or directory to rename/move!\n");
         return -ENOENT;
     }
 
@@ -444,7 +825,7 @@ int MTPDevice::rename(const std::string &oldpath, const std::string &newpath)
             LIBMTP_PROPERTY_ParentObject, dir_new_parent->id());
         criticalLeave();
         if (rval != 0) {
-            logerr("Could not move '", oldpath, "' to '", newpath, "'.\n");
+            logmsg("Could not move '", oldpath, "' to '", newpath, "'.\n");
             LIBMTP_Dump_Errorstack(m_device);
             LIBMTP_Clear_Errorstack(m_device);
             return -EINVAL;
@@ -457,7 +838,7 @@ int MTPDevice::rename(const std::string &oldpath, const std::string &newpath)
             LIBMTP_PROPERTY_Name, tmp_new_basename.c_str());
         criticalLeave();
         if (rval != 0) {
-            logerr("Could not rename '", oldpath, "' to '", newpath, "'.\n");
+            logmsg("Could not rename '", oldpath, "' to '", newpath, "'.\n");
             LIBMTP_Dump_Errorstack(m_device);
             LIBMTP_Clear_Errorstack(m_device);
             return -EINVAL;
@@ -470,37 +851,67 @@ int MTPDevice::rename(const std::string &oldpath, const std::string &newpath)
 
 int MTPDevice::filesplitPull(const std::string &src,const std::string &dst,uint32_t size, uint32_t offset,unsigned char* buf)
 {
+   bool isInCache = true;
+   uint32_t fileId = 0;
+   int rval = 0;
 	const std::string src_basename(smtpfs_basename(src));
 	const std::string src_dirname(smtpfs_dirname(src));
-	const TypeDir *dir_parent = dirFetchContent(src_dirname);
+	const TypeDir *dir_parent = dirFetchContentFromCache(src_dirname);
 	const TypeFile *file_to_fetch = dir_parent ? dir_parent->file(src_basename) : nullptr;
 	if (!dir_parent) {
-		logerr("Can not fetch '", src, "'.\n");
-		return -EINVAL;
+		logmsg("filesplitPull, dir_parent Can not fetch '", src, "'.\n");
+		isInCache = false;
 	}
+
 	if (!file_to_fetch) {
-		logerr("No such file '", src, "'.\n");
-		return -ENOENT;
+		logmsg("filesplitPull, file_to_fetch No such file '", src, "'.\n");
+		isInCache = false;
 	}
-	uint32_t readlen = 0;
-	unsigned char* tmpbuf = NULL;
-	int rval = LIBMTP_GetPartialObject(m_device,file_to_fetch->id(),offset,size,&tmpbuf,&readlen);
-	memcpy(buf,tmpbuf,readlen);
+
+   uint32_t readlen = 0;
+   unsigned char* tmpbuf = NULL;
+   
+   if(isInCache == true)
+   {
+      fileId = file_to_fetch->id();
+   }
+   else
+   {
+      string path = src.c_str();
+      queryFileID(path, getUUID(), &fileId);
+      if(!fileId)
+      {
+         logmsg("queryFileID No such file '", src, "'.\n");
+         return -EINVAL;
+      }
+   }
+
+   //logmsg(" read file: ", src, "\n");
+
+   //logmsg(" enter LIBMTP_GetPartialObject, fileId: ", fileId, "\n");
+   //criticalEnter1();
+   rval = LIBMTP_GetPartialObject(m_device,fileId,offset,size,&tmpbuf,&readlen);
+   //criticalLeave1();
+   //logmsg(" exit LIBMTP_GetPartialObject, fileId: ", fileId, "\n");
+
+   //logmsg("LIBMTP_GetPartialObject ", ",rval: ", rval, ",readlen: ", readlen, "\n");
 	if(tmpbuf)
 	{
+      memcpy(buf,tmpbuf,readlen);
+      
 		free(tmpbuf);
 		tmpbuf = NULL;
 	}
 
 	//criticalLeave();
 	if (rval != 0) {
-		logerr("Could not fetch file '", src, "'.\n");
+		logmsg("Could not fetch file '", src, "'.failed\n");
 
 		LIBMTP_Dump_Errorstack(m_device);
 		LIBMTP_Clear_Errorstack(m_device);
-		return -ENOENT;
+		return -EAGAIN;
 	}
-	logmsg("File fetched '", src, "'.\n");
+	//logmsg("File fetched '", src, "'. ok\n");
 	return readlen;
 
 }
@@ -509,14 +920,14 @@ int MTPDevice::filePull(const std::string &src, const std::string &dst)
 {
     const std::string src_basename(smtpfs_basename(src));
     const std::string src_dirname(smtpfs_dirname(src));
-    const TypeDir *dir_parent = dirFetchContent(src_dirname);
+    const TypeDir *dir_parent = dirFetchContentFromCache(src_dirname);
     const TypeFile *file_to_fetch = dir_parent ? dir_parent->file(src_basename) : nullptr;
     if (!dir_parent) {
-        logerr("Can not fetch '", src, "'.\n");
+        logmsg("filePull, Can not fetch '", src, "'.\n");
         return -EINVAL;
     }
     if (!file_to_fetch) {
-        logerr("No such file '", src, "'.\n");
+        logmsg("filePull, No such file '", src, "'.\n");
         return -ENOENT;
     }
     if (file_to_fetch->size() == 0) {
@@ -529,7 +940,7 @@ int MTPDevice::filePull(const std::string &src, const std::string &dst)
             dst.c_str(), nullptr, nullptr);
         criticalLeave();
         if (rval != 0) {
-            logerr("Could not fetch file '", src, "'.\n");
+            logmsg("Could not fetch file '", src, "'.\n");
             LIBMTP_Dump_Errorstack(m_device);
             LIBMTP_Clear_Errorstack(m_device);
             return -ENOENT;
@@ -543,14 +954,14 @@ int MTPDevice::filePush(const std::string &src, const std::string &dst)
 {
     const std::string dst_basename(smtpfs_basename(dst));
     const std::string dst_dirname(smtpfs_dirname(dst));
-    const TypeDir *dir_parent = dirFetchContent(dst_dirname);
+    const TypeDir *dir_parent = dirFetchContentFromCache(dst_dirname);
     const TypeFile *file_to_remove = dir_parent ? dir_parent->file(dst_basename) : nullptr;
     if (dir_parent && file_to_remove) {
         criticalEnter();
         int rval = LIBMTP_Delete_Object(m_device, file_to_remove->id());
         criticalLeave();
         if (rval != 0) {
-            logerr("Can not upload '", src, "' to '", dst, "'.\n");
+            logmsg("Can not upload '", src, "' to '", dst, "'.\n");
             return -EINVAL;
         }
     }
@@ -566,7 +977,7 @@ int MTPDevice::filePush(const std::string &src, const std::string &dst)
     int rval = LIBMTP_Send_File_From_File(m_device, src.c_str(), f, nullptr, nullptr);
     criticalLeave();
     if (rval != 0) {
-        logerr("Could not upload file '", src, "'.\n");
+        logmsg("Could not upload file '", src, "'.\n");
         LIBMTP_Dump_Errorstack(m_device);
         LIBMTP_Clear_Errorstack(m_device);
         rval = -EINVAL;
@@ -591,17 +1002,17 @@ int MTPDevice::fileRemove(const std::string &path)
 {
     const std::string tmp_basename(smtpfs_basename(path));
     const std::string tmp_dirname(smtpfs_dirname(path));
-    const TypeDir *dir_parent = dirFetchContent(tmp_dirname);
+    const TypeDir *dir_parent = dirFetchContentFromCache(tmp_dirname);
     const TypeFile *file_to_remove = dir_parent ? dir_parent->file(tmp_basename) : nullptr;
     if (!dir_parent || !file_to_remove) {
-        logerr("No such file '", path, "' to remove.\n");
+        logmsg("No such file '", path, "' to remove.\n");
         return -ENOENT;
     }
     criticalEnter();
     int rval = LIBMTP_Delete_Object(m_device, file_to_remove->id());
     criticalLeave();
     if (rval != 0) {
-        logerr("Could not remove the directory '", path, "'.\n");
+        logmsg("Could not remove the directory '", path, "'.\n");
         return -EINVAL;
     }
     const_cast<TypeDir*>(dir_parent)->removeFile(*file_to_remove);
@@ -615,10 +1026,10 @@ int MTPDevice::fileRename(const std::string &oldpath, const std::string &newpath
     const std::string tmp_old_dirname(smtpfs_dirname(oldpath));
     const std::string tmp_new_basename(smtpfs_basename(newpath));
     const std::string tmp_new_dirname(smtpfs_dirname(newpath));
-    const TypeDir *dir_parent = dirFetchContent(tmp_old_dirname);
+    const TypeDir *dir_parent = dirFetchContentFromCache(tmp_old_dirname);
     const TypeFile *file_to_rename = dir_parent ? dir_parent->file(tmp_old_basename) : nullptr;
     if (!dir_parent || !file_to_rename || tmp_old_dirname != tmp_new_dirname) {
-        logerr("Can not rename '", oldpath, "' to '", tmp_new_basename, "'.\n");
+        logmsg("Can not rename '", oldpath, "' to '", tmp_new_basename, "'.\n");
         return -EINVAL;
     }
 
@@ -629,7 +1040,7 @@ int MTPDevice::fileRename(const std::string &oldpath, const std::string &newpath
     free(static_cast<void*>(file->filename));
     free(static_cast<void*>(file));
     if (rval > 0) {
-        logerr("Could not rename '", oldpath, "' to '", newpath, "'.\n");
+        logmsg("Could not rename '", oldpath, "' to '", newpath, "'.\n");
         LIBMTP_Dump_Errorstack(m_device);
         LIBMTP_Clear_Errorstack(m_device);
         return -EINVAL;
@@ -704,6 +1115,8 @@ bool MTPDevice::listDevices(bool verbose, const std::string &dev_file)
         sprintf(bus_num_str, "%03d", raw_devices[i].bus_location);
         sprintf(dev_num_str, "%03d", raw_devices[i].devnum);
 
+        //printf("vid: %x, pid: %x\n", raw_devices[i].device_entry.vendor_id, raw_devices[i].device_entry.product_id);
+
         std::cout << i + 1 << ": "
             << (raw_devices[i].device_entry.vendor ? raw_devices[i].device_entry.vendor : "Unknown vendor ")
             << (raw_devices[i].device_entry.product ? raw_devices[i].device_entry.product : "Unknown product")
@@ -727,3 +1140,35 @@ bool MTPDevice::listDevices(bool verbose, const std::string &dev_file)
 
     return true;
 }
+
+int32_t MTPDevice::getFileInfoById(uint32_t id, struct stat *st)
+{
+   if(st == NULL)
+   {
+      logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", st is NULL\n");
+      return -1;
+   }
+
+   criticalEnter1();
+   LIBMTP_file_t *file = LIBMTP_Get_Filemetadata(m_device, id);
+   criticalLeave1();
+   if(file == NULL)
+   {
+      logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", file is NULL\n");
+      return -1;
+   }
+
+   //fill st with file
+   st->st_ino = id;
+   st->st_size = file->filesize;
+   st->st_blocks = (file->filesize / 512) + (file->filesize % 512 > 0 ? 1 : 0);
+   st->st_nlink = 1;
+   st->st_mode = S_IFREG | 0644;
+   st->st_mtime = file->modificationdate;
+   st->st_ctime = st->st_mtime;
+   st->st_atime = st->st_mtime;
+
+   LIBMTP_Free_Files_And_Folders(&file);
+
+    return 0;
+ }
\ No newline at end of file
diff --git a/src/simple-mtpfs-mtp-device.h b/src/simple-mtpfs-mtp-device.h
old mode 100644
new mode 100755
index bc5e665..d5beb1c
--- a/src/simple-mtpfs-mtp-device.h
+++ b/src/simple-mtpfs-mtp-device.h
@@ -24,12 +24,13 @@
 #include <string>
 #include <vector>
 extern "C" {
-#  include <libmtp.h>
+#include <libmtp.h>
 }
 #include "simple-mtpfs-type-dir.h"
 #include "simple-mtpfs-type-file.h"
+#include "simple-mtpfs-db.hpp"
 
-class MTPDevice
+class MTPDevice : public SIMPLE_DB
 {
 public:
     class Capabilities
@@ -74,7 +75,14 @@ public:
     int dirCreateNew(const std::string &path);
     int dirRemove(const std::string &path);
     int dirRename(const std::string &oldpath, const std::string &newpath);
-    const TypeDir *dirFetchContent(std::string path);
+    const TypeDir *dirFetchContentFromCache(std::string path);
+    
+    //the item type: 0 unknown, 1:folder, 2:file
+    #define MTP_ITEMTYPE_UNKOWN (0)
+    #define MTP_ITEMTYPE_FOLDER (1)
+    #define MTP_ITEMTYPE_FILE (2)
+    const TypeDir *dirFetchContent(std::string path, int *itemType);
+    int dirFetchCount(std::string path);
 
     int rename(const std::string &oldpath, const std::string &newpath);
 
@@ -86,10 +94,21 @@ public:
     Capabilities getCapabilities() const;
 
     static bool listDevices(bool verbose, const std::string &dev_file);
+    string& getUUID(){return mUUID;}
+    int32_t getFileInfoById(uint32_t id, struct stat *st);
+    bool isMediaType(const char *fileName);
+    void criticalEnter1() { m_device_mutex.lock(); }
+    void criticalLeave1() { m_device_mutex.unlock(); }
 
 private:
+
+#if 0
     void criticalEnter() { m_device_mutex.lock(); }
     void criticalLeave() { m_device_mutex.unlock(); }
+#else
+    void criticalEnter() {  }
+    void criticalLeave() {  }
+#endif
 
     bool enumStorages();
 
@@ -100,9 +119,10 @@ private:
     LIBMTP_mtpdevice_t *m_device;
     Capabilities m_capabilities;
     std::mutex m_device_mutex;
-    TypeDir m_root_dir;
+    TypeDir  m_root_dir;
     bool m_move_enabled;
     static uint32_t s_root_node;
+    string mUUID;
 };
 
 #endif // SMTPFS_MTP_DEVICE_H
diff --git a/src/simple-mtpfs-type-basic.h b/src/simple-mtpfs-type-basic.h
old mode 100644
new mode 100755
index e21378d..b6b1b31
--- a/src/simple-mtpfs-type-basic.h
+++ b/src/simple-mtpfs-type-basic.h
@@ -28,23 +28,41 @@ public:
         m_id(0),
         m_parent_id(0),
         m_storage_id(0),
-        m_name()
-    {}
+        m_name(),
+        fetched_offset(0),
+        item_n(0),
+        fetched_handle_done(false)
+    {
+       handles.n = 0;
+       handles.Handler = NULL;
+    }
 
     TypeBasic(uint32_t id, uint32_t parent_id, uint32_t storage_id,
         const std::string &name):
         m_id(id),
         m_parent_id(parent_id),
         m_storage_id(storage_id),
-        m_name(name)
-    {}
+        m_name(name),
+        fetched_offset(0),
+        item_n(0),
+        fetched_handle_done(false)
+    {
+       handles.n = 0;
+       handles.Handler = NULL;
+    }
 
     TypeBasic(const TypeBasic &copy):
         m_id(copy.m_id),
         m_parent_id(copy.m_parent_id),
         m_storage_id(copy.m_storage_id),
-        m_name(copy.m_name)
-    {}
+        m_name(copy.m_name),
+        fetched_offset(0),
+        item_n(0),
+        fetched_handle_done(false)
+    {
+       handles.n = 0;
+       handles.Handler = NULL;
+    }
 
     uint32_t id() const { return m_id; }
     uint32_t parentid() const { return m_parent_id; }
@@ -62,6 +80,10 @@ public:
         m_parent_id = rhs.m_parent_id;
         m_storage_id = rhs.m_storage_id;
         m_name = rhs.m_name;
+        fetched_offset = 0;
+        handles.n = 0;
+        handles.Handler = NULL;
+        fetched_handle_done = false;
         return *this;
     }
 
@@ -70,11 +92,24 @@ public:
     bool operator <(const std::string &rhs) const { return m_name < rhs; }
     bool operator <(const TypeBasic &rhs) const { return m_name < rhs.m_name; }
 
+    int setFetchedOffset(uint32_t offset = 0) { fetched_offset = offset; return 0;}
+    uint32_t getFetchedOffset() const { return fetched_offset; }
+    ObjectHandles* getObjHandles() {return &handles;}
+    int setItemCount(uint32_t n) { item_n = n; return 0;}
+    uint32_t getItemCount() const { return item_n; }
+    
+    void setFetchHandleDone(bool done) { fetched_handle_done = done;}
+    bool getFetchHandleDone() const { return fetched_handle_done; }
+
 protected:
     uint32_t m_id;
     uint32_t m_parent_id;
     uint32_t m_storage_id;
     std::string m_name;
+    uint32_t fetched_offset;
+    uint32_t item_n;
+    ObjectHandles handles;
+    bool fetched_handle_done;
 };
 
 #endif // SMTPFS_TYPE_BASIC
diff --git a/src/simple-mtpfs-type-dir.cpp b/src/simple-mtpfs-type-dir.cpp
old mode 100644
new mode 100755
index ae921d7..a3ecea1
--- a/src/simple-mtpfs-type-dir.cpp
+++ b/src/simple-mtpfs-type-dir.cpp
@@ -84,14 +84,14 @@ LIBMTP_folder_t *TypeDir::toLIBMTPFolder() const
 void TypeDir::addDir(const TypeDir &dir)
 {
     enterCritical();
-    m_dirs.insert(dir);
+    m_dirs.push_back(dir);
     leaveCritical();
 }
 
 void TypeDir::addFile(const TypeFile &file)
 {
     enterCritical();
-    m_files.insert(file);
+    m_files.push_back(file);
     leaveCritical();
 }
 
@@ -130,7 +130,7 @@ bool TypeDir::replaceFile(const TypeFile &oldfile, const TypeFile &newfile)
         return false;
     }
     m_files.erase(it);
-    m_files.insert(newfile);
+    m_files.push_back(newfile);
     leaveCritical();
     return true;
 }
diff --git a/src/simple-mtpfs-type-dir.h b/src/simple-mtpfs-type-dir.h
old mode 100644
new mode 100755
index 8883bfa..300ddce
--- a/src/simple-mtpfs-type-dir.h
+++ b/src/simple-mtpfs-type-dir.h
@@ -19,7 +19,7 @@
 #define SMTPFS_TYPE_DIR_H
 
 #include <mutex>
-#include <set>
+#include <vector>
 #include <string>
 
 #include "simple-mtpfs-type-basic.h"
@@ -46,17 +46,17 @@ public:
     bool removeFile(const TypeFile &file);
     bool replaceFile(const TypeFile &oldfile, const TypeFile &newfile);
 
-    std::set<TypeDir>::size_type dirCount() const { return m_dirs.size(); }
-    std::set<TypeFile>::size_type fileCount() const { return m_files.size(); }
+    std::vector<TypeDir>::size_type dirCount() const { return m_dirs.size(); }
+    std::vector<TypeFile>::size_type fileCount() const { return m_files.size(); }
     const TypeDir  *dir(const std::string &name) const;
     const TypeFile *file(const std::string &name) const;
-    std::set<TypeDir> dirs() const { return m_dirs; }
-    std::set<TypeFile> files() const { return m_files; }
+    std::vector<TypeDir> dirs() const { return m_dirs; }
+    std::vector<TypeFile> files() const { return m_files; }
     bool isEmpty() const { return m_dirs.empty() && m_files.empty(); }
 
-	time_t modificationDate() const { return m_modif_date; }
+	 time_t modificationDate() const { return m_modif_date; }
     void setModificationDate(time_t modif_date) { m_modif_date = modif_date; }
-	
+
     LIBMTP_folder_t *toLIBMTPFolder() const;
     TypeDir &operator =(const TypeDir &rhs);
     bool operator ==(const std::string &rhs) const { return TypeBasic::operator ==(rhs); }
@@ -65,8 +65,8 @@ public:
     bool operator <(const TypeDir &rhs) const { return TypeBasic::operator <(rhs); }
 
 private:
-    std::set<TypeDir> m_dirs;
-    std::set<TypeFile> m_files;
+    std::vector<TypeDir> m_dirs;
+    std::vector<TypeFile> m_files;
     mutable std::mutex m_access_mutex;
     bool m_fetched;
     time_t m_modif_date;
diff --git a/src/simple-mtpfs-util.cpp b/src/simple-mtpfs-util.cpp
old mode 100644
new mode 100755
index e7fd0e0..07b9a05
--- a/src/simple-mtpfs-util.cpp
+++ b/src/simple-mtpfs-util.cpp
@@ -290,3 +290,97 @@ bool smtpfs_check_dir(const std::string &path)
 
     return false;
 }
+
+int GetCoCPath(const char *inPath, COCMediaPathInfo *outPath)
+{
+    if(!inPath || !outPath)
+    {
+       logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", invaild paraments", "\n");
+       return -1;
+    }
+    
+    memset(outPath, 0x00, sizeof(COCMediaPathInfo));
+
+    char *pos = strstr((char *)inPath, COCPREKEY);
+    int len = 0;
+    char *path = NULL;
+    if(pos != NULL)
+    {
+       len = (pos - inPath);
+    }
+    else
+    {
+       len = strlen(inPath);
+    }
+    
+    path = (char *)calloc(1, len+1);
+    if(path == NULL)
+    {
+       logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ",calloc failed", "\n");
+       return -1;
+    }
+
+    memcpy(path, inPath, len);
+
+    //fill path
+    outPath->path = path;
+
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", path: ", outPath->path,  "\n");
+
+    //fill media type
+    if(pos && (strstr((char *)pos, COCMEDIATYPEAUDIO) != NULL))
+    {
+       outPath->MediaType |= MEDIATYPEAUDIO;
+    }
+
+    if(pos && (strstr((char *)pos, COCMEDIATYPEVIDEO) != NULL))
+    {
+       outPath->MediaType |= MEDIATYPEVIDEO;
+    }
+    
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", mediaType: ", outPath->MediaType,  "\n");
+
+    //fill media count
+    if(pos)
+    {
+      char *posCnt = strrchr(pos, '_');
+
+      //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", posCnt: ", posCnt, "\n");
+      //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", posCnt+1: ", posCnt+1, "\n");
+
+      if(posCnt)
+      {
+         if((int)(posCnt+1-inPath) <= strlen(inPath))
+         {
+            outPath->MediaCnt = atoi(posCnt+1);
+         }
+      }
+    }
+
+    //logmsg("  fun: ", __FUNCTION__, "  line: ", __LINE__, ", MediaCnt: ", outPath->MediaCnt,  "\n");
+
+    return 0;
+}
+
+int FreeCoCPath(COCMediaPathInfo *outPath)
+{
+   if(!outPath)
+   {
+      return -1;
+   }
+
+   if(outPath->path)
+   {
+      free(outPath->path);
+   }
+
+   memset(outPath, 0x00, sizeof(COCMediaPathInfo));
+
+   return 0;
+}
+
+
+bool endWith(const string& str, const string& substr) 
+{
+   return str.rfind(substr) == (str.length() - substr.length());
+}
diff --git a/src/simple-mtpfs-util.h b/src/simple-mtpfs-util.h
old mode 100644
new mode 100755
index 76d7117..4e4f541
--- a/src/simple-mtpfs-util.h
+++ b/src/simple-mtpfs-util.h
@@ -56,4 +56,29 @@ void smtpfs_raw_device_free(LIBMTP_raw_device_t *device);
 bool smtpfs_reset_device(LIBMTP_raw_device_t *device);
 #endif // HAVE_LIBUSB1
 
+//prefix string
+#define COCPREKEY             "_COCMEDIAPREKEY"
+//media type string
+#define COCMEDIATYPEAUDIO     "_AUDIO"
+#define COCMEDIATYPEVIDEO     "_VIDEO"
+#define COCMEDIATYPEAV        "_AUDIO_VIDEO"
+//media count string
+#define COCMEDIACOUNT(n)      #n
+
+//totle string
+#define COCMTPSPKEY(a, b, c)  #a##b##c
+
+typedef struct
+{
+   char *path;
+   #define MEDIATYPEAUDIO (0x01)
+   #define MEDIATYPEVIDEO (0x02)
+   int   MediaType;
+   int   MediaCnt;
+}COCMediaPathInfo;
+
+int GetCoCPath(const char *inPath, COCMediaPathInfo *outPath);
+int FreeCoCPath(COCMediaPathInfo *outPath);
+bool endWith(const std::string& str, const std::string& substr);
+
 #endif // SIMPLE_MTPFS_UTIL
