*******************************************************************************
Date         : 2020-04-26
Author       : Xiaojun Zou
Harman International Industries, Incorporated

Description  : This patch is used for caching file for MediaOne if necessary
ChangeList   : 5537089
*******************************************************************************

diff --git a/src/simple-mtpfs-config.cpp b/src/simple-mtpfs-config.cpp
index aad6583..cfe48d2 100755
--- a/src/simple-mtpfs-config.cpp
+++ b/src/simple-mtpfs-config.cpp
@@ -25,6 +25,9 @@ Config::Config()
 : mScanThrPolicy(SCHED_OTHER)
 , mScanThrPriority(0)
 , mExcludePattern()
+, mEnableCacheFirstFile(false)
+, mTmpPath()
+, mTmpSizeLimit(0)
 {}
 
 Config::~Config()
@@ -41,78 +44,127 @@ int Config::setConfig(uint32_t type, const std::string& value)
 {
    std::string valueLower = value;
 
-   std::transform(valueLower.begin(), valueLower.end(), valueLower.begin(), ::tolower);
    LogInfo("config type: %x; config value: %s", type, value.c_str());
-   if (value.empty())
-   {
-      LogInfo("empty value, no need to set up");
-      return 0;
-   }
+   std::transform(valueLower.begin(), valueLower.end(), valueLower.begin(), ::tolower);
    switch (type)
    {
       case SMTPFS_CONFIG_THREAD_POLICY:
       {
-         mScanThrPolicy = atoi(value.c_str());
+         if (!value.empty())
+         {
+            mScanThrPolicy = atoi(value.c_str());
+         }
       }
       break;
 
       case SMTPFS_CONFIG_THREAD_PRIORITY:
       {
-         mScanThrPriority = atoi(value.c_str());
+         if (!value.empty())
+         {
+            mScanThrPriority = atoi(value.c_str());
+         }
       }
       break;
 
       case SMTPFS_CONFIG_EXCLUDE_PATTERN:
       {
-         mExcludePattern = value;
+         if (!value.empty())
+         {
+            mExcludePattern = value;
+         }
       }
       break;
 
       case SMTPFS_CONFIG_EXTAUDIO:
       {
-         mExtNameAudio.push_back(valueLower);
+         if (!valueLower.empty())
+         {
+            mExtNameAudio.push_back(valueLower);
+         }
       }
       break;
 
       case SMTPFS_CONFIG_EXTVIDEO:
       {
-         mExtNameVideo.push_back(valueLower);
+         if (!valueLower.empty())
+         {
+            mExtNameVideo.push_back(valueLower);
+         }
       }
       break;
 
       case SMTPFS_CONFIG_EXTIMAGE:
       {
-         mExtNameImage.push_back(valueLower);
+         if (!valueLower.empty())
+         {
+            mExtNameImage.push_back(valueLower);
+         }
       }
       break;
 
       case SMTPFS_CONFIG_EXTPLAYLIST:
       {
-         mExtNamePlaylist.push_back(valueLower);
+         if (!valueLower.empty())
+         {
+            mExtNamePlaylist.push_back(valueLower);
+         }
       }
       break;
 
       case SMTPFS_CONFIG_EXTAUDIOBOOK:
       {
-         mExtNameAudiobook.push_back(valueLower);
+         if (!valueLower.empty())
+         {
+            mExtNameAudiobook.push_back(valueLower);
+         }
       }
       break;
 
       case SMTPFS_CONFIG_LOGLEVEL:
       {
-         mSMTPFSLogLevel = value;
+         if (!value.empty())
+         {
+            mSMTPFSLogLevel = value;
+         }
       }
       break;
 
       case SMTPFS_CONFIG_LIBMTP_LOGLEVEL:
       {
-         mLibMTPLogLevel = value;
+         if (!value.empty())
+         {
+            mLibMTPLogLevel = value;
+         }
+      }
+      break;
+
+      case SMTPFS_CONFIG_CACHEFIRSTFILE:
+      {
+         mEnableCacheFirstFile = true;
+      }
+      break;
+
+      case SMTPFS_CONFIG_TMPPATH:
+      {
+         if (!value.empty())
+         {
+            mTmpPath = value;
+         }
+      }
+      break;
+
+      case SMTPFS_CONFIG_TMPSIZELIMIT:
+      {
+         if (!value.empty())
+         {
+            mTmpSizeLimit = atoi(value.c_str());
+         }
       }
       break;
 
       default:
       {
-         LogError("Unsupported config type: %x", type);
+         LogError("Unsupported config type: %x; value: %s", type, value.c_str());
          return -1;
       }
       break;
diff --git a/src/simple-mtpfs-config.h b/src/simple-mtpfs-config.h
index c4d5566..395e2ba 100755
--- a/src/simple-mtpfs-config.h
+++ b/src/simple-mtpfs-config.h
@@ -40,6 +40,9 @@ public:
    std::vector<std::string> getExtNameAudiobook();
    std::string getSMTPFSLogLevel();
    std::string getLibMTPLogLevel();
+   bool getEnableCacheFirstFile();
+   std::string getTmpPath();
+   int32_t getTmpSizeLimit();
 
 private:
    int32_t mScanThrPolicy;
@@ -52,6 +55,9 @@ private:
    std::vector<std::string> mExtNameAudiobook;
    std::string mSMTPFSLogLevel;
    std::string mLibMTPLogLevel;
+   bool mEnableCacheFirstFile;
+   std::string mTmpPath;
+   int32_t mTmpSizeLimit;
 };
 
 inline int32_t Config::getScanThrPolicy()
@@ -104,4 +110,19 @@ inline std::string Config::getLibMTPLogLevel()
    return mLibMTPLogLevel;
 }
 
+inline bool Config::getEnableCacheFirstFile()
+{
+   return mEnableCacheFirstFile;
+}
+
+inline std::string Config::getTmpPath()
+{
+   return mTmpPath;
+}
+
+inline int32_t Config::getTmpSizeLimit()
+{
+   return mTmpSizeLimit;
+}
+
 #endif
\ No newline at end of file
diff --git a/src/simple-mtpfs-fuse.cpp b/src/simple-mtpfs-fuse.cpp
index 6b0d164..2edeae3 100755
--- a/src/simple-mtpfs-fuse.cpp
+++ b/src/simple-mtpfs-fuse.cpp
@@ -29,6 +29,9 @@ extern "C" {
 #include "simple-mtpfs-log.h"
 #include "simple-mtpfs-util.h"
 
+#define FD_SMTP_IOCTL_NODE       ((uint64_t)0)
+#define FD_SMTP_DEF_FILE_DESC    ((uint64_t)0)
+
 int wrap_getattr(const char *path, struct stat *statbuf)
 {
    LogDebug("enter getattr path:%s", path);
@@ -82,8 +85,7 @@ int wrap_utime(const char *path, struct utimbuf *ubuf)
 
 int wrap_open(const char *path, struct fuse_file_info *file_info)
 {
-   //return SMTPFileSystem::instance()->open(path, file_info);
-   return 0;
+   return SMTPFileSystem::instance()->open(path, file_info);
 }
 
 int wrap_access(const char *path, int mask)
@@ -95,13 +97,13 @@ int wrap_access(const char *path, int mask)
 int wrap_read(const char *path, char *buf, size_t size, off_t offset,
               struct fuse_file_info *file_info)
 {
-   //LogInfo("enter wrap_read[%s], size is :%d offset is:%d", path, size, offset);
+   LogDebug("enter wrap_read[%s], size is :%d offset is:%d", path, size, offset);
    return SMTPFileSystem::instance()->read(path, buf, size, offset, file_info);
 }
 
 int wrap_readbuf(const char *path, struct fuse_bufvec **bufp, size_t size, off_t off, struct fuse_file_info *fileinfo)
 {
-   //LogInfo("enter wrap_readbuf[%s], size is :%d offset is:%d", path, size, off);
+   LogDebug("enter wrap_readbuf[%s], size is :%d offset is:%d", path, size, off);
    int readsize = 0;
    struct fuse_bufvec *fbuf = (struct fuse_bufvec *)malloc(sizeof(struct fuse_bufvec));
    if (!fbuf)
@@ -251,7 +253,9 @@ SMTPFileSystem *SMTPFileSystem::instance()
 SMTPFileSystem::SMTPFileSystem() : m_args(),
                                    m_tmp_files_pool(),
                                    m_options(),
-                                   m_device()
+                                   m_mutex_mediaone_ioctl(),
+                                   m_ph_mediaone_ioctl(NULL),
+                                   m_device(*this)
 //  selectFd(0LL)
 {
    m_fuse_operations.getattr = wrap_getattr;
@@ -431,12 +435,6 @@ bool SMTPFileSystem::exec()
       return false;
    }
 
-   if (!m_tmp_files_pool.createTmpDir())
-   {
-      LogError("Can not create a temporary directory");
-      return false;
-   }
-
    if (m_options.m_device_file)
    {
       // Try to use device file first, if provided
@@ -452,6 +450,7 @@ bool SMTPFileSystem::exec()
    m_device.enableMove(m_options.m_enable_move);
    if (fuse_main(m_args.argc, m_args.argv, &m_fuse_operations, nullptr) > 0)
    {
+      LogInfo("fuse_main return false");
       return false;
    }
 
@@ -459,6 +458,7 @@ bool SMTPFileSystem::exec()
    m_device.disconnect();
    LogInfo("m_device.disconnect ok");
 
+   LogInfo("try to removeTmpDir");
    m_tmp_files_pool.removeTmpDir();
    LogInfo("removeTmpDir ok");
 
@@ -583,21 +583,22 @@ int SMTPFileSystem::getattr(const char *path, struct stat *buf)
 
 int SMTPFileSystem::mknod(const char *path, mode_t mode, dev_t dev)
 {
-   if (!S_ISREG(mode))
-      return -EINVAL;
+   return -EINVAL;
+   // if (!S_ISREG(mode))
+   //    return -EINVAL;
 
-   std::string tmp_path = m_tmp_files_pool.makeTmpPath(std::string(path));
-   int rval = ::open(tmp_path.c_str(), O_CREAT | O_WRONLY, mode);
-   if (rval < 0)
-      return -errno;
+   // std::string tmp_path = m_tmp_files_pool.makeTmpPath(std::string(path));
+   // int rval = ::open(tmp_path.c_str(), O_CREAT | O_WRONLY, mode);
+   // if (rval < 0)
+   //    return -errno;
 
-   rval = ::close(rval);
-   if (rval < 0)
-      return -errno;
+   // rval = ::close(rval);
+   // if (rval < 0)
+   //    return -errno;
 
-   m_device.filePush(tmp_path, std::string(path));
-   ::unlink(tmp_path.c_str());
-   return 0;
+   // m_device.filePush(tmp_path, std::string(path));
+   // ::unlink(tmp_path.c_str());
+   // return 0;
 }
 
 int SMTPFileSystem::mkdir(const char *path, mode_t mode)
@@ -617,28 +618,29 @@ int SMTPFileSystem::rmdir(const char *path)
 
 int SMTPFileSystem::rename(const char *path, const char *newpath)
 {
-   const std::string tmp_old_dirname(smtpfs_dirname(std::string(path)));
-   const std::string tmp_new_dirname(smtpfs_dirname(std::string(newpath)));
-   if (tmp_old_dirname == tmp_new_dirname)
-      return m_device.rename(std::string(path), std::string(newpath));
+   return -EINVAL;
+   // const std::string tmp_old_dirname(smtpfs_dirname(std::string(path)));
+   // const std::string tmp_new_dirname(smtpfs_dirname(std::string(newpath)));
+   // if (tmp_old_dirname == tmp_new_dirname)
+   //    return m_device.rename(std::string(path), std::string(newpath));
 
-   if (!m_options.m_enable_move)
-      return -EPERM;
+   // if (!m_options.m_enable_move)
+   //    return -EPERM;
 
-   const std::string tmp_file = m_tmp_files_pool.makeTmpPath(std::string(newpath));
-   int rval = m_device.filePull(std::string(path), tmp_file);
-   if (rval != 0)
-      return -rval;
+   // const std::string tmp_file = m_tmp_files_pool.makeTmpPath(std::string(newpath));
+   // int rval = m_device.filePull(std::string(path), tmp_file);
+   // if (rval != 0)
+   //    return -rval;
 
-   rval = m_device.filePush(tmp_file, std::string(newpath));
-   if (rval != 0)
-      return -rval;
+   // rval = m_device.filePush(tmp_file, std::string(newpath));
+   // if (rval != 0)
+   //    return -rval;
 
-   rval = m_device.fileRemove(std::string(path));
-   if (rval != 0)
-      return -rval;
+   // rval = m_device.fileRemove(std::string(path));
+   // if (rval != 0)
+   //    return -rval;
 
-   return 0;
+   // return 0;
 }
 
 int SMTPFileSystem::chmod(const char *path, mode_t mode)
@@ -653,36 +655,37 @@ int SMTPFileSystem::chown(const char *path, uid_t uid, gid_t gid)
 
 int SMTPFileSystem::truncate(const char *path, off_t new_size)
 {
-   const std::string tmp_path = m_tmp_files_pool.makeTmpPath(std::string(path));
-   int rval = m_device.filePull(std::string(path), tmp_path);
-   if (rval != 0)
-   {
-      ::unlink(tmp_path.c_str());
-      return -rval;
-   }
+   return -EINVAL;
+   // const std::string tmp_path = m_tmp_files_pool.makeTmpPath(std::string(path));
+   // int rval = m_device.filePull(std::string(path), tmp_path);
+   // if (rval != 0)
+   // {
+   //    ::unlink(tmp_path.c_str());
+   //    return -rval;
+   // }
 
-   rval = ::truncate(tmp_path.c_str(), new_size);
-   if (rval != 0)
-   {
-      int errno_tmp = errno;
-      ::unlink(tmp_path.c_str());
-      return -errno_tmp;
-   }
+   // rval = ::truncate(tmp_path.c_str(), new_size);
+   // if (rval != 0)
+   // {
+   //    int errno_tmp = errno;
+   //    ::unlink(tmp_path.c_str());
+   //    return -errno_tmp;
+   // }
 
-   rval = m_device.fileRemove(std::string(path));
-   if (rval != 0)
-   {
-      ::unlink(tmp_path.c_str());
-      return -rval;
-   }
+   // rval = m_device.fileRemove(std::string(path));
+   // if (rval != 0)
+   // {
+   //    ::unlink(tmp_path.c_str());
+   //    return -rval;
+   // }
 
-   rval = m_device.filePush(tmp_path, std::string(path));
-   ::unlink(tmp_path.c_str());
+   // rval = m_device.filePush(tmp_path, std::string(path));
+   // ::unlink(tmp_path.c_str());
 
-   if (rval != 0)
-      return -rval;
+   // if (rval != 0)
+   //    return -rval;
 
-   return 0;
+   // return 0;
 }
 
 int SMTPFileSystem::utime(const char *path, struct utimbuf *ubuf)
@@ -705,17 +708,18 @@ int SMTPFileSystem::utime(const char *path, struct utimbuf *ubuf)
 
 int SMTPFileSystem::create(const char *path, mode_t mode, fuse_file_info *file_info)
 {
-   const std::string tmp_path = m_tmp_files_pool.makeTmpPath(std::string(path));
+   return -EINVAL;
+   // const std::string tmp_path = m_tmp_files_pool.makeTmpPath(std::string(path));
 
-   int rval = ::creat(tmp_path.c_str(), mode);
-   if (rval < 0)
-      return -errno;
+   // int rval = ::creat(tmp_path.c_str(), mode);
+   // if (rval < 0)
+   //    return -errno;
 
-   file_info->fh = rval;
-   m_tmp_files_pool.addFile(TypeTmpFile(std::string(path), tmp_path, rval, true));
-   m_device.filePush(tmp_path, std::string(path));
+   // file_info->fh = rval;
+   // m_tmp_files_pool.addFile(TypeTmpFile(std::string(path), tmp_path, rval, true));
+   // m_device.filePush(tmp_path, std::string(path));
 
-   return 0;
+   // return 0;
 }
 
 int SMTPFileSystem::open(const char *path, struct fuse_file_info *file_info)
@@ -730,8 +734,10 @@ int SMTPFileSystem::open(const char *path, struct fuse_file_info *file_info)
       return -1;
    }
 
+   LogDebug("open path: %s", path);
    if (path == ioctlNode)
    {
+      file_info->fh = FD_SMTP_IOCTL_NODE;
       // if(!selectFd)
       // {
       // 	uint64_t handle = 0x0807060504030201;
@@ -746,8 +752,32 @@ int SMTPFileSystem::open(const char *path, struct fuse_file_info *file_info)
    }
    else
    {
-      //LogInfo("enter open path:%s, fh: %llx --> 0", path, file_info->fh);
-      file_info->fh = 0;
+      // check if the file be cached
+      const std::string std_path(path);
+      TypeTmpFile *tmp_file = const_cast<TypeTmpFile *>(m_tmp_files_pool.getFile(std_path));
+
+      if (NULL == tmp_file)
+      {
+         LogDebug("open file from device directly; path:%s", path);
+         // the file was not local cached, we need to request IO from the MTP device directly
+         file_info->fh = FD_SMTP_DEF_FILE_DESC;
+      }
+      else
+      {
+         // the file was local cached, we could request IO from local file
+         std::string tmp_path = tmp_file->pathTmp();
+         int fd = ::open(tmp_path.c_str(), file_info->flags);
+
+         if (fd < 0)
+         {
+            LogError("open the cached file failed, the cached file would be removed; %s; tmp file: %s", strerror(errno), tmp_path.c_str());
+            //::unlink(tmp_path.c_str());
+            return -errno;
+         }
+         file_info->fh = fd;
+         tmp_file->addFileDescriptor(fd);
+         LogDebug("open the cached file successfully. source: %s; tmp file: %s", std_path.c_str(), tmp_path.c_str());
+      }
    }
 
    return 0;
@@ -800,7 +830,7 @@ int SMTPFileSystem::read(const char *path, char *buf, size_t size,
    string ioctlNode = "/";
    ioctlNode += SMTPFSIOCTLNODE;
 
-   //LogInfo("read node: %s, size: %u, offset: %u, fh: %llx", path, size, offset, file_info->fh);
+   LogDebug("read node: %s, size: %u, offset: %u, fh: %llx", path, size, offset, file_info->fh);
 
    //if(buf) memset(buf, 0x00, size);
 
@@ -811,7 +841,25 @@ int SMTPFileSystem::read(const char *path, char *buf, size_t size,
    }
    else
    {
-      ret = m_device.filesplitPull(std_path, "", size, offset, (unsigned char *)buf);
+      const std::string std_path(path);
+      TypeTmpFile *tmp_file = const_cast<TypeTmpFile *>(m_tmp_files_pool.getFile(std_path));
+
+      if (NULL == tmp_file)
+      {
+         ret = m_device.filesplitPull(std_path, "", size, offset, (unsigned char *)buf);
+         LogDebug("read from device directly: ret: %d", ret);
+      }
+      else
+      {
+         ret = ::pread(file_info->fh, buf, size, offset);
+
+         LogDebug("read from cache file: ret: %d", ret);
+         if (ret < 0)
+         {
+            return -errno;
+         }
+         return ret;
+      }
    }
    return ret;
 }
@@ -819,16 +867,17 @@ int SMTPFileSystem::read(const char *path, char *buf, size_t size,
 int SMTPFileSystem::write(const char *path, const char *buf, size_t size,
                           off_t offset, struct fuse_file_info *file_info)
 {
-   const TypeTmpFile *tmp_file = m_tmp_files_pool.getFile(std::string(path));
-   if (!tmp_file)
-      return -EINVAL;
+   return -EINVAL;
+   // const TypeTmpFile *tmp_file = m_tmp_files_pool.getFile(std::string(path));
+   // if (!tmp_file)
+   //    return -EINVAL;
 
-   int rval = ::pwrite(file_info->fh, buf, size, offset);
-   if (rval < 0)
-      return -errno;
+   // int rval = ::pwrite(file_info->fh, buf, size, offset);
+   // if (rval < 0)
+   //    return -errno;
 
-   const_cast<TypeTmpFile *>(tmp_file)->setModified();
-   return rval;
+   // const_cast<TypeTmpFile *>(tmp_file)->setModified();
+   // return rval;
 }
 
 int SMTPFileSystem::release(const char *path, struct fuse_file_info *file_info)
@@ -841,24 +890,33 @@ int SMTPFileSystem::release(const char *path, struct fuse_file_info *file_info)
    if (std_path == std::string("-"))
       return 0;
 
-   TypeTmpFile *tmp_file = const_cast<TypeTmpFile *>(
-       m_tmp_files_pool.getFile(std_path));
+   TypeTmpFile *tmp_file = const_cast<TypeTmpFile *>(m_tmp_files_pool.getFile(std_path));
+
+   if (NULL == tmp_file)
+   {
+      LogError("get file from pool failed; path: %s", std_path.c_str());
+      return 0;
+   }
    tmp_file->removeFileDescriptor(file_info->fh);
    if (tmp_file->refcnt() != 0)
+   {
       return 0;
+   }
 
-   const bool modif = tmp_file->isModified();
+   // const bool modif = tmp_file->isModified();
    const std::string tmp_path = tmp_file->pathTmp();
+
    m_tmp_files_pool.removeFile(std_path);
-   if (modif)
-   {
-      rval = m_device.filePush(tmp_path, std_path);
-      if (rval != 0)
-      {
-         ::unlink(tmp_path.c_str());
-         return -rval;
-      }
-   }
+   // the file could not be modified from MediaOne's side
+   // if (modif)
+   // {
+   //    rval = m_device.filePush(tmp_path, std_path);
+   //    if (rval != 0)
+   //    {
+   //       ::unlink(tmp_path.c_str());
+   //       return -rval;
+   //    }
+   // }
 
    ::unlink(tmp_path.c_str());
 
@@ -974,11 +1032,12 @@ int SMTPFileSystem::fsyncdir(const char *path, int datasync,
 int SMTPFileSystem::ftruncate(const char *path, off_t offset,
                               struct fuse_file_info *file_info)
 {
-   const TypeTmpFile *tmp_file = m_tmp_files_pool.getFile(std::string(path));
-   if (::ftruncate(file_info->fh, offset) != 0)
-      return -errno;
-   const_cast<TypeTmpFile *>(tmp_file)->setModified();
-   return 0;
+   return -EINVAL;
+   // const TypeTmpFile *tmp_file = m_tmp_files_pool.getFile(std::string(path));
+   // if (::ftruncate(file_info->fh, offset) != 0)
+   //    return -errno;
+   // const_cast<TypeTmpFile *>(tmp_file)->setModified();
+   // return 0;
 }
 
 int SMTPFileSystem::access(const char *path, int mask)
@@ -1080,7 +1139,7 @@ int SMTPFileSystem::ioctl(const char *path, int cmd, void *arg, struct fuse_file
    string ioctlNode = "/";
    ioctlNode += SMTPFSIOCTLNODE;
 
-   //LogInfo("enter path:%s", path);
+   LogDebug("enter path:%s", path);
 
    if (!path || !file_info)
    {
@@ -1103,10 +1162,16 @@ int SMTPFileSystem::ioctl(const char *path, int cmd, void *arg, struct fuse_file
 
    switch (cmd)
    {
+   case SMTPFS_CHECKVERSION:
+   {
+      ret = ioctlCheckVersion((char *)data, SMTPFS_EVENT_MAXLEN);
+   }
+   break;
    case SMTPFS_GETEVENT:
    {
       //LogInfo(" cmd: SMTPFS_GETEVENT, %p, %p", data, arg);
-      ret = m_device.getEvent((char *)data, SMTPFS_EVENT_MAXLEN);
+      // ret = m_device.getEvent((char *)data, SMTPFS_EVENT_MAXLEN);
+      ret = ioctlGetTrackList((char *)data, SMTPFS_EVENT_MAXLEN);
    }
    break;
 
@@ -1122,10 +1187,18 @@ int SMTPFileSystem::ioctl(const char *path, int cmd, void *arg, struct fuse_file
       LogInfo(" cmd: SMTPFS_SETCONFIG, %p, %p", data, arg);
       ret = ioctlSetConfig((char *)data, SMTPFS_EVENT_MAXLEN);
    }
+   break;
+
+   case SMTPFS_ABORTSCAN:
+   {
+      LogInfo("cmd: SMTPFS_ABORTSCAN, abort the MTP scanning");
+      ret = m_device.abortTask();
+   }
+   break;
 
    default:
    {
-      //LogWarning(" unsupported cmd");
+      LogWarning(" unsupported cmd: %x", cmd);
       ret = -EINVAL;
    }
    break;
@@ -1152,6 +1225,7 @@ int SMTPFileSystem::poll(const char *path, struct fuse_file_info *file_info, str
 
    if (ioctlNode != path)
    {
+      // only process ioctl for mediaone ioctl node
       return -ENOSYS;
    }
 
@@ -1169,22 +1243,233 @@ int SMTPFileSystem::poll(const char *path, struct fuse_file_info *file_info, str
    // 	   return 0;
    //    }
 
-   if (ph && (false == m_device.indexingDone()))
+   if (m_device.isListAllDone())
    {
-      //LogInfo("has event to happen, notify app");
+      LogDebug("the scanning task was exited, let upper-layer call ioctl.");
       *reventsp |= POLLIN;
-      fuse_notify_poll(ph);
+      pollClear();
    }
    else
    {
-      //LogInfo("indexing done, not notify polling");
-      ret = -1;
+      if (m_device.hasAvailableTrack())
+      {
+         *reventsp |= POLLIN;
+         LogDebug("has available track info, notify app, add POLLIN, *reventsp: %x", *reventsp);
+      }
+      else
+      {
+         LogDebug("no track available, do not notify; *reventsp: %x", *reventsp);
+         pollRequest(ph);
+      }
    }
 
    //LogInfo("exit path:%s", path);
    return ret;
 }
 
+int SMTPFileSystem::onFileCache(const std::string& std_path)
+{
+   int ret = -1;
+
+   if (!Config::instance().getEnableCacheFirstFile())
+   {
+      LogInfo("Not enable cache first file");
+      return 0;
+   }
+   if (!m_tmp_files_pool.isInitialized())
+   {
+      ret = initTmpDir();
+      if (0 != ret || !m_tmp_files_pool.isInitialized())
+      {
+         LogError("initialize tmp dir failed, could not cache file to local; ret: %d", ret);
+         return 0;
+      }
+   }
+
+   std::string local_path = m_tmp_files_pool.makeTmpPath(std_path);
+   std::string dir_path(smtpfs_dirname(std_path));
+   std::string file_name(smtpfs_basename(std_path));
+   const TypeDir *content = m_device.dirFetchContentFromCache(dir_path);
+   const TypeFile *file = NULL;
+
+   if (NULL == content)
+   {
+      LogError("Did not find the dir for cache; %s", dir_path.c_str());
+      return -1;
+   }
+   file = content->file(file_name);
+   if (NULL == file)
+   {
+      LogError("Did not find the file for cache; name: %s; dir path: %s", file_name.c_str(), dir_path.c_str());
+      return -1;
+   }
+   // check if we could pull the file from device to local first
+   if (!m_tmp_files_pool.hasFreeSpace(file->size()))
+   {
+      LogError("Has no free space to cache file: source: %s; local: %s; size: %" PRIu64, std_path.c_str(), local_path.c_str(), file->size());
+      return -1;
+   }
+   ret = m_device.filePull(std_path, local_path);
+   if (0 == ret)
+   {
+      // use the fd as -1 to persist the local cache file, even if the no app call open for this file.
+      m_tmp_files_pool.addFile(TypeTmpFile(std_path, local_path, -1));
+      LogInfo("Have pulled the file from MTP device to local; source: %s; local: %s; size: %" PRIu64, std_path.c_str(), local_path.c_str(), file->size());
+   }
+   else
+   {
+      LogError("Pull file to local failed; source: %s; local: %s; size: %" PRIu64 "ret: %x", std_path.c_str(), local_path.c_str(), file->size(), ret);
+   }
+
+   return ret;
+}
+
+int SMTPFileSystem::onFileInfoAvailable()
+{
+   return pollNotify();
+}
+
+int SMTPFileSystem::pollRequest(struct fuse_pollhandle *ph)
+{
+   m_mutex_mediaone_ioctl.lock();
+   if (m_ph_mediaone_ioctl)
+   {
+      fuse_pollhandle_destroy(m_ph_mediaone_ioctl);
+      m_ph_mediaone_ioctl = NULL;
+   }
+   m_ph_mediaone_ioctl = ph;
+   m_mutex_mediaone_ioctl.unlock();
+   return 0;
+}
+
+int SMTPFileSystem::pollNotify()
+{
+   m_mutex_mediaone_ioctl.lock();
+   if (m_ph_mediaone_ioctl)
+   {
+      fuse_notify_poll(m_ph_mediaone_ioctl);
+      fuse_pollhandle_destroy(m_ph_mediaone_ioctl);
+      m_ph_mediaone_ioctl = NULL;
+   }
+   m_mutex_mediaone_ioctl.unlock();
+   return 0;
+}
+
+int SMTPFileSystem::pollClear()
+{
+   m_mutex_mediaone_ioctl.lock();
+   if (m_ph_mediaone_ioctl)
+   {
+      fuse_pollhandle_destroy(m_ph_mediaone_ioctl);
+      m_ph_mediaone_ioctl = NULL;
+   }
+   m_mutex_mediaone_ioctl.unlock();
+   return 0;
+}
+
+int SMTPFileSystem::initTmpDir()
+{
+   if (m_tmp_files_pool.isInitialized())
+   {
+      LogInfo("the tmp files pool was initialized already");
+      return 0;
+   }
+   m_tmp_files_pool.setTmpDir(Config::instance().getTmpPath());
+   m_tmp_files_pool.setTmpSizeLimit(Config::instance().getTmpSizeLimit());
+   if (!m_tmp_files_pool.createTmpDir())
+   {
+      LogError("createTmpDir for tmp files pool failed");
+      return -1;
+   }
+   return 0;
+}
+
+int SMTPFileSystem::ioctlCheckVersion(char *data, uint32_t len)
+{
+   if (NULL == data || (len < sizeof(smtpfs_version)))
+   {
+      LogError("data: %p, len: %d", data, len);
+      return -1;
+   }
+   smtpfs_version *version = (smtpfs_version *)data;
+   if (version->versionInternal == SMTPFS_INTERNAL_VERSION)
+   {
+      LogInfo("the version is correct: %" PRIu64, version->versionInternal);
+   }
+   else
+   {
+      LogError("incorrect version: %" PRIu64 "; simple-mtpfs internal version: %" PRIu64, version->versionInternal, SMTPFS_INTERNAL_VERSION);
+      return -1;
+   }
+
+   return 0;
+}
+
+int SMTPFileSystem::ioctlGetTrackList(char *data, uint32_t len)
+{
+   if (!data || (len < (int)sizeof(smtpfs_event)))
+   {
+      LogError("data: %p, len: %d", data, len);
+      return -1;
+   }
+   //LogInfo(" track list");
+   if (len < (sizeof(smtpfs_event) + sizeof(smtpfs_trackList) + sizeof(smtpfs_trackInfo)))
+   {
+      LogError("len[%u] is too small", len);
+      return -1;
+   }
+   
+   int32_t trackCount = (len - sizeof(smtpfs_event) - sizeof(smtpfs_trackList)) / sizeof(smtpfs_trackInfo);
+   std::vector<smtpfs_trackInfo> trackList;
+   int32_t ret = 0;
+
+   ret = m_device.getTrackList(trackList, trackCount);
+
+   //event header
+   smtpfs_event *pEvent = (smtpfs_event *)data;
+
+   //LogInfo("-----trackList, trackNum: %d------------", trackNum);
+   //fill event header
+   pEvent->eventType = SMTPFS_EVENT_TRACKLIST;
+   pEvent->len = sizeof(smtpfs_event);
+
+   //fill smtpfs_trackList
+   smtpfs_trackList *trackListHeader = (smtpfs_trackList *)(data + pEvent->len);
+
+   trackListHeader->fragment = 1;
+   trackListHeader->count = 0;
+   pEvent->len += sizeof(smtpfs_trackList);
+
+   if (ret < 0)
+   {
+      LogInfo("getTrackList failed; there is no track info any more; ret: %d", ret);
+      trackListHeader->fragment = 0;
+   }
+   else if (trackList.empty())
+   {
+      LogDebug("not track info available, pending");
+      pEvent->len = 0;
+   }
+   else
+   {
+      // fill the track list
+      smtpfs_trackInfo *track = (smtpfs_trackInfo *)(data + pEvent->len);
+
+      for (auto it = trackList.begin(); it != trackList.end(); ++ it)
+      {
+         //fill track info
+         *track = *it;
+
+         ++ track;
+         ++ trackListHeader->count;
+         pEvent->len += sizeof(smtpfs_trackInfo);
+      }
+      LogDebug("track info count: %d; len: %u", trackListHeader->count, pEvent->len);
+   }
+
+   return pEvent->len;
+}
+
 int SMTPFileSystem::ioctlSetConfig(char *data, uint32_t len)
 {
    if (NULL == data || (len < sizeof(smtpfs_config)))
diff --git a/src/simple-mtpfs-fuse.h b/src/simple-mtpfs-fuse.h
index 88a1618..3fe9763 100755
--- a/src/simple-mtpfs-fuse.h
+++ b/src/simple-mtpfs-fuse.h
@@ -23,7 +23,7 @@
 #include <string>
 #include <cstdlib>
 extern "C" {
-#  include <fuse/fuse.h>
+#include <fuse/fuse.h>
 }
 #include "simple-mtpfs-mtp-device.h"
 #include "simple-mtpfs-tmp-files-pool.h"
@@ -31,104 +31,124 @@ extern "C" {
 
 class SMTPFileSystem
 {
-private:
-    struct SMTPFileSystemOptions {
+ private:
+   struct SMTPFileSystemOptions
+   {
     public:
-        int m_good;
-        int m_help;
-        int m_version;
-        int m_verbose;
-        int m_enable_move;
-        int m_list_devices;
-        int m_device_no;
-        char *m_device_file;
-        char *m_mount_point;
-
-        SMTPFileSystemOptions();
-        ~SMTPFileSystemOptions();
-
-        static int opt_proc(void *data, const char *arg, int key,
-            struct fuse_args *outargs);
-    };
-
-    SMTPFileSystem();
-
-    enum {
-        KEY_ENABLE_MOVE,
-        KEY_DEVICE_NO,
-        KEY_LIST_DEVICES,
-        KEY_VERBOSE,
-        KEY_VERSION,
-        KEY_HELP
-    };
-
-public:
-    ~SMTPFileSystem();
-
-    static SMTPFileSystem *instance();
-
-    bool parseOptions(int argc, char **argv);
-    void printHelp() const;
-    void printVersion() const;
-    bool listDevices() const;
-
-    bool exec();
-    bool isGood() const { return m_options.m_good; }
-    bool isHelp() const { return m_options.m_help; }
-    bool isVersion() const { return m_options.m_version; }
-    bool isListDevices() const { return m_options.m_list_devices; }
-
-    int getattr(const char *path, struct stat *buf);
-    int mknod(const char *path, mode_t mode, dev_t dev);
-    int mkdir(const char *path, mode_t mode);
-    int unlink(const char *path);
-    int rmdir(const char *path);
-    int rename(const char *path, const char *newpath);
-    int chmod(const char *path, mode_t mode);
-    int chown(const char *path, uid_t uid, gid_t gid);
-    int truncate(const char *path, off_t new_size);
-    int utime(const char *path, struct utimbuf *ubuf);
-    int open(const char *path, struct fuse_file_info *file_info);
-    int read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *file_info);
-    int write(const char *path, const char *buf, size_t size, off_t offset, struct fuse_file_info *file_info);
-    int statfs(const char *path, struct statvfs *stat_info);
-    int flush(const char *path, struct fuse_file_info *file_info);
-    int release(const char *path, struct fuse_file_info *file_info);
-    int fsync(const char *path, int datasync, struct fuse_file_info *fi);
-    int opendir(const char *path, struct fuse_file_info *file_info);
-    int readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *file_info);
-    int releasedir(const char *path, struct fuse_file_info *file_info);
-    int fsyncdir(const char *path, int datasync, struct fuse_file_info *file_info);
-    int ftruncate(const char *path, off_t offset, struct fuse_file_info *file_info);
-    void* init(struct fuse_conn_info *conn);
-    int create(const char *path, mode_t mode, fuse_file_info *file_info);
-    int access(const char *path, int mask);
-    int ioctl(const char *path, int cmd, void *arg, struct fuse_file_info *file_info, unsigned int flags, void *data);
-    int poll(const char *path, struct fuse_file_info *file_info, struct fuse_pollhandle *ph, unsigned *reventsp);
-    //void polLock() { m_Pollhandle_lock.lock(); }
-    //void polUnlock() { m_Pollhandle_lock.unlock(); }
+      int m_good;
+      int m_help;
+      int m_version;
+      int m_verbose;
+      int m_enable_move;
+      int m_list_devices;
+      int m_device_no;
+      char *m_device_file;
+      char *m_mount_point;
+
+      SMTPFileSystemOptions();
+      ~SMTPFileSystemOptions();
+
+      static int opt_proc(void *data, const char *arg, int key,
+                          struct fuse_args *outargs);
+   };
+
+   SMTPFileSystem();
+
+   enum
+   {
+      KEY_ENABLE_MOVE,
+      KEY_DEVICE_NO,
+      KEY_LIST_DEVICES,
+      KEY_VERBOSE,
+      KEY_VERSION,
+      KEY_HELP
+   };
+
+ public:
+   ~SMTPFileSystem();
+
+   static SMTPFileSystem *instance();
+
+   bool parseOptions(int argc, char **argv);
+   void printHelp() const;
+   void printVersion() const;
+   bool listDevices() const;
+
+   bool exec();
+   bool isGood() const { return m_options.m_good; }
+   bool isHelp() const { return m_options.m_help; }
+   bool isVersion() const { return m_options.m_version; }
+   bool isListDevices() const { return m_options.m_list_devices; }
+
+   int getattr(const char *path, struct stat *buf);
+   int mknod(const char *path, mode_t mode, dev_t dev);
+   int mkdir(const char *path, mode_t mode);
+   int unlink(const char *path);
+   int rmdir(const char *path);
+   int rename(const char *path, const char *newpath);
+   int chmod(const char *path, mode_t mode);
+   int chown(const char *path, uid_t uid, gid_t gid);
+   int truncate(const char *path, off_t new_size);
+   int utime(const char *path, struct utimbuf *ubuf);
+   int open(const char *path, struct fuse_file_info *file_info);
+   int read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *file_info);
+   int write(const char *path, const char *buf, size_t size, off_t offset, struct fuse_file_info *file_info);
+   int statfs(const char *path, struct statvfs *stat_info);
+   int flush(const char *path, struct fuse_file_info *file_info);
+   int release(const char *path, struct fuse_file_info *file_info);
+   int fsync(const char *path, int datasync, struct fuse_file_info *fi);
+   int opendir(const char *path, struct fuse_file_info *file_info);
+   int readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *file_info);
+   int releasedir(const char *path, struct fuse_file_info *file_info);
+   int fsyncdir(const char *path, int datasync, struct fuse_file_info *file_info);
+   int ftruncate(const char *path, off_t offset, struct fuse_file_info *file_info);
+   void *init(struct fuse_conn_info *conn);
+   int create(const char *path, mode_t mode, fuse_file_info *file_info);
+   int access(const char *path, int mask);
+   int ioctl(const char *path, int cmd, void *arg, struct fuse_file_info *file_info, unsigned int flags, void *data);
+   int poll(const char *path, struct fuse_file_info *file_info, struct fuse_pollhandle *ph, unsigned *reventsp);
+   //void polLock() { m_Pollhandle_lock.lock(); }
+   //void polUnlock() { m_Pollhandle_lock.unlock(); }
+
+ public:
+   // receive the notify from MTPDevice
+   int onFileCache(const std::string& std_path);
+   int onFileInfoAvailable();
+
+ private:
+   static bool removeDir(const std::string &dirname);
+   // for polling of mediaone ioctl
+   int pollRequest(struct fuse_pollhandle *ph);
+   int pollNotify();
+   int pollClear();
+
+   int initTmpDir();
+   bool createTmpDir();
+   bool removeTmpDir();
+
+   // check the version between MediaOne and simple-mtpfs
+   int ioctlCheckVersion(char *data, uint32_t len);
+   // handle ioctl for get track list
+   int ioctlGetTrackList(char *data, uint32_t len);
+   // handle ioctl for set config
+   int ioctlSetConfig(char *data, uint32_t len);
 
 private:
-    static bool removeDir(const std::string &dirname);
-
-    bool createTmpDir();
-    bool removeTmpDir();
-
-    //  handle ioctl for set config
-    int ioctlSetConfig(char* data, uint32_t len);
-
-    static std::unique_ptr<SMTPFileSystem> s_instance;
-    struct fuse_args m_args;
-    struct fuse_operations m_fuse_operations;
-    TmpFilesPool m_tmp_files_pool;
-    SMTPFileSystemOptions m_options;
-    
-public:
-    MTPDevice m_device;
-
-// private:
-//    //save select node file handle
-//     uint64_t selectFd;
+   static std::unique_ptr<SMTPFileSystem> s_instance;
+   struct fuse_args m_args;
+   struct fuse_operations m_fuse_operations;
+   TmpFilesPool m_tmp_files_pool;
+   SMTPFileSystemOptions m_options;
+
+   std::mutex m_mutex_mediaone_ioctl;
+   struct fuse_pollhandle *m_ph_mediaone_ioctl;
+
+ public:
+   MTPDevice m_device;
+
+   // private:
+   //    //save select node file handle
+   //     uint64_t selectFd;
 };
 
 #endif // SMTPFS_FUSE_H
diff --git a/src/simple-mtpfs-mtp-device.cpp b/src/simple-mtpfs-mtp-device.cpp
index b5fbb69..be151c9 100755
--- a/src/simple-mtpfs-mtp-device.cpp
+++ b/src/simple-mtpfs-mtp-device.cpp
@@ -36,6 +36,7 @@ extern "C" {
 #include "simple-mtpfs-log.h"
 #include "simple-mtpfs-mtp-device.h"
 #include "simple-mtpfs-util.h"
+#include "simple-mtpfs-fuse.h"
 
 // the time out for libmtp request
 #define LIBMTP_REQUEST_TIMEOUT                  (500)
@@ -47,10 +48,11 @@ static LIBMTP_mtpdevice_t *g_device = NULL;
 static MTPDevice *gMTPDev = NULL;
 #define RINGBUF_SIZE (512 * 1024)
 
-MTPDevice::MTPDevice() :
+MTPDevice::MTPDevice(SMTPFileSystem &fs) :
 #ifdef MTP_HAS_DB
                          SIMPLE_DB(),
 #endif
+                         mFileSystem(fs),
                          m_device(nullptr),
                          m_capabilities(),
                          m_device_mutex(),
@@ -67,7 +69,9 @@ MTPDevice::MTPDevice() :
                          m_trackList_offset(0),
                          scanThreadRun(false),
                          isIndexingDone(false),
+                         mScanAbort(false),
                          m_lastMode_sync_done(false),
+                         mNeedCacheFile(false),
                          mFolderIgnored(0),
                          mFileIgnored(0)
 {
@@ -86,6 +90,7 @@ MTPDevice::~MTPDevice()
    sem_destroy(&device_connect_sem);
    scanThreadRun = false;
    isIndexingDone = false;
+   mScanAbort = true;
    m_lastMode_sync_done = false;
 }
 
@@ -353,7 +358,7 @@ bool MTPDevice::enumStorages()
 
 const TypeDir *MTPDevice::dirFetchContentFromCache(std::string path)
 {
-   //LogInfo("MTPDevice::dirFetchContentFromCache: path:%s", path.c_str());
+   LogDebug("MTPDevice::dirFetchContentFromCache: path:%s", path.c_str());
 
    if (false == m_root_dir.isFetched())
    {
@@ -760,66 +765,64 @@ int MTPDevice::readByRingBuf(const uint32_t id, const uint64_t fileSize, const u
     size_t rBufDataSize = RingBuffer_Out(m_rbuf, (void *)buf, size);
 	return rBufDataSize;
 #else
+   m_read_data_cmd_coming = 1;
+   int rVal = 0;
+   uint32_t tmpLen = 0;
+   long diffTime;
+   unsigned char *tmpBuf = NULL;
+
+   long t1 = getSysRunTime();
+   //LogInfo("read get lock, 1111");
+   criticalEnter1();
+   //LogInfo("read get lock, 2222");
+   rVal = LIBMTP_GetPartialObject(m_device, id, offset, size, &tmpBuf, &tmpLen);
+   //LogInfo("read get lock, 3333");
+   criticalLeave1();
+   //LogInfo("read get lock, 4444");
+   long t2 = getSysRunTime();
+   diffTime = t2 - t1;
+   if (diffTime > LIBMTP_REQUEST_TIMEOUT)
    {
-      m_read_data_cmd_coming = 1;
-      int rVal = 0;
-      uint32_t tmpLen = 0;
-      long diffTime;
-      unsigned char *tmpBuf = NULL;
+      LogInfo("id: %d, retLen: %d, diffTime: %ld ms", id, rVal, diffTime);
+   }
 
-      long t1 = getSysRunTime();
-      //LogInfo("read get lock, 1111");
-      criticalEnter1();
-      //LogInfo("read get lock, 2222");
-      rVal = LIBMTP_GetPartialObject(m_device, id, offset, size, &tmpBuf, &tmpLen);
-      //LogInfo("read get lock, 3333");
-      criticalLeave1();
-      //LogInfo("read get lock, 4444");
-      long t2 = getSysRunTime();
-      diffTime = t2 - t1;
-      if (diffTime > LIBMTP_REQUEST_TIMEOUT)
-      {
-         LogInfo("id: %d, retLen: %d, diffTime: %ld ms", id, rVal, diffTime);
-      }
+   m_read_data_cmd_coming = 0;
 
-      m_read_data_cmd_coming = 0;
+   //LogInfo("LIBMTP_GetPartialObject rVal:%d, tmpLen:%d, willReadLen:%d", rVal, tmpLen, willReadLen);
 
-      //LogInfo("LIBMTP_GetPartialObject rVal:%d, tmpLen:%d, willReadLen:%d", rVal, tmpLen, willReadLen);
+   if (rVal || (tmpLen > size))
+   {
+      LogError("LIBMTP_GetPartialObject, id: %u, rVal: %d, tmpLen[%d] < willReadLen[%d]", id, rVal, tmpLen, size);
 
-      if (rVal || (tmpLen > size))
+      LIBMTP_Dump_Errorstack(m_device);
+      LIBMTP_Clear_Errorstack(m_device);
+      return -1;
+   }
+   else
+   {
+      if (tmpLen && tmpBuf)
       {
-         LogError("LIBMTP_GetPartialObject, id: %u, rVal: %d, tmpLen[%d] < willReadLen[%d]", id, rVal, tmpLen, size);
-
-         LIBMTP_Dump_Errorstack(m_device);
-         LIBMTP_Clear_Errorstack(m_device);
-         return -1;
+         //push data into ringbuf
+         m_fileOffset += tmpLen;
+         if (m_fileOffset == fileSize)
+         {
+            m_fileOffset = 0;
+         }
+         memcpy((void *)buf, (void *)tmpBuf, tmpLen);
+         free(tmpBuf);
+         return tmpLen;
       }
-      else if (!rVal)
+      else
       {
-         if (tmpLen && tmpBuf)
+         if (m_fileOffset != fileSize)
          {
-            //push data into ringbuf
-            m_fileOffset += tmpLen;
-            if (m_fileOffset == fileSize)
-            {
-               m_fileOffset = 0;
-            }
-            memcpy((void *)buf, (void *)tmpBuf, tmpLen);
-            free(tmpBuf);
-            return tmpLen;
+            LogWarning("read return len == 0, ask app retry; ofst: %" PRIu64 "; fileSize: %" PRIu64 "; tmpLen: %u; tmpBuf: %x; LIBMTP_GetPartialObject return: %x", m_fileOffset, fileSize, tmpLen, tmpBuf, rVal);
+            return -EAGAIN;
          }
          else
          {
-            if (m_fileOffset != fileSize)
-            {
-               LogWarning("read return len == 0, ask app retry");
-               return -EAGAIN;
-            }
-            else
-            {
-               LogInfo("read reach eof");
-               return 0;
-            }
+            LogInfo("read reach eof; ofst: %" PRIu64 "; fileSize: %" PRIu64 "; tmpLen: %u; tmpBuf: %x; LIBMTP_GetPartialObject return: %x", m_fileOffset, fileSize, tmpLen, tmpBuf, rVal);
+            return 0;
          }
       }
    }
@@ -1055,7 +1058,7 @@ bool MTPDevice::listDevices(bool verbose, const std::string &dev_file)
                 << " /dev/bus/usb/" << bus_num_str << "/" << dev_num_str
                 << std::endl;
 #ifdef HAVE_LIBMTP_CHECK_CAPABILITY
-      MTPDevice dev;
+      MTPDevice dev(*SMTPFileSystem::instance());
       if (verbose)
       {
          if (!dev.connect(&raw_devices[i]))
@@ -1159,6 +1162,12 @@ int MTPDevice::getMediaFileType(const std::string &filename)
 
 int MTPDevice::getAllFolderAndFiles(LIBMTP_mtpdevice_t *device, LIBMTP_devicestorage_t *storage, uint32_t id, string &path, const string &lastModePath)
 {
+   LogDebug("enter scan for folder: %s", path.c_str());
+   if (mScanAbort)
+   {
+      LogInfo("mtp scanning was aborted");
+      return -1;
+   }
    if (NULL == device)
    {
       LogError("the device is NULL");
@@ -1205,6 +1214,11 @@ int MTPDevice::getAllFolderAndFiles(LIBMTP_mtpdevice_t *device, LIBMTP_devicesto
 
    while (m_read_data_cmd_coming)
    {
+      if (mScanAbort)
+      {
+         LogInfo("mtp scanning was aborted");
+         return -1;
+      }
       LogInfo("in syncing, wait, let read cmd first");
       usleep(200000);
    }
@@ -1236,6 +1250,11 @@ int MTPDevice::getAllFolderAndFiles(LIBMTP_mtpdevice_t *device, LIBMTP_devicesto
    {
       while (m_read_data_cmd_coming)
       {
+         if (mScanAbort)
+         {
+            LogInfo("mtp scanning was aborted");
+            break;
+         }
          LogInfo("in syncing, wait, let read cmd first");
          usleep(200000);
       }
@@ -1280,6 +1299,11 @@ int MTPDevice::getAllFolderAndFiles(LIBMTP_mtpdevice_t *device, LIBMTP_devicesto
 
       while (mtpFile != NULL)
       {
+         if (mScanAbort)
+         {
+            LogInfo("mtp scanning was aborted");
+            break;
+         }
          if (m_lastMode_sync_done && !lastModePath.empty())
          {
             LogInfo("----lastmode scan done----");
@@ -1294,10 +1318,10 @@ int MTPDevice::getAllFolderAndFiles(LIBMTP_mtpdevice_t *device, LIBMTP_devicesto
          {
             string folderPath = path + "/" + tmpFile->filename;
 
-            //LogInfo("-----folder: %s, path: %s, size: %llu---------\n", tmpFile->filename, folderPath.c_str(), tmpFile->filesize);
+            LogDebug("scan folder: %s, path: %s---------", tmpFile->filename, folderPath.c_str());
             if (reMatch(folderPath + "/", reExclude))
             {
-               LogInfo("-----ignore folder: %s---------", folderPath.c_str());
+               LogInfo("ignore folder: %s", folderPath.c_str());
                ++ mFolderIgnored;
             }
             else
@@ -1309,14 +1333,14 @@ int MTPDevice::getAllFolderAndFiles(LIBMTP_mtpdevice_t *device, LIBMTP_devicesto
                }
                else
                {
-                  LogInfo("-----lastmode skip folder: %s---------", folderPath.c_str());
+                  LogInfo("lastmode skip folder: %s", folderPath.c_str());
                }
             }
          }
          else
          {
             string filePath = path + "/" + tmpFile->filename;
-            //LogInfo("-----file: %s, path: %s---------\n", tmpFile->filename, filePath.c_str());
+            LogDebug("scan file: %s, path: %s, size: %llu---------", tmpFile->filename, filePath.c_str(), tmpFile->filesize);
 
             //save into db
             int fileType = getMediaFileType(tmpFile->filename);
@@ -1335,7 +1359,7 @@ int MTPDevice::getAllFolderAndFiles(LIBMTP_mtpdevice_t *device, LIBMTP_devicesto
                criticalLeave1();
                if ((t2 - t1) >= LIBMTP_REQUEST_TIMEOUT)
                {
-                  LogInfo("LIBMTP_Get_Trackmetadata, id: %x; path: %s; took: %lu ms", tmpFile->item_id, filePath.c_str(), (t2 - t1));
+                  LogInfo("LIBMTP_Get_Trackmetadata, id: %u; path: %s; took: %lu ms", tmpFile->item_id, filePath.c_str(), (t2 - t1));
                }
 
                smtpfs_trackInfo smtpfsTrack;
@@ -1358,14 +1382,42 @@ int MTPDevice::getAllFolderAndFiles(LIBMTP_mtpdevice_t *device, LIBMTP_devicesto
                   criticalLeave1();
                }
 
+               ret = -1;
                if (lastModePath.empty() && (m_lastmode_path != filePath))
                {
-                  m_trackMetaList.push_back(smtpfsTrack);
+                  // for non-lastmode, need to cache the first audio file successfully, and notify it to MediaOne.
+                  // but others files should not be notified to MediaOne, until the mtp scanning completed.
+                  if (mNeedCacheFile && MTP_FILE_TYPE_AUDIO == fileType)
+                  {
+                     ret = mFileSystem.onFileCache(filePath);
+                  }
+                  if (0 == ret)
+                  {
+                     pushTrackInfo(smtpfsTrack);
+                     mNeedCacheFile = false;
+                  }
+                  else
+                  {
+                     if (Config::instance().getEnableCacheFirstFile())
+                     {
+                        m_tmpTrackMetaList.push_back(smtpfsTrack);
+                     }
+                     else
+                     {
+                        pushTrackInfo(smtpfsTrack);
+                     }
+                  }
                }
-
                if (!lastModePath.empty() && (lastModePath == filePath))
                {
-                  m_trackMetaList.push_back(smtpfsTrack);
+                  // for lastmode, just cache the lastmode file.
+                  // even if cache failed, notify the lastmode track to MediaOne.
+                  if (mNeedCacheFile)
+                  {
+                     ret = mFileSystem.onFileCache(filePath);
+                  }
+                  pushTrackInfo(smtpfsTrack);
+                  mNeedCacheFile = false;
                   LogInfo("----find lastModePath: %s---", lastModePath.c_str());
                   m_lastMode_sync_done = true;
                   break;
@@ -1479,6 +1531,10 @@ int32_t MTPDevice::autoListAll()
       LogInfo("end scan Storage: %s, storage->id: %x, took: %lu ms", storage->StorageDescription, storage->id, (t2 - t1));
    }
 
+   // before list all done, copy the tmp track list to the track list
+   pushTrackList(m_tmpTrackMetaList);
+   std::vector<smtpfs_trackInfo>().swap(m_tmpTrackMetaList);
+
    m_list_all_done = 1;
 
    long whole_t2 = getSysRunTime();
@@ -1533,6 +1589,7 @@ int MTPDevice::launchTasks()
       }
 
       scanThreadRun = true;
+      mScanAbort = false;
       ret = pthread_create(&pid, &attr, autoScanItemsRun, this);
       if (ret)
       {
@@ -1547,6 +1604,19 @@ int MTPDevice::launchTasks()
    return 0;
 }
 
+int MTPDevice::abortTask()
+{
+   LogInfo("try to abort the MTP scanning thread");
+   mScanAbort = true;
+
+   return 0;
+}
+
+bool MTPDevice::isMediaType(const std::string &path)
+{
+   return (MTP_FILE_TYPE_UNKNOWN != getMediaFileType(path));
+}
+
 void MTPDevice::printTrackInfo(const smtpfs_trackInfo *track)
 {
    if (track == NULL)
@@ -1666,92 +1736,31 @@ int MTPDevice::fillTrackInfoByFile(smtpfs_trackInfo *dst, const LIBMTP_file_t *s
    return 0;
 }
 
-int MTPDevice::getEvent(char *buf, uint32_t bufLen)
+int32_t MTPDevice::getTrackList(std::vector<smtpfs_trackInfo> &trackList, int32_t count)
 {
-   if (!buf || (bufLen < (int)sizeof(smtpfs_event)))
+   trackList.clear();
+   if (isIndexingDone)
    {
-      LogError("buf: %p, bufLen: %d", buf, bufLen);
+      LogInfo("the scanning is done, and all of the track info were consumed");
       return -1;
    }
-
-   //event header
-   int dataLen = 0;
-
-   smtpfs_event *pEvent = (smtpfs_event *)buf;
-
-   if (!isIndexingDone)
+   else
    {
-      //LogInfo(" track list");
-      if (bufLen < (sizeof(smtpfs_event) + sizeof(smtpfs_trackList) + sizeof(smtpfs_trackInfo)))
+      if (!m_list_all_done && !hasAvailableTrack())
       {
-         LogError("bufLen[%u] is too small", bufLen);
-         return -1;
-      }
-
-      if (!m_list_all_done && (m_trackList_offset >= m_trackMetaList.size()))
-      {
-         //LogError("m_trackList_offset: %d >= total: %d", m_trackList_offset, m_trackMetaList.size());
-         if (m_list_all_done)
-         {
-            LogInfo("set isIndexingDone == ture done");
-            isIndexingDone = true;
-            m_trackMetaList.clear();
-            vector<smtpfs_trackInfo>().swap(m_trackMetaList);
-            return -1;
-         }
+         // pending
          return 0;
       }
-
-      uint32_t trackNum = (bufLen - sizeof(smtpfs_event) - sizeof(smtpfs_trackList)) / sizeof(smtpfs_trackInfo);
-
-      //LogInfo("-----trackList, trackNum: %d------------", trackNum);
-
-      //fill event header
-      pEvent->eventType = SMTPFS_EVENT_TRACKLIST;
-      dataLen += sizeof(smtpfs_event);
-
-      //fill smtpfs_trackList
-      smtpfs_trackList *trackListHeader = (smtpfs_trackList *)(buf + dataLen);
-      trackListHeader->fragment = 1;
-      dataLen += sizeof(smtpfs_trackList);
-
-      uint32_t total = m_trackMetaList.size();
-      uint32_t i = 0, sum = 0;
-      for (i = m_trackList_offset; i < total && sum < trackNum; i++, sum++)
-      {
-         //LogInfo("-----trackList, sum: %d------------", sum);
-         //fill track info
-         smtpfs_trackInfo *track = (smtpfs_trackInfo *)(buf + dataLen + sum * sizeof(smtpfs_trackInfo));
-
-         *track = m_trackMetaList[i];
-
-         //printTrackInfoprintTrackInfo(track);
-      }
-
-      //LogInfo("-----trackList, sum: %d, total: %d, m_trackList_offset: %d, trackNum: %d------------", sum, total, m_trackList_offset, trackNum);
-
-      dataLen += sum * sizeof(smtpfs_trackInfo);
-
-      m_trackList_offset = i;
-
-      pEvent->len = dataLen;
-
-      if (m_list_all_done && (m_trackList_offset >= m_trackMetaList.size()))
+      popTrackList(trackList, count);
+      if (m_list_all_done && !hasAvailableTrack())
       {
-         trackListHeader->fragment = 0;
          LogInfo("isIndexingDone is true");
          isIndexingDone = true;
-         m_trackMetaList.clear();
-         vector<smtpfs_trackInfo>().swap(m_trackMetaList);
+         clearTrackList();
       }
-
-      trackListHeader->count = sum;
-      //LogInfo("bufLen: %u, dataLen: %d", bufLen, dataLen);
    }
 
-   //LogInfo("dataLen: %d", dataLen);
-
-   return dataLen;
+   return (int32_t)trackList.size();
 }
 
 int MTPDevice::setEvent(char *buf, uint32_t bufLen)
@@ -1827,6 +1836,8 @@ int MTPDevice::setLastModeSyncPath(string path)
 
    mScanThPolicy = Config::instance().getScanThrPolicy();
    mScanThPriority = Config::instance().getScanThrPriority();
+
+   mNeedCacheFile = Config::instance().getEnableCacheFirstFile();
    // end of initialize
 
 
@@ -1839,7 +1850,63 @@ int MTPDevice::setLastModeSyncPath(string path)
    return 0;
 }
 
-bool MTPDevice::isMediaType(const std::string &path)
+void MTPDevice::clearTrackList()
 {
-   return (MTP_FILE_TYPE_UNKNOWN != getMediaFileType(path));
+   m_mutexTrackList.lock();
+
+   m_trackMetaList.clear();
+   vector<smtpfs_trackInfo>().swap(m_trackMetaList);
+
+   m_mutexTrackList.unlock();
+}
+
+void MTPDevice::pushTrackInfo(const smtpfs_trackInfo &trackInfo)
+{
+   pushTrackList(std::vector<smtpfs_trackInfo>(1, trackInfo));
+}
+
+void MTPDevice::pushTrackList(const std::vector<smtpfs_trackInfo> &trackList)
+{
+   m_mutexTrackList.lock();
+
+   m_trackMetaList.insert(m_trackMetaList.end(), trackList.begin(), trackList.end());
+
+   m_mutexTrackList.unlock();
+
+   // notify filesystem, there might be some io request waiting
+   mFileSystem.onFileInfoAvailable();
+}
+
+int32_t MTPDevice::popTrackList(std::vector<smtpfs_trackInfo> &trackList, int32_t count)
+{
+   trackList.clear();
+   m_mutexTrackList.lock();
+
+   int32_t cntAvaMeta = (int32_t)m_trackMetaList.size() - (int32_t)m_trackList_offset;
+
+   count = std::min(count, cntAvaMeta);
+   if (count > 0)
+   {
+      auto it = m_trackMetaList.begin() + m_trackList_offset;
+
+      trackList.assign(it, it + count);
+      m_trackList_offset += count;
+   }
+
+   m_mutexTrackList.unlock();
+
+   return count;
+}
+
+bool MTPDevice::hasAvailableTrack()
+{
+   bool ava = false;
+
+   m_mutexTrackList.lock();
+
+   ava = (m_trackList_offset < m_trackMetaList.size());
+
+   m_mutexTrackList.unlock();
+
+   return ava;
 }
\ No newline at end of file
diff --git a/src/simple-mtpfs-mtp-device.h b/src/simple-mtpfs-mtp-device.h
index c04923c..375b134 100755
--- a/src/simple-mtpfs-mtp-device.h
+++ b/src/simple-mtpfs-mtp-device.h
@@ -35,6 +35,9 @@ extern "C" {
 
 //#define MTP_HAS_DB
 
+// definition for SMTPFileSystem
+class SMTPFileSystem;
+
 #ifdef MTP_HAS_DB
 class MTPDevice : public SIMPLE_DB
 #else
@@ -66,7 +69,7 @@ class MTPDevice
 
    // -------------------------------------------------------------------------
 
-   MTPDevice();
+   MTPDevice(SMTPFileSystem &fs);
    ~MTPDevice();
 
    bool connect(LIBMTP_raw_device_t *dev);
@@ -107,10 +110,12 @@ class MTPDevice
    void criticalLeave1() { m_device_mutex.unlock(); }
    bool isFileExist(const uint32_t id);
    int32_t autoListAll();
-   int getEvent(char *buf, uint32_t bufLen);
+   int32_t getTrackList(std::vector<smtpfs_trackInfo> &trackList, int32_t count);
    int setEvent(char *buf, uint32_t bufLen);
    int launchTasks();
-   bool indexingDone() { return isIndexingDone; };
+   int abortTask();
+   bool isListAllDone() { return m_list_all_done; };
+   bool hasAvailableTrack();
    bool isMediaType(const std::string &path);
 
  private:
@@ -134,8 +139,16 @@ class MTPDevice
    int fillTrackInfoByFile(smtpfs_trackInfo *dst, const LIBMTP_file_t *src, const char *path, int type);
    int getMediaFileType(const std::string &filename);
    int setLastModeSyncPath(string path);
+   // for metadata track list
+   void clearTrackList();
+   void pushTrackInfo(const smtpfs_trackInfo &trackInfo);
+   void pushTrackList(const std::vector<smtpfs_trackInfo> &trackList);
+   int32_t popTrackList(std::vector<smtpfs_trackInfo> &trackList, int32_t count);
 
  private:
+   // the reference of the owner, SMTPFileSystem
+   SMTPFileSystem &mFileSystem;
+
    LIBMTP_mtpdevice_t *m_device;
    Capabilities m_capabilities;
    std::mutex m_device_mutex;
@@ -152,7 +165,9 @@ class MTPDevice
    uint64_t m_fileSize;
    uint64_t m_fileOffset;
 
-   //for event notify
+   std::vector<smtpfs_trackInfo> m_tmpTrackMetaList;
+   //for event notify, make it be thread-safty
+   std::mutex m_mutexTrackList;
    uint32_t m_trackList_offset;
    std::vector<smtpfs_trackInfo> m_trackMetaList;
 
@@ -160,12 +175,17 @@ class MTPDevice
    bool scanThreadRun;
    //scan track done
    bool isIndexingDone;
+   // abort MTP scanning
+   bool mScanAbort;
    //last mode path
    string m_lastmode_path;
 
    //lastmode sync done
    bool m_lastMode_sync_done;
 
+   // need cache the scanned file
+   bool mNeedCacheFile;
+
    int32_t mScanThPolicy;
    int32_t mScanThPriority;
    std::map<std::string, std::regex> mReMapExclude;
diff --git a/src/simple-mtpfs-tmp-files-pool.cpp b/src/simple-mtpfs-tmp-files-pool.cpp
old mode 100644
new mode 100755
index a3b88e8..6eb285b
--- a/src/simple-mtpfs-tmp-files-pool.cpp
+++ b/src/simple-mtpfs-tmp-files-pool.cpp
@@ -18,13 +18,20 @@
 #include <config.h>
 #include <algorithm>
 #include <sstream>
+
+#include <sys/vfs.h>
+
 #include "simple-mtpfs-tmp-files-pool.h"
 #include "simple-mtpfs-sha1.h"
 #include "simple-mtpfs-util.h"
+#include "simple-mtpfs-log.h"
+
+#define TMP_SIZE_LIMIT_PERCENT_DEF (30)
 
-TmpFilesPool::TmpFilesPool():
-    m_tmp_dir(smtpfs_get_tmpdir()),
-    m_pool()
+TmpFilesPool::TmpFilesPool() : m_tmp_dir(smtpfs_get_tmpdir()),
+                               m_tmp_size_limit(TMP_SIZE_LIMIT_PERCENT_DEF),
+                               m_pool(),
+                               m_initialized(false)
 {
 }
 
@@ -32,39 +39,97 @@ TmpFilesPool::~TmpFilesPool()
 {
 }
 
+void TmpFilesPool::setTmpDir(const std::string &tmp_dir)
+{
+   if (!tmp_dir.empty())
+   {
+      m_tmp_dir = tmp_dir;
+   }
+}
+
+void TmpFilesPool::setTmpSizeLimit(const int32_t percent)
+{
+   if (percent > 0)
+   {
+      m_tmp_size_limit = percent;
+   }
+}
+
 void TmpFilesPool::removeFile(const std::string &path)
 {
-    auto it = std::find(m_pool.begin(), m_pool.end(), path);
-    if (it == m_pool.end())
-        return;
-    m_pool.erase(it);
+   auto it = std::find(m_pool.begin(), m_pool.end(), path);
+   if (it == m_pool.end())
+      return;
+   m_pool.erase(it);
+}
+
+bool TmpFilesPool::hasFreeSpace(uint64_t size)
+{
+   struct statfs s;
+   uint64_t freeSize = 0;
+   uint64_t totalSize = 0;
+
+   memset(&s, 0, sizeof(s));
+   statfs(m_tmp_dir.c_str(), &s);
+
+   freeSize = (uint64_t)s.f_bsize * (uint64_t)s.f_bavail;
+   totalSize = (uint64_t)s.f_bsize * (uint64_t)s.f_blocks;
+   if (size > freeSize)
+   {
+      LogError("the dir has no free space; dir: %s; expect size: %" PRIu64 "; free size: %" PRIu64, m_tmp_dir.c_str(), size, freeSize);
+      return false;
+   }
+   if (size > totalSize * m_tmp_size_limit / 100)
+   {
+      LogError("the size is more than the size limitation; expect size: %" PRIu64 "; limit size: %" PRIu64, size, totalSize * m_tmp_size_limit / 100);
+      return false;
+   }
+   LogInfo("total size: %" PRIu64 "; free size: %" PRIu64 "; expect size: %" PRIu64, totalSize, freeSize, size);
+
+   return true;
 }
 
 const TypeTmpFile *TmpFilesPool::getFile(const std::string &path) const
 {
-    auto it = std::find(m_pool.begin(), m_pool.end(), path);
-    if (it == m_pool.end())
-        return nullptr;
-    return static_cast<const TypeTmpFile*>(&*it);
+   auto it = std::find(m_pool.begin(), m_pool.end(), path);
+   if (it == m_pool.end())
+      return nullptr;
+   return static_cast<const TypeTmpFile *>(&*it);
 }
 
 std::string TmpFilesPool::makeTmpPath(const std::string &path_device) const
 {
-    static int cnt = 0;
-    std::stringstream ss;
-    ss << path_device << ++cnt;
-    return m_tmp_dir + std::string("/") + SHA1::sumString(ss.str());
+   static int cnt = 0;
+   std::stringstream ss;
+   ss << path_device << ++cnt;
+   return m_tmp_dir + std::string("/") + SHA1::sumString(ss.str());
 }
 
 bool TmpFilesPool::createTmpDir()
 {
-    removeTmpDir();
-    return smtpfs_create_dir(m_tmp_dir);
+   bool ret = false;
+
+   removeTmpDir();
+   ret = smtpfs_create_dir(m_tmp_dir);
+   if (ret)
+   {
+      LogInfo("create tmp dir OK; %s", m_tmp_dir.c_str());
+   }
+   else
+   {
+      LogError("create tmp dir failed; %s", m_tmp_dir.c_str());
+   }
+   m_initialized = true;
+
+   return ret;
 }
 
 bool TmpFilesPool::removeTmpDir()
 {
-    if (!m_tmp_dir.empty())
-        return smtpfs_remove_dir(m_tmp_dir);
-    return false;
+   if (m_tmp_dir.empty())
+   {
+      m_tmp_dir = smtpfs_get_tmpdir();
+   }
+   
+   return smtpfs_remove_dir(m_tmp_dir);
 }
diff --git a/src/simple-mtpfs-tmp-files-pool.h b/src/simple-mtpfs-tmp-files-pool.h
old mode 100644
new mode 100755
index 8b11c7b..23d0153
--- a/src/simple-mtpfs-tmp-files-pool.h
+++ b/src/simple-mtpfs-tmp-files-pool.h
@@ -25,25 +25,30 @@
 
 class TmpFilesPool
 {
-public:
-    TmpFilesPool();
-    ~TmpFilesPool();
-
-    void setTmpDir(const std::string &tmp_dir) { m_tmp_dir = tmp_dir; }
-
-    void addFile(const TypeTmpFile &tmp) { m_pool.insert(tmp); }
-    void removeFile(const std::string &path);
-    bool empty() const { return m_pool.size(); }
-
-    const TypeTmpFile *getFile(const std::string &path) const;
-
-    std::string makeTmpPath(const std::string &path_device) const;
-    bool createTmpDir();
-    bool removeTmpDir();
-
-private:
-    std::string m_tmp_dir;
-    std::set<TypeTmpFile> m_pool;
+ public:
+   TmpFilesPool();
+   ~TmpFilesPool();
+
+   bool isInitialized(){ return m_initialized; }
+   void setTmpDir(const std::string &tmp_dir);
+   void setTmpSizeLimit(const int32_t percent);
+
+   void addFile(const TypeTmpFile &tmp) { m_pool.insert(tmp); }
+   void removeFile(const std::string &path);
+   bool empty() const { return m_pool.size(); }
+   bool hasFreeSpace(uint64_t size);
+
+   const TypeTmpFile *getFile(const std::string &path) const;
+
+   std::string makeTmpPath(const std::string &path_device) const;
+   bool createTmpDir();
+   bool removeTmpDir();
+
+ private:
+   std::string m_tmp_dir;
+   int32_t m_tmp_size_limit;
+   std::set<TypeTmpFile> m_pool;
+   bool m_initialized;
 };
 
 #endif // SMTPFS_TMP_FILES_POOL_H
diff --git a/src/simple-mtpfs-util.cpp b/src/simple-mtpfs-util.cpp
index 502aa64..bb2dac5 100755
--- a/src/simple-mtpfs-util.cpp
+++ b/src/simple-mtpfs-util.cpp
@@ -142,11 +142,12 @@ std::string smtpfs_get_tmpdir()
         tmp_dir = smtpfs_realpath(c_tmp);
     }
 
-    tmp_dir += "/simple-mtpfs-XXXXXX";
-    char *c_tmp_dir = ::mkdtemp(::strdup(tmp_dir.c_str()));
+   tmp_dir += "/simple-mtpfs";
+   //  tmp_dir += "/simple-mtpfs-XXXXXX";
+   //  char *c_tmp_dir = ::mkdtemp(::strdup(tmp_dir.c_str()));
 
-    tmp_dir.assign(c_tmp_dir);
-    ::free(static_cast<void*>(c_tmp_dir));
+   //  tmp_dir.assign(c_tmp_dir);
+   //  ::free(static_cast<void*>(c_tmp_dir));
 
     return tmp_dir;
 }
@@ -162,6 +163,7 @@ bool smtpfs_remove_dir(const std::string &dirname)
     struct dirent *entry;
     std::string path;
 
+    LogDebug("try to remove the dir: %s", dirname.c_str());
     dir = ::opendir(dirname.c_str());
     if (!dir)
         return false;
@@ -172,10 +174,12 @@ bool smtpfs_remove_dir(const std::string &dirname)
             if (entry->d_type == DT_DIR)
                 return smtpfs_remove_dir(path);
             ::unlink(path.c_str());
+            LogDebug("unlink file: %s", path.c_str());
         }
     }
     ::closedir(dir);
     ::remove(dirname.c_str());
+    LogDebug("remove dir: %s", dirname.c_str());
     return true;
 }
 
@@ -699,6 +703,25 @@ bool reMatch(const std::string& str, const std::regex& re)
     return false;
 }
 
+bool reSearch(const std::string &str, const std::regex &re)
+{
+   //  use c++ regex search
+    try
+    {
+        return std::regex_search(str, re);
+    }
+    catch (std::regex_error e)
+    {
+        LogError("regex exception: %d; %s; str: %s;", e.code(), e.what(), str.c_str());
+    }
+    catch (...)
+    {
+        LogError("catch unknown exception while search excluding string; str: %s", str.c_str());
+    }
+
+    return false;
+}
+
 int setThreadPriority(int32_t policy, int32_t priority)
 {
    sched_param param;
diff --git a/src/simple-mtpfs-util.h b/src/simple-mtpfs-util.h
index b7bb773..cd8280a 100755
--- a/src/simple-mtpfs-util.h
+++ b/src/simple-mtpfs-util.h
@@ -19,6 +19,8 @@
 #define SIMPLE_MTPFS_UTIL
 
 #include <config.h>
+#include <stdint.h>
+#include <inttypes.h>
 #include <cstdint>
 #include <string>
 #include <regex>
@@ -83,6 +85,7 @@ bool makePatternStrArray(std::string &pattern, const std::vector<std::string> &s
 bool makeRegEx(std::regex &re, const std::string &pattern);
 bool makeRegExStrArray(std::regex &re, const std::vector<std::string> &strVec);
 bool reMatch(const std::string &str, const std::regex &re);
+bool reSearch(const std::string &str, const std::regex &re);
 
 inline long getSysRunTime()
 {
diff --git a/src/simple-mtpfs.h b/src/simple-mtpfs.h
index fae2b9b..f8d17f9 100755
--- a/src/simple-mtpfs.h
+++ b/src/simple-mtpfs.h
@@ -21,8 +21,18 @@
 
 #include <sys/ioctl.h>
 
+// the internal version of simple-mtpfs, it need to be updated if the interface file "simple-mtpfs.h" be modified
+#define SMTPFS_INTERNAL_VERSION     ((uint64_t)1)
+
 #define SMTPFS_EVENT_MAXLEN (8 * 1024) //128k
 
+// SMTPFS_GETVERSION
+// the versioin structure
+typedef struct
+{
+   uint64_t versionInternal;
+} smtpfs_version;
+
 typedef struct
 {
 #define SMTPFS_EVENT_SYNC_LASTMODE (0x01)
@@ -65,7 +75,8 @@ typedef struct
 {
    int fragment;
    int count;
-   smtpfs_trackInfo trackList[0];
+   // fix gcc warning
+   // smtpfs_trackInfo trackList[0];
 } smtpfs_trackList;
 
 //for sync lastmode: smtpfs_event + smtpfs_sync_lastmode
@@ -92,6 +103,10 @@ typedef struct
 // for log config
 #define SMTPFS_CONFIG_LOGLEVEL (0x9)
 #define SMTPFS_CONFIG_LIBMTP_LOGLEVEL (0xa)
+// for file cache tmp folder
+#define SMTPFS_CONFIG_CACHEFIRSTFILE (0xb)
+#define SMTPFS_CONFIG_TMPPATH (0xc)
+#define SMTPFS_CONFIG_TMPSIZELIMIT (0xd)
 typedef struct
 {
    //	the config type
@@ -105,13 +120,19 @@ typedef struct
 #define SMTPFSIOCTLNODE "mediaone_smtpfs_node"
 #define SMTPFSMAGIC 'm'
 
+// check the version
+#define SMTPFS_CHECKVERSION _IOW(SMTPFSMAGIC, 1, char[SMTPFS_EVENT_MAXLEN])
+
 //write  event
-#define SMTPFS_SETEVENT _IOW(SMTPFSMAGIC, 1, char[SMTPFS_EVENT_MAXLEN])
+#define SMTPFS_SETEVENT _IOW(SMTPFSMAGIC, 2, char[SMTPFS_EVENT_MAXLEN])
 
 //read event
-#define SMTPFS_GETEVENT _IOR(SMTPFSMAGIC, 2, char[SMTPFS_EVENT_MAXLEN])
+#define SMTPFS_GETEVENT _IOR(SMTPFSMAGIC, 3, char[SMTPFS_EVENT_MAXLEN])
 
 //  set config from MediaOne
-#define SMTPFS_SETCONFIG _IOW(SMTPFSMAGIC, 3, char[SMTPFS_EVENT_MAXLEN])
+#define SMTPFS_SETCONFIG _IOW(SMTPFSMAGIC, 4, char[SMTPFS_EVENT_MAXLEN])
+
+// abort the MTP scanning
+#define SMTPFS_ABORTSCAN _IOW(SMTPFSMAGIC, 5, char[SMTPFS_EVENT_MAXLEN])
 
 #endif
\ No newline at end of file
