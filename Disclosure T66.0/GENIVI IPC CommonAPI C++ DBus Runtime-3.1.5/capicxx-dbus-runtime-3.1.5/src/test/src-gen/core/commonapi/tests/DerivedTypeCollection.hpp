/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201512091035.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef COMMONAPI_TESTS_Derived_Type_Collection_HPP_
#define COMMONAPI_TESTS_Derived_Type_Collection_HPP_


#include <commonapi/tests/PredefinedTypeCollection.hpp>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>
#include <unordered_map>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace commonapi {
namespace tests {

struct DerivedTypeCollection {
    struct TestStruct : CommonAPI::Struct<::commonapi::tests::PredefinedTypeCollection::TestString, uint16_t> {
    	
    	TestStruct() {
    	}
    	TestStruct(const ::commonapi::tests::PredefinedTypeCollection::TestString &_testString, const uint16_t &_uintValue)
    	{
    		std::get<0>(values_) = _testString;
    		std::get<1>(values_) = _uintValue;
    	}
    	/**
    	 * description: the name of the property
    	 */
    	inline const ::commonapi::tests::PredefinedTypeCollection::TestString &getTestString() const { return std::get<0>(values_); }
    	inline void setTestString(const ::commonapi::tests::PredefinedTypeCollection::TestString &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: the actual value
    	 */
    	inline const uint16_t &getUintValue() const { return std::get<1>(values_); }
    	inline void setUintValue(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const TestStruct& _other) const {
                return (getTestString() == _other.getTestString() && getUintValue() == _other.getUintValue());
        }
    	inline bool operator!=(const TestStruct &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<DerivedTypeCollection::TestStruct> TestArrayTestStruct;
    typedef std::unordered_map<uint32_t, ::commonapi::tests::DerivedTypeCollection::TestArrayTestStruct> TestMap;
    
    struct TestEnum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            E_UNKNOWN = 0,
            E_OK = 1,
            E_OUT_OF_RANGE = 2,
            E_NOT_USED = 3
        };
        
        TestEnum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::E_UNKNOWN)) {}
        TestEnum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::E_UNKNOWN):
                case static_cast<int32_t>(Literal::E_OK):
                case static_cast<int32_t>(Literal::E_OUT_OF_RANGE):
                case static_cast<int32_t>(Literal::E_NOT_USED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const TestEnum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TestEnum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TestEnum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TestEnum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TestEnum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const TestEnum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct TestEnumExtended : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            E_UNKNOWN = 0,
            E_OK = 1,
            E_OUT_OF_RANGE = 2,
            E_NOT_USED = 3,
            E_NEW = 4
        };
        
        TestEnumExtended() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::E_UNKNOWN)) {}
        TestEnumExtended(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        TestEnumExtended &operator=(const TestEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::E_UNKNOWN):
                case static_cast<int32_t>(Literal::E_OK):
                case static_cast<int32_t>(Literal::E_OUT_OF_RANGE):
                case static_cast<int32_t>(Literal::E_NOT_USED):
                case static_cast<int32_t>(Literal::E_NEW):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const TestEnumExtended &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TestEnumExtended &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TestEnumExtended &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TestEnumExtended &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TestEnumExtended &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const TestEnumExtended &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct TestEnumExtended2 : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            E_UNKNOWN = 0,
            E_OK = 1,
            E_OUT_OF_RANGE = 2,
            E_NOT_USED = 3,
            E_NEW = 4,
            E_NEW2 = 5
        };
        
        TestEnumExtended2() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::E_UNKNOWN)) {}
        TestEnumExtended2(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        TestEnumExtended2 &operator=(const TestEnumExtended::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
        TestEnumExtended2 &operator=(const TestEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::E_UNKNOWN):
                case static_cast<int32_t>(Literal::E_OK):
                case static_cast<int32_t>(Literal::E_OUT_OF_RANGE):
                case static_cast<int32_t>(Literal::E_NOT_USED):
                case static_cast<int32_t>(Literal::E_NEW):
                case static_cast<int32_t>(Literal::E_NEW2):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const TestEnumExtended2 &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TestEnumExtended2 &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TestEnumExtended2 &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TestEnumExtended2 &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TestEnumExtended2 &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const TestEnumExtended2 &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct TestStructExtended : CommonAPI::Struct<::commonapi::tests::PredefinedTypeCollection::TestString, uint16_t, TestEnumExtended2> {
    	
    	TestStructExtended() {
    	}
    	TestStructExtended(const ::commonapi::tests::PredefinedTypeCollection::TestString &_testString, const uint16_t &_uintValue, const TestEnumExtended2 &_testEnumExtended2)
    	{
    		std::get<0>(values_) = _testString;
    		std::get<1>(values_) = _uintValue;
    		std::get<2>(values_) = _testEnumExtended2;
    	}
    	/**
    	 * description: the name of the property
    	 */
    	inline const ::commonapi::tests::PredefinedTypeCollection::TestString &getTestString() const { return std::get<0>(values_); }
    	inline void setTestString(const ::commonapi::tests::PredefinedTypeCollection::TestString &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: the actual value
    	 */
    	inline const uint16_t &getUintValue() const { return std::get<1>(values_); }
    	inline void setUintValue(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	inline const TestEnumExtended2 &getTestEnumExtended2() const { return std::get<2>(values_); }
    	inline void setTestEnumExtended2(const TestEnumExtended2 &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const TestStructExtended& _other) const {
                return (getTestString() == _other.getTestString() && getUintValue() == _other.getUintValue() && getTestEnumExtended2() == _other.getTestEnumExtended2());
        }
    	inline bool operator!=(const TestStructExtended &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::unordered_map<::commonapi::tests::DerivedTypeCollection::TestEnum, std::string, CommonAPI::EnumHasher<::commonapi::tests::DerivedTypeCollection::TestEnum>> TestEnumMap;
    
    struct TestEnumMissingValue : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            E1 = 0,
            E2 = 1,
            E3 = 2
        };
        
        TestEnumMissingValue() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::E1)) {}
        TestEnumMissingValue(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::E1):
                case static_cast<int32_t>(Literal::E2):
                case static_cast<int32_t>(Literal::E3):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const TestEnumMissingValue &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TestEnumMissingValue &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TestEnumMissingValue &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TestEnumMissingValue &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TestEnumMissingValue &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const TestEnumMissingValue &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    typedef std::vector<uint64_t> TestArrayUInt64;
    static const CommonAPI::Serial TESTPOLYMORPHICSTRUCT_SERIAL = 0x8F51A326;
    static const CommonAPI::Serial TESTEXTENDEDPOLYMORPHICSTRUCT_SERIAL = 0xA49310F2;
    
    struct TestPolymorphicStruct : CommonAPI::PolymorphicStruct {
    	static std::shared_ptr<TestPolymorphicStruct> create(CommonAPI::Serial _serial);
    	CommonAPI::Serial getSerial() const { return TESTPOLYMORPHICSTRUCT_SERIAL; }
    	
    	TestPolymorphicStruct() {
    	}
    	TestPolymorphicStruct(const ::commonapi::tests::PredefinedTypeCollection::TestString &_testString, const uint16_t &_uintValue)
    	{
    		std::get<0>(values_) = _testString;
    		std::get<1>(values_) = _uintValue;
    	}
    	template<class _Input>
    	void readValue(CommonAPI::InputStream<_Input> &_input, const CommonAPI::EmptyDeployment *_depl) {
    		_input.template readValue<CommonAPI::EmptyDeployment>(std::get<0>(values_));
    		_input.template readValue<CommonAPI::EmptyDeployment>(std::get<1>(values_));
    		switch (getSerial()) {
    		case TESTEXTENDEDPOLYMORPHICSTRUCT_SERIAL:
    			static_cast<TestExtendedPolymorphicStruct *>(this)->template readValue<_Input>(_input, _depl);
    			break;
    		default:
    			break;
    		}
    	}
    
    	template<class _Input, class _Deployment>
    	void readValue(CommonAPI::InputStream<_Input> &_input, const _Deployment *_depl) {
    		_input.template readValue<>(std::get<0>(values_), std::get<0>(_depl->values_));
    		_input.template readValue<>(std::get<1>(values_), std::get<1>(_depl->values_));
    		switch (getSerial()) {
    		case TESTEXTENDEDPOLYMORPHICSTRUCT_SERIAL:
    			static_cast<TestExtendedPolymorphicStruct *>(this)->template readValue<>(_input, _depl);
    			break;
    		default:
    			break;
    		}
    	}
    	template<class _Output>
    	void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
    		_output.writeType(std::get<0>(values_), _depl);
    		_output.writeType(std::get<1>(values_), _depl);
    		switch (getSerial()) {
    		case TESTEXTENDEDPOLYMORPHICSTRUCT_SERIAL:
    			static_cast<TestExtendedPolymorphicStruct *>(this)->template writeType<_Output>(_output, _depl);
    			break;
    		default:
    			break;
    		}
    	}
    	template<class _Output, class _Deployment>
    	void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const _Deployment *_depl) {
    		_output.writeType(std::get<0>(values_), std::get<0>(_depl->values_));
    		_output.writeType(std::get<1>(values_), std::get<1>(_depl->values_));
    		switch (getSerial()) {
    		case TESTEXTENDEDPOLYMORPHICSTRUCT_SERIAL:
    			static_cast<TestExtendedPolymorphicStruct *>(this)->template writeType<_Output, _Deployment>(_output, _depl);
    			break;
    		default:
    			break;
    		}
    	}
    
    	template<class _Output>
    	void writeValue(CommonAPI::OutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
    		_output.template writeValue<CommonAPI::EmptyDeployment>(std::get<0>(values_));
    		_output.template writeValue<CommonAPI::EmptyDeployment>(std::get<1>(values_));
    		switch (getSerial()) {
    		case TESTEXTENDEDPOLYMORPHICSTRUCT_SERIAL:
    			static_cast<TestExtendedPolymorphicStruct *>(this)->template writeValue<_Output>(_output, _depl);
    			break;
    		default:
    			break;
    		}
    	}
    
    	template<class _Output, class _Deployment>
    	void writeValue(CommonAPI::OutputStream<_Output> &_output, const _Deployment *_depl) {
    		_output.template writeValue<>(std::get<0>(values_), std::get<0>(_depl->values_));
    		_output.template writeValue<>(std::get<1>(values_), std::get<1>(_depl->values_));
    		switch (getSerial()) {
    		case TESTEXTENDEDPOLYMORPHICSTRUCT_SERIAL:
    			static_cast<TestExtendedPolymorphicStruct *>(this)->template writeValue<>(_output, _depl);
    			break;
    		default:
    			break;
    		}
    	}
    	/**
    	 * description: the name of the property
    	 */
    	inline const ::commonapi::tests::PredefinedTypeCollection::TestString &getTestString() const { return std::get<0>(values_); }
    	inline void setTestString(const ::commonapi::tests::PredefinedTypeCollection::TestString &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: the actual value
    	 */
    	inline const uint16_t &getUintValue() const { return std::get<1>(values_); }
    	inline void setUintValue(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	
    	std::tuple<::commonapi::tests::PredefinedTypeCollection::TestString, uint16_t> values_;
    	inline bool operator==(const TestPolymorphicStruct& _other) const {
                return (getTestString() == _other.getTestString() && getUintValue() == _other.getUintValue());
        }
    	inline bool operator!=(const TestPolymorphicStruct &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct TestExtendedPolymorphicStruct : TestPolymorphicStruct {
    	CommonAPI::Serial getSerial() const { return TESTEXTENDEDPOLYMORPHICSTRUCT_SERIAL; }
    	
    	TestExtendedPolymorphicStruct() {
    	}
    	TestExtendedPolymorphicStruct(const ::commonapi::tests::PredefinedTypeCollection::TestString &_testString, const uint16_t &_uintValue, const uint32_t &_additionalValue)
    	: TestPolymorphicStruct(_testString, _uintValue)
    	{
    		std::get<0>(values_) = _additionalValue;
    	}
    	template<class _Input>
    	void readValue(CommonAPI::InputStream<_Input> &_input, const CommonAPI::EmptyDeployment *_depl) {
    	    (void) _depl;
    		_input.template readValue<CommonAPI::EmptyDeployment>(std::get<0>(values_));
    	}
    
    	template<class _Input, class _Deployment>
    	void readValue(CommonAPI::InputStream<_Input> &_input, const _Deployment *_depl) {
    		_input.template readValue<>(std::get<0>(values_), std::get<2>(_depl->values_));
    	}
    	template<class _Output>
    	void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
    		_output.writeType(std::get<0>(values_), _depl);
    	}
    	template<class _Output, class _Deployment>
    	void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const _Deployment *_depl) {
    		_output.writeType(std::get<0>(values_), std::get<2>(_depl->values_));
    	}
    
    	template<class _Output>
    	void writeValue(CommonAPI::OutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
    	    (void) _depl;
    		_output.template writeValue<CommonAPI::EmptyDeployment>(std::get<0>(values_));
    	}
    
    	template<class _Output, class _Deployment>
    	void writeValue(CommonAPI::OutputStream<_Output> &_output, const _Deployment *_depl) {
    		_output.template writeValue<>(std::get<0>(values_), std::get<2>(_depl->values_));
    	}
    	inline const uint32_t &getAdditionalValue() const { return std::get<0>(values_); }
    	inline void setAdditionalValue(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	
    	std::tuple<uint32_t> values_;
    	inline bool operator==(const TestExtendedPolymorphicStruct& _other) const {
                return (getTestString() == _other.getTestString() && getUintValue() == _other.getUintValue() && getAdditionalValue() == _other.getAdditionalValue());
        }
    	inline bool operator!=(const TestExtendedPolymorphicStruct &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::unordered_map<uint8_t, std::shared_ptr<TestPolymorphicStruct>> MapIntToPolymorphic;
    struct StructWithPolymorphicMember : CommonAPI::Struct<uint32_t, std::shared_ptr<TestPolymorphicStruct>> {
    	
    	StructWithPolymorphicMember() {
    	}
    	StructWithPolymorphicMember(const uint32_t &_numberValue, const std::shared_ptr<TestPolymorphicStruct> &_polymorphicMember)
    	{
    		std::get<0>(values_) = _numberValue;
    		std::get<1>(values_) = _polymorphicMember;
    	}
    	inline const uint32_t &getNumberValue() const { return std::get<0>(values_); }
    	inline void setNumberValue(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	inline const std::shared_ptr<TestPolymorphicStruct> &getPolymorphicMember() const { return std::get<1>(values_); }
    	inline void setPolymorphicMember(const std::shared_ptr<TestPolymorphicStruct> &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const StructWithPolymorphicMember& _other) const {
                return (getNumberValue() == _other.getNumberValue() && getPolymorphicMember() == _other.getPolymorphicMember());
        }
    	inline bool operator!=(const StructWithPolymorphicMember &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct StructWithEnumKeyMap : CommonAPI::Struct<TestEnumMap> {
    	
    	StructWithEnumKeyMap() {
    	}
    	StructWithEnumKeyMap(const TestEnumMap &_testMap)
    	{
    		std::get<0>(values_) = _testMap;
    	}
    	inline const TestEnumMap &getTestMap() const { return std::get<0>(values_); }
    	inline void setTestMap(const TestEnumMap &_value) { std::get<0>(values_) = _value; }
    	inline bool operator==(const StructWithEnumKeyMap& _other) const {
                return (getTestMap() == _other.getTestMap());
        }
    	inline bool operator!=(const StructWithEnumKeyMap &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "commonapi.tests.DerivedTypeCollection";
    return typeCollectionName;
}


}; // struct DerivedTypeCollection

} // namespace tests
} // namespace commonapi

namespace CommonAPI {
}


namespace std {
    //Hash for TestEnum
    template<>
    struct hash<::commonapi::tests::DerivedTypeCollection::TestEnum> {
        inline size_t operator()(const ::commonapi::tests::DerivedTypeCollection::TestEnum& testEnum) const {
            return static_cast<int32_t>(testEnum);
        }
    };
    //Hash for TestEnumExtended2
    template<>
    struct hash<::commonapi::tests::DerivedTypeCollection::TestEnumExtended2> {
        inline size_t operator()(const ::commonapi::tests::DerivedTypeCollection::TestEnumExtended2& testEnumExtended2) const {
            return static_cast<int32_t>(testEnumExtended2);
        }
    };
    //Hash for TestEnumMissingValue
    template<>
    struct hash<::commonapi::tests::DerivedTypeCollection::TestEnumMissingValue> {
        inline size_t operator()(const ::commonapi::tests::DerivedTypeCollection::TestEnumMissingValue& testEnumMissingValue) const {
            return static_cast<int32_t>(testEnumMissingValue);
        }
    };
    //Hash for TestEnumExtended
    template<>
    struct hash<::commonapi::tests::DerivedTypeCollection::TestEnumExtended> {
        inline size_t operator()(const ::commonapi::tests::DerivedTypeCollection::TestEnumExtended& testEnumExtended) const {
            return static_cast<int32_t>(testEnumExtended);
        }
    };
}



#endif // COMMONAPI_TESTS_Derived_Type_Collection_HPP_
